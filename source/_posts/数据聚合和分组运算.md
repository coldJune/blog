---
title: 数据聚合和分组运算
date: 2018-03-25 14:34:00
categories: 数据分析
copyright: true
tags:
    - 聚合和分组
    - 数据分析
description: 对数据进行分组并对各组应用一个函数是数据分析工作的重要环节
---
Python和pandas可以利用任何合一接受pandas对象或NumPy数组的函数执行复杂的分组运算：
1. 根据一个或多个键(可以是函数、数组或DataFrame列名)拆分pandas对象
2. 计算分组摘要统计，如计数、平均数、标准差或用户自定义函数
3. 对DataFrame的列应用各种各样的函数
4. 应用组内转换或其他运算，如规格化、线性回归、排名或选取子集等
5. 计算透视表或交叉表
6. 执行分位数分析以及其他分组分析

## GroupBy技术
pandas对象(无论是Series、DataFrane还是其他)中的数据会根据提供的一个或多个键被拆分(split)为多组。拆分操作是在对象的特定轴上执行。然后将一个函数应用(apply)到各个分组并产生一个新值。最后这些函数的执行结果会被合并(combine)到最终结果中。结果对象的形式一般取决于数据上所执行的操作。
* split-apply-combine(分组聚合)
![分组聚合](数据聚合和分组运算/分股聚合演示.png) 

分组键可以有多种形式，且类型不必相同(后三种只是快捷方式其最终目的是产生一组用于拆分对象的值)：
1. 列表或数组，其长度和待分组轴一样
2. 表示DataFrame某个列名的值
3. 字典或Series，给出待分组轴上的值或分组名之间的对应关系
4. 函数、用于处理轴索引或索引中的各个标签

```Python
In [4]: df = DataFrame({'key1':list('aabba'),
   ...:                 'key2':['one','two','one','two','one'],
   ...:                 'data1':np.random.randn(5),
   ...:                 'data2':np.random.randn(5)})
   ...:

In [5]: df
Out[5]:
      data1     data2 key1 key2
0 -0.007051  1.406114    a  one
1  1.136247  1.320876    a  two
2  0.285600 -2.665997    b  one
3  1.578314  0.772522    b  two
4  0.263382 -0.067916    a  one

In [6]: #按key1进行分组，并计算data1的平均值

In [7]: #访问data1，并根据key1调用groupby

In [8]: grouped = df['data1'].groupby(df['key1'])

In [9]: grouped #变量grouped是一个GroupBy对象。它没有进行任何计算，该对象已经有了接下来对分组执行运算所需的一切信息
Out[9]: <pandas.core.groupby.SeriesGroupBy object at 0x11292e4e0>

In [10]: #调用GroupBy的mean方法计算分组平均值

In [11]: grouped.mean()#数据(Series)根据分组键进行了聚合，产生新的一个Series，其索引为key1列中的唯一值
Out[11]:
key1
a    0.464193
b    0.931957
Name: data1, dtype: float64

In [12]: # 传入多个数组

In [15]: means = df['data1'].groupby([df['key1'],df['key2']]).mean()#通过两个键对数据进行了分组，得到一个Series具有层次化索引(由唯一的建对组成)

In [16]: means
Out[16]:
key1  key2
a     one     0.128166
      two     1.136247
b     one     0.285600
      two     1.578314
Name: data1, dtype: float64

In [17]: means.unstack()
Out[17]:
key2       one       two
key1
a     0.128166  1.136247
b     0.285600  1.578314
```

以上分组键均为Series，2⃣️分组键可以是任何 **长度适当**的数组，也可以将列名(可以是字符串、数字或其他Python对象)用作分组键:
```Python
In [18]: states=np.array(['Ohio','California','California','Ohio','Ohio'])

In [19]: years = np.array([2005,2005,2006,2005,2006])

In [20]: df['data1'].groupby([states,years]).mean()#分组键为适当长度的数组
Out[20]:
California  2005    1.136247
            2006    0.285600
Ohio        2005    0.785631
            2006    0.263382
Name: data1, dtype: float64


In [21]: # 分组键为列名

In [22]: df.groupby('key1').mean()
Out[22]:
         data1     data2
key1
a     0.464193  0.886358
b     0.931957 -0.946738

In [23]: # 结果中没有key2列是因为这一列不是数值数据，会从结果中排除。默认情况所有数值列都会被聚合

In [24]: df.groupby(['key1','key2']).mean()
Out[24]:
              data1     data2
key1 key2
a    one   0.128166  0.669099
     two   1.136247  1.320876
b    one   0.285600 -2.665997
     two   1.578314  0.772522
```

### 对分组进行迭代
GroupBy对象支持迭代，可以产生一组二元元组(由分组名和数据块组成):
```Python
In [26]: for name, group in df.groupby('key1'):
    ...:     print('分组名',name)
    ...:     print('数据块\n',group)
    ...:
分组名 a
数据块
       data1     data2 key1 key2
0 -0.007051  1.406114    a  one
1  1.136247  1.320876    a  two
4  0.263382 -0.067916    a  one
分组名 b
数据块
       data1     data2 key1 key2
2  0.285600 -2.665997    b  one
3  1.578314  0.772522    b  two
```
对于多重键的情况，元组的第一个元素将会是由键值组成的元组：
```Python
In [28]: for (k1,k2), group in df.groupby(['key1','key2']):
    ...:     print(k1,k2)
    ...:     print(group)
    ...:
a one
      data1     data2 key1 key2
0 -0.007051  1.406114    a  one
4  0.263382 -0.067916    a  one
a two
      data1     data2 key1 key2
1  1.136247  1.320876    a  two
b one
    data1     data2 key1 key2
2  0.2856 -2.665997    b  one
b two
      data1     data2 key1 key2
3  1.578314  0.772522    b  two

In [33]: # 将数据片段转化成一个字典

In [34]: pieces = dict(list(df.groupby('key1')))

In [35]: pieces['a']
Out[35]:
      data1     data2 key1 key2
0 -0.007051  1.406114    a  one
1  1.136247  1.320876    a  two
4  0.263382 -0.067916    a  one

In [36]: pieces
Out[36]:
{'a':       data1     data2 key1 key2
 0 -0.007051  1.406114    a  one
 1  1.136247  1.320876    a  two
 4  0.263382 -0.067916    a  one, 'b':       data1     data2 key1 key2
 2  0.285600 -2.665997    b  one
 3  1.578314  0.772522    b  two}
```

`groupby`默认是在`axis=0`(DataFrame行)上进行分组，通过设置可以在其他任何轴上进行分组：
```Python
In [42]: # 通过dtype对列进行分组

In [43]: grouped = df.groupby(df.dtypes, axis=1)

In [44]: dict(list(grouped))
Out[44]:
{dtype('float64'):       data1     data2
 0 -0.007051  1.406114
 1  1.136247  1.320876
 2  0.285600 -2.665997
 3  1.578314  0.772522
 4  0.263382 -0.067916, dtype('O'):   key1 key2
 0    a  one
 1    a  two
 2    b  one
 3    b  two
 4    a  one}
```

### 选取一个或一组列
对于由DataFrame产生的GroupBy对象，如果用一个(单个字符串)或一组(字符串数组)列名对其进行索引，就能实现选取部分列进行聚合的目的：`df.groupby('key1')['data1']`相当于`df['data1'].groupby('key1')`；`df.groupby('key1')[['data2']]`相当于`df[['data2']].groupby(df['key1'])`。对于大数据集很可能只需要对部分列进行聚合，这种索引操作返回的对象是一个DataFrame(如果传入的是列表或数组)或已分组的Series(如果传入的是标量形式的单个列名):
```Python
In [46]: # 计算data2列的平均值并以DataFrame形式得到结果

In [47]: df.groupby(['key1','key2'])[['data2']].mean()
Out[47]:
              data2
key1 key2
a    one   0.669099
     two   1.320876
b    one  -2.665997
     two   0.772522

In [48]: s_grouped= df.groupby(['key1','key2'])['data2']

In [49]: s_grouped
Out[49]: <pandas.core.groupby.SeriesGroupBy object at 0x1119a86a0>

In [50]: s_grouped.mean()
Out[50]:
key1  key2
a     one     0.669099
      two     1.320876
b     one    -2.665997
      two     0.772522
Name: data2, dtype: float64
```

### 通过字典或Series进行分组
除了数组以外，分组信息可以是 **字典**和 **Series**。Series会被看成一个固定大小的映射，如果用Series作为分组键，则pandas会检查Series以确保其索引跟分组轴对齐：
```Python
In [55]: people = DataFrame(np.random.randn(5,5),
    ...:                    columns=list('abcde'),
    ...:                    index=['tom','john','jim','lancy','lucy'])
    ...:

In [56]: people.loc[2:3,['b','c']] = np.nan

In [57]: people
Out[57]:
              a         b         c         d         e
tom    1.522909 -1.357885 -0.262730  0.180761 -1.662128
john   0.941963 -0.330136  0.520398 -0.069789  0.856472
jim   -0.077905       NaN       NaN  0.527588 -0.162906
lancy -0.141172  0.699214 -0.602441 -2.306901 -0.228982
lucy  -1.345708  0.931025  0.615641 -0.733455  1.321982

In [58]: # 字典作为分组键

In [59]: mapping = {'a':'red', 'b':'red', 'c':'blue',
    ...:            'd':'blue', 'e':'red', 'f':'orange'}
    ...:

In [60]: by_column = people.groupby(mapping, axis=1)

In [61]: by_column.sum()
Out[61]:
           blue       red
tom   -0.081968 -1.497105
john   0.450609  1.468299
jim    0.527588 -0.240812
lancy -2.909342  0.329059
lucy  -0.117814  0.907299

In [64]: # Series用作分组键

In [65]: map_series = Series(mapping)

In [66]: people.groupby(map_series, axis=1).count()
Out[66]:
       blue  red
tom       2    3
john      2    3
jim       1    2
lancy     2    3
lucy      2    3
```

### 通过函数进行分组
任何作为分组键的函数都会在各个索引值上被调用一次，其返回值就会被用作分类名称；同时将函数跟数组、列表、字典、Series混用也可以，因为任何东西都会被转换为数组：
```Python
In [67]: # 根据人名的长度进行分组，可以仅仅传入一个len函数

In [68]: people.groupby(len).sum()
Out[68]:
          a         b         c         d         e
3  1.445004 -1.357885 -0.262730  0.708349 -1.825035
4 -0.403745  0.600890  1.136039 -0.803243  2.178454
5 -0.141172  0.699214 -0.602441 -2.306901 -0.228982

In [72]: # 将函数、列表和数组混用

In [73]: key_list =['one','one','one','two','two']

In [74]: people.groupby([len,key_list]).min()
Out[74]:
              a         b         c         d         e
3 one -0.077905 -1.357885 -0.262730  0.180761 -1.662128
4 one  0.941963 -0.330136  0.520398 -0.069789  0.856472
  two -1.345708  0.931025  0.615641 -0.733455  1.321982
5 two -0.141172  0.699214 -0.602441 -2.306901 -0.228982
```

### 根据索引级别分组
通过`level`关键字传入级别编号或名称来根据索引级别聚合层次化索引数据集:
```Python
In [77]: columns = pd.MultiIndex.from_arrays([['US','US','US','CH','CH'],[1,3,5,1,3]],names=['cty','tenor'])

In [78]: hier_df = DataFrame(np.random.randn(4,5), columns=columns)

In [79]: hier_df
Out[79]:
cty          US                            CH
tenor         1         3         5         1         3
0     -1.544928  0.860951 -1.021428  0.150361  0.863332
1      1.500901  0.411124  0.717717 -1.186560 -0.341670
2      1.728200  0.507285 -0.974570  0.856083  0.606669
3      0.356776  0.399169 -0.254092  0.274927  0.169848

In [80]: hier_df.groupby(level='cty',axis=1).count()
Out[80]:
cty  CH  US
0     2   3
1     2   3
2     2   3
3     2   3
```