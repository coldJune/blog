---
title: 时间序列(一)
date: 2018-03-27 09:00:40
categories: 数据分析
copyright: true
tags:
    - 时间序列
    - 数据分析
description: 无论在什么领域中，时间序列(time series)数据是一种重要的结构化数据
---
在多个时间点观察或测量到的任何事物都可以形成一段时间序列。很多时间序列是固定频率的，数据点是根据某种规律定期出现的(比如没15秒、每5分钟、每月出现一次)。时间序列也可以是不定期的。时间序列数据的意义取决于具体的应用场景，主要有几种:
1. 时间戳(timestamp)，特定的时刻
2. 固定时期(period)，如2018年3月或2018年全年
3. 时间间隔(interval),由起始和结束时间戳表示。时期(period)可以被看做间隔(interval)的特例。
4. 实验或过程时间，每个时间点都是相对于特定起始时间的一个度量。例如，从放入烤箱时起，每秒钟饼干的直径

## 日期和时间数据类型及工具
Python标准库包含用于日期(date)和时间(time)数据的数据类型，而且有日历方面的功能。主要用到的事`datetime`、`time`、`canlendar`模块；`datetime`以毫秒形式存储日期和时间；`datetime.timedelta`表示两个datetime对象之间的时间差，可以给datetime对象加上(或减去)一个或多个timedelta产生一个新对象
* datetime模块中的数据类型

|   类型    |                   说明                   |
|:---------:|:----------------------------------------:|
|   date    |    以公历形式存储日历日期(年、月、日)    |
|   time    |       将时间存储为时、分、秒、毫秒       |
| datetime  |              存储日期和时间              |
| timedelta | 表示两个datetime值之间的差(日、秒、毫秒) |

```Python
In [1]: from datetime import datetime

In [2]: now  = datetime.now()

In [3]: now
Out[3]: datetime.datetime(2018, 3, 27, 9, 18, 40, 701738)

In [4]: now.year, now.month, now.day
Out[4]: (2018, 3, 27)

In [5]: # 使用timedelta

In [6]: delta = datetime.now() - datetime(2017,8,4)

In [7]: delta
Out[7]: datetime.timedelta(235, 33622, 69715)

In [8]: delta.days
Out[8]: 235

In [9]: delta.seconds
Out[9]: 33622

In [10]: # 加减timedelta

In [11]: from datetime import timedelta

In [12]: start = datetime.now()

In [13]: start+timedelta(12)
Out[13]: datetime.datetime(2018, 4, 8, 9, 21, 53, 280284)

In [14]: start - 2*timedelta(2)
Out[14]: datetime.datetime(2018, 3, 23, 9, 21, 53, 280284)
```

### 字符串和datetime的相互转换
利用`str`或`strftime`方法(传入一个格式化字符串),datetime对象和pandas的Timestamp对象可以被格式化为字符串`datetime.strptime`可以使用相应的格式化编码将字符串转换为日期[^1]
* datetime格式定义

| 代码 |                                             说明                                             |
|:----:|:--------------------------------------------------------------------------------------------:|
|  %Y  |                                          4位数的年                                           |
|  %y  |                                          2位数的年                                           |
|  %m  |                                       2位数的月[01,12]                                       |
|  %d  |                                       2位数的日[01,31]                                       |
|  %H  |                                     时(24小时制)[00,23]                                      |
|  %I  |                                     是(12小时制)[01,12]                                      |
|  %M  |                                       2位数的分[00,59]                                       |
|  %S  |                                 秒[00,61](秒60和61用于闰秒)                                  |
|  %w  |                               用整数表示的星期几[0(星期天),6]                                |
|  %U  | 每年的第几周[00,53]。星期天被认为是每周的第一天，每年第一个星期天之前的那几天被认为是"第0周" |
|  %W  | 每年的第几周[00,53]。星期一被认为是每周的第一天，每年第一个星期一之前的那几天被认为是"第0周" |
|  %z  |                      以+HHMM或-HHMM表示的UTC时区为naive，则返回空字符串                      |
|  %F  |                               %Y0%m-%d简写形式，例如2018-03-27                               |
|  %D  |                                 %m%d%y简写形式，例如03/27/18                                 |

* 特定于当前环境的日期格式

| 代码 |                              说明                               |
|:----:|:---------------------------------------------------------------:|
|  %a  |                          星期几的简写                           |
|  %A  |                          星期几的全称                           |
|  %b  |                           月份的简写                            |
|  %B  |                           月份的全称                            |
|  %c  |       完整的日期和时间。例如"Tue 01 May 2012 04:20:57 PM"       |
|  %p  |                       不同环境中的AM或PM                        |
|  %x  | 适用于当前环境的日期格式，在美国“May 1, 2012”会产生"05/01/2012" |
|  %X  |           适用于当前环境的时间格式，例如"04:24:12 PM"           |

`datetime.strptime`是通过已知格式进行日期解析的最佳方式，而对于一些常见的日期格式，可以使用`dateutil`这个三方包中的`parser.parse`方法来避免编写格式定义；`dateutil`可以解析除中文外几乎所有人类能够理解的日期表现形式[^2]
```Python
In [18]: #将日期转换为字符串

In [19]: stamp = datetime.now()

In [20]: str(stamp)
Out[20]: '2018-03-27 14:19:08.645810'

In [21]: stamp.strftime('%Y-%m-%d')
Out[21]: '2018-03-27'

In [22]: #将字符串转换为日期

In [23]: value = '2018-03-27'

In [24]: datetime.strptime(value,'%Y-%m-%d')
Out[24]: datetime.datetime(2018, 3, 27, 0, 0)

In [25]: datestrs = ['8/4/2017','3/27/2018']

In [27]: [datetime.strptime(x, '%m/%d/%Y') for x in datestrs]
Out[27]: [datetime.datetime(2017, 8, 4, 0, 0), datetime.datetime(2018, 3, 27, 0, 0)]

In [30]: from dateutil.parser import parse

In [31]: parse('2018/03/27')
Out[31]: datetime.datetime(2018, 3, 27, 0, 0)

In [32]: parse('Jan 31, 1997 10:45 PM')
Out[32]: datetime.datetime(1997, 1, 31, 22, 45)

In [33]: # 日出现在月的前面，传入dayfirst = True

In [34]: parse('4/8/2017', dayfirst=True)
Out[34]: datetime.datetime(2017, 8, 4, 0, 0)
```
pandas通常是用于处理成组日期的，不管这些日期时DataFrame的轴索引还是列。`to_datetime`方法可以解析多种不同的日期表示形式，并且它还可以处理缺失值(None、空字符串等)，*NaT(Not a Time)* 是pandas中时间戳数据的NA值
```Python
In [45]: datestrs
Out[45]: ['8/4/2017', '3/27/2018']

In [46]: pd.to_datetime(datestrs)
Out[46]: DatetimeIndex(['2017-08-04', '2018-03-27'], dtype='datetime64[ns]', freq=None)

In [47]: idx = pd.to_datetime(datestrs + [None])

In [48]: idx
Out[48]: DatetimeIndex(['2017-08-04', '2018-03-27', 'NaT'], dtype='datetime64[ns]', freq=None)

In [49]: idx[2]
Out[49]: NaT

In [50]: pd.isnull(idx)
Out[50]: array([False, False,  True], dtype=bool)
```
## 时间序列基础
pandas最基本的时间序列类型是以时间戳(以字符串或datetime对象表示)为索引的Series，datetime对象实际上是被放在DatetimeIndex中的，不同索引的时间序列之间的算数运算会自动按日期对齐；pandas使用NumPy的datetime64数据类型以纳秒形式存储时间戳，而DatetimeIndex中各个标量值是pandas的Timestamp对象，在需要的时候Timestamp可以随时自动转换为datetime对象，并且它还可以存储频率信息，且知道如何执行时区转换以及其他操作：
```Python
In [58]: # 创建时间序列

In [59]: dates = [datetime(2018,3,d) for d in range(21,27)]

In [60]: ts = Series(np.random.randn(6), index=dates)

In [61]: ts
Out[61]:
2018-03-21    0.555044
2018-03-22   -0.404548
2018-03-23   -1.334704
2018-03-24   -0.550604
2018-03-25    0.037230
2018-03-26    0.298817
dtype: float64

In [62]: # ts的类型

In [63]: type(ts)
Out[63]: pandas.core.series.Series

In [64]: ts.index
Out[64]:
DatetimeIndex(['2018-03-21', '2018-03-22', '2018-03-23', '2018-03-24',
               '2018-03-25', '2018-03-26'],
              dtype='datetime64[ns]', freq=None)

In [65]: # 不同索引的时间序列之间的算数运算会自动按日期对齐

In [66]: ts+ts[::2]
Out[66]:
2018-03-21    1.110088
2018-03-22         NaN
2018-03-23   -2.669409
2018-03-24         NaN
2018-03-25    0.074461
2018-03-26         NaN
dtype: float64

In [67]: # 时间戳类型

In [68]: ts.index.dtype
Out[68]: dtype('<M8[ns]')

In [69]: #DateIndex中的各个标量值是pandas的Timestamp对象

In [70]: stamp =ts.index[0]

In [71]: stamp
Out[71]: Timestamp('2018-03-21 00:00:00')
```

### 索引、选取、子集构造
索引和数据选取和Series的行为相同，也可以传入一个被解释为日期的字符串；对于较长的时间序列，可以传入 **"年"** 或 **"年月"** 选取数据的切片，而通过日期切片的方式只对规则Series有效；对大部分时间序列的数据来说都是按照时间先后排序的，因此可以用不存在于改时间序列中的时间戳进行切片(即范围查找)，而这里同样可以传入字符串日期、datetime或Timestamp，**和NumPy一样都是产生原时间序列的视图**。可以调用`truncate`方法并传入`before`和`after`来实现相同的效果。而这些对DataFrame同样有效:
```Python
In [73]: # 选取索引和数据

In [74]: stamp = ts.index[2]

In [75]: ts[stamp]
Out[75]: -1.3347042513067129

In [81]: # 通过"年"或"年月"切片

In [82]: long_ts = Series(np.random.randn(1000),index=pd.date_range('1/1/2018', periods=1000))

In [83]: long_ts
Out[83]:
2018-01-01    0.047281
2018-01-02   -0.630386
2018-01-03    0.630630
                ...
2020-09-26    0.993575
Freq: D, Length: 1000, dtype: float64

In [84]: long_ts['2019']
Out[84]:
2019-01-01    0.890328
2019-01-02   -1.131193
2019-01-03   -0.225457
2019-01-04   -0.097514
                ...
2019-12-28    1.096610
2019-12-29    0.534131
2019-12-30   -1.859665
2019-12-31   -0.408150
Freq: D, Length: 365, dtype: float64

In [85]: long_ts['2019-09']
Out[85]:
2019-09-01    0.950379
2019-09-02    0.508369
2019-09-03    0.631864
                ...
2019-09-26    1.982801
2019-09-27    1.626522
2019-09-28    0.546744
2019-09-29   -0.971617
2019-09-30    0.106587
Freq: D, dtype: float64

In [88]: # 通过日期进行切片

In [89]: ts[datetime(2018,3,24):]
Out[89]:
2018-03-24   -0.550604
2018-03-25    0.037230
2018-03-26    0.298817
dtype: float64

In [95]: # 按时间戳进行切片

In [96]: ts
Out[96]:
2018-03-21    0.555044
2018-03-22   -0.404548
2018-03-23    1.000000
2018-03-24    1.000000
2018-03-25    1.000000
2018-03-26    0.298817
dtype: float64

In [97]: ts['23/3/2018':'25/3/2018']
Out[97]:
2018-03-23    1.0
2018-03-24    1.0
2018-03-25    1.0
dtype: float64

In [119]: #切片数据是源数据的视图

In [120]: ts = Series(np.random.randn(6), index=dates)

In [121]: ts
Out[121]:
2018-03-21   -0.209784
2018-03-22   -0.034117
2018-03-23   -0.383131
2018-03-24    1.207778
2018-03-25   -1.419493
2018-03-26    0.019064
dtype: float64

In [122]: ts_slice = ts['23/3/2018':'25/3/2018']

In [123]: ts_slice[0]=1

In [124]: ts
Out[124]:
2018-03-21   -0.209784
2018-03-22   -0.034117
2018-03-23    1.000000
2018-03-24    1.207778
2018-03-25   -1.419493
2018-03-26    0.019064
dtype: float64

In [125]: #通过truncate实现切片并实现复制

In [126]: ts.truncate(after='24/3/2018', copy=True)
Out[126]:
2018-03-21   -0.209784
2018-03-22   -0.034117
2018-03-23    1.000000
2018-03-24    1.207778
dtype: float64

In [127]: ts_slice = ts.truncate(after='24/3/2018', copy=True)

In [128]: ts_slice[0]=1

In [129]: ts
Out[129]:
2018-03-21   -0.209784
2018-03-22   -0.034117
2018-03-23    1.000000
2018-03-24    1.207778
2018-03-25   -1.419493
2018-03-26    0.019064
dtype: float64

In [130]: # 对DataFrame的行进行索引

In [131]: date = pd.date_range('1/3/2018', periods=100, freq='W-WED')

In [132]: long_df = DataFrame(np.random.randn(100,4),
     ...:                     index=date,
     ...:                     columns=['col1','col2','col3','col4'])
     ...:

In [133]: long_df.loc['5-2018']
Out[133]:
                col1      col2      col3      col4
2018-05-02 -1.217853 -0.052510  1.854937  0.187870
2018-05-09  0.555552 -0.276599 -0.145089 -0.676329
2018-05-16  0.704234  0.316785 -0.057501  0.033567
2018-05-23  0.451673  0.367754  0.121129 -0.861855
2018-05-30 -1.057437 -0.904105 -0.025711 -2.689067

```

### 带有重复索引的时间序列
当多个观测数据落在同一个时间点上的时候，可以通过检查索引的`is_unique`属性来确定它是否唯一，而对这个时间序列进行索引要么产生 **标量值**(不重复)，要么产生 **切片**(重复)；如果需要对具有非唯一时间戳的数据进行聚合，使用groupby并传入`level=0`(索引的唯一一层):
```Python
In [137]: # 生成时间索引的Series

In [138]: dates = pd.DatetimeIndex(['1/3/2018','1/3/2018','2/3/2018','2/3/2018','3/3/2018'])

In [139]: dup_ts = Series(np.arange(5), index=dates)

In [140]: dup_ts
Out[140]:
2018-01-03    0
2018-01-03    1
2018-02-03    2
2018-02-03    3
2018-03-03    4
dtype: int32

In [141]: #检查索引是否唯一

In [142]: dup_ts.index.is_unique
Out[142]: False

In [143]: #对时间序列进行索引

In [144]: dup_ts['3/3/2018'] #不重复
Out[144]: 4

In [145]: dup_ts['2/3/2018'] #重复
Out[145]:
2018-02-03    2
2018-02-03    3
dtype: int32

In [150]: # 进行分组聚合

In [151]: grouped = dup_ts.groupby(level=0)

In [152]: grouped.count()
Out[152]:
2018-01-03    2
2018-02-03    2
2018-03-03    1
dtype: int64

In [153]: grouped.mean()
Out[153]:
2018-01-03    0.5
2018-02-03    2.5
2018-03-03    4.0
dtype: float64
```

## 日期的范围、频率以及移动
pandas有一整套标准时间序列频率以及用于重采样、频率推断、生成固定频率日期范围的工具。调用`resample`方法将时间序列转换为一个具有固定频率的时间序列:
```Python
In [176]: dates = [datetime(2018,3,d) for d in arange(21, 31, step=2)]

In [177]: ts.resample('D').sum()
Out[177]:
2018-03-21   -2.084044
2018-03-22         NaN
2018-03-23    1.075880
2018-03-24         NaN
2018-03-25    0.045201
2018-03-26         NaN
2018-03-27   -0.754086
2018-03-28         NaN
2018-03-29   -0.448258
Freq: D, dtype: float64

In [178]: dates = [datetime(2018,3,d) for d in arange(21, 31, step=2)]

In [179]: ts = Series(np.random.randn(5), index=dates)

In [180]: ts.resample('D').sum() #转换成固定频率(每日)
Out[180]:
2018-03-21   -0.376527
2018-03-22         NaN
2018-03-23    0.282788
2018-03-24         NaN
2018-03-25   -0.014975
2018-03-26         NaN
2018-03-27    1.209955
2018-03-28         NaN
2018-03-29   -1.279524
Freq: D, dtype: float64

```
### 生成日期范围
`pandas.data_range`用于生成指定长度的DatatimeIndex，默认情况下`data_range`会产生按天计算的时间点。如果只传入起始或结束时间，那么的传入一个表示一段时间的数字`periods`。起始和结束日期定义了日期索引的严格边界(*如果想要生成一个由每个月最后一个工作日组成的日期索引，传入"BM"频率，这样只会包含时间间隔内(或刚好在边界上)符合频率要求的日期*)。`data_range`默认会保留起始或结束时间戳的 **时间** 信息(有的话)。如果希望产生一组被规范化到午夜的时间戳，可以设置`normalize=True`：
```Python
In [182]: index = pd.date_range('8/4/2017','3/27/2018')

In [183]: index
Out[183]:
DatetimeIndex(['2017-08-04', '2017-08-05', '2017-08-06', '2017-08-07',
               '2017-08-08', '2017-08-09', '2017-08-10', '2017-08-11',
               '2017-08-12', '2017-08-13',
               ...
               '2018-03-18', '2018-03-19', '2018-03-20', '2018-03-21',
               '2018-03-22', '2018-03-23', '2018-03-24', '2018-03-25',
               '2018-03-26', '2018-03-27'],
              dtype='datetime64[ns]', length=236, freq='D')

In [185]: #传入起始日期或结束日期并设置一段时间

In [186]: pd.date_range(start='8/4/2017',periods=20)
Out[186]:
DatetimeIndex(['2017-08-04', '2017-08-05', '2017-08-06', '2017-08-07',
               '2017-08-08', '2017-08-09', '2017-08-10', '2017-08-11',
               '2017-08-12', '2017-08-13', '2017-08-14', '2017-08-15',
               '2017-08-16', '2017-08-17', '2017-08-18', '2017-08-19',
               '2017-08-20', '2017-08-21', '2017-08-22', '2017-08-23'],
              dtype='datetime64[ns]', freq='D')

In [187]: pd.date_range(end='8/4/2017',periods=20)
Out[187]:
DatetimeIndex(['2017-07-16', '2017-07-17', '2017-07-18', '2017-07-19',
               '2017-07-20', '2017-07-21', '2017-07-22', '2017-07-23',
               '2017-07-24', '2017-07-25', '2017-07-26', '2017-07-27',
               '2017-07-28', '2017-07-29', '2017-07-30', '2017-07-31',
               '2017-08-01', '2017-08-02', '2017-08-03', '2017-08-04'],
              dtype='datetime64[ns]', freq='D')

In [188]: #传入频率

In [189]: pd.date_range('8/4/2017','3/27/2018', freq='BM')
Out[189]:
DatetimeIndex(['2017-08-31', '2017-09-29', '2017-10-31', '2017-11-30',
               '2017-12-29', '2018-01-31', '2018-02-28'],
              dtype='datetime64[ns]', freq='BM')

In [193]: #保留时间信息

In [194]: pd.date_range('8/4/2017 12:21:56', periods=5)
Out[194]:
DatetimeIndex(['2017-08-04 12:21:56', '2017-08-05 12:21:56',
               '2017-08-06 12:21:56', '2017-08-07 12:21:56',
               '2017-08-08 12:21:56'],
              dtype='datetime64[ns]', freq='D')

In [203]: #规范化时间

In [204]: date_r = pd.date_range('8/4/2017 12:21:56', periods=5, normalize=True)

In [205]: date_r[1]
Out[205]: Timestamp('2017-08-05 00:00:00', freq='D')
```

### 频率和日期偏移量
pandas中的频率由一个 **基础频率** 和一个 **乘数** 组成。基础频率通常以一个字符串别名表示，比如“M”表示每月，“H”表示每小时。对于每个基础频率，都有一个被称为 **日期偏移量** 的对象与之对应。按小时计算可以使用Hour类，传入一个整数即可定义偏移量的倍数。一般来说无需显式创建便宜对象，直接使用诸如"H"或"4H"这样的字符串别名即可，在基础频率前加上一个整数可创建倍数；大部分的偏移量对象可以通过加法进行连接，而传入"1h30min"这样的频率字符串也能被高效地解析为等效的表达式。有些频率描述的时间点并不是均匀分隔的。(*"M"(日历月末)和"BM"(每月最后一个工作日)就取决于每月的天数，对于后者还要考虑月末是不是周末，这种称为锚点偏移量(anchored offset)[^3]*)。

* 时间序列的基础频率

|         别名          |      偏移量类型      |                                                         说明                                                         |
|:---------------------:|:--------------------:|:--------------------------------------------------------------------------------------------------------------------:|
|           D           |         Day          |                                                       每日历日                                                       |
|           B           |     BusinessDay      |                                                       每工作日                                                       |
|           H           |         Hour         |                                                        每小时                                                        |
|        T或min         |        Minute        |                                                         每分                                                         |
|           S           |        Second        |                                                         每秒                                                         |
|         L或ms         |        Milli         |                                                每毫秒(即每千分之一秒)                                                |
|           U           |        Micro         |                                               每微秒(即每百万分之一秒)                                               |
|           M           |       MonthEnd       |                                                  每月最后一个日历日                                                  |
|          BM           |   BusinessMonthEnd   |                                                  每月最后一个工作日                                                  |
|          MS           |      MonthBegin      |                                                   每月第一个日历日                                                   |
|          BMS          |  BusinessMonthBegin  |                                                   每月第一个工作日                                                   |
|    W-MON、W-TUE...    |         Week         |                           从指定的星期几(MON、TUE、WED、THU、FRI、SAT、SUN)开始算起，每周                            |
| WOM-1MON、WOM-2MON... |     WeekOfMonth      |                    产生每月第一、第二、第三或第四轴的星期几。例如，WOM-3FRI表示每月的第三个星期五                    |
|    Q-JAN、Q-FEB...    |      QuaterEnd       | 对于以指定月份(JAN、FEB、MAR、APR、MAY、JUN、JUL、AUG、SEP、OCT、NOV、DEC)结束的年度，每季度最后一月的最后一个日历日 |
|   BQ-JAN、BQ-FEB...   |  BusinessQuarterEnd  |                              对于以指定月份结束的年度，每季度最后一个月的最后一个工作日                              |
|   QS-JAN、QS-FEB...   |     QuarterBegin     |                                对于以指定月份结束的年度，每季度最后一月的第一个日历日                                |
|  BQS-JAN、BQS-FEB...  | BusinessQuarterBegin |                                对于以指定月份结束的年度，每季度最后一月的第一个工作日                                |
|    A-JAN、A-FEB...    |       YearEnd        |               每年指定月份(JAN、FEB、MAR、APR、MAY、JUN、JUL、AUG、SEP、OCT、NOV、DEC)的最后一个日历日               |
|   BA-JAN、BA-FEB...   |   BusinessYearEnd    |                                             每年指定月份的最后一个工作日                                             |
|   AS-JAN、AS-FEB...   |      YearBegin       |                                             每年指定月份的最后一个日历日                                             |
|  BAS-JAN、BAS-FEB...  |  BusinessYearBegin   |                                             每年指定月份的最后一个工作日                                             |

```Python
In [189]: #按小时计算的频率

In [190]: from pandas.tseries.offsets import Hour, Minute

In [191]: hour = Hour()

In [192]: hour
Out[192]: <Hour>

In [193]: four_hours = Hour(4)

In [194]: four_hours
Out[194]: <4 * Hours>

In [195]: #使用“H”或“4H”字符串别名

In [196]: pd.date_range('3/27/2018','3/30/2018', freq='4h')
Out[196]:
DatetimeIndex(['2018-03-27 00:00:00', '2018-03-27 04:00:00',
               '2018-03-27 08:00:00', '2018-03-27 12:00:00',
               '2018-03-27 16:00:00', '2018-03-27 20:00:00',
               '2018-03-28 00:00:00', '2018-03-28 04:00:00',
               '2018-03-28 08:00:00', '2018-03-28 12:00:00',
               '2018-03-28 16:00:00', '2018-03-28 20:00:00',
               '2018-03-29 00:00:00', '2018-03-29 04:00:00',
               '2018-03-29 08:00:00', '2018-03-29 12:00:00',
               '2018-03-29 16:00:00', '2018-03-29 20:00:00',
               '2018-03-30 00:00:00'],
              dtype='datetime64[ns]', freq='4H')

In [197]: #通过加法连接偏移量

In [198]: Hour(2)+Minute(30)
Out[198]: <150 * Minutes>

In [199]: #传入频率字符串

In [200]: pd.date_range('3/27/2018',periods=10,freq='2h30min')
Out[200]:
DatetimeIndex(['2018-03-27 00:00:00', '2018-03-27 02:30:00',
               '2018-03-27 05:00:00', '2018-03-27 07:30:00',
               '2018-03-27 10:00:00', '2018-03-27 12:30:00',
               '2018-03-27 15:00:00', '2018-03-27 17:30:00',
               '2018-03-27 20:00:00', '2018-03-27 22:30:00'],
              dtype='datetime64[ns]', freq='150T')
```

#### WOM日期
WOM(Week Of Month)是一种非常实用的频率类，它以 **WOM** 开头，能够获得诸如“每个月第三个星期五”之类的日期：
```Python
In [202]: # 每月第三个星期五

In [203]: rng = pd.date_range('3/1/2018','9/1/2018',freq='WOM-3FRI')

In [204]: rng
Out[204]:
DatetimeIndex(['2018-03-16', '2018-04-20', '2018-05-18', '2018-06-15',
               '2018-07-20', '2018-08-17'],
              dtype='datetime64[ns]', freq='WOM-3FRI')
```

### 移动(超前和滞后)数据
**移动(shifting)** 指的是沿着时间轴将数据前移或后移。Series和DataFrame又一个`shift`方法用于执行单纯的前移或后移操作，保持索引不变.`shift`通常用于计算一个时间序列或多个时间序列中的百分比变化(ts/ts.shift(1)-1)。单纯的移位操作不会修改索引，所以部分数据会被丢弃。2⃣️如果频率已知，可以将其传给`shift`来实现对时间戳进行位移而不是对数据进行简单位移：
```Python
In [205]: #使用shift方法对数据移位

In [206]: ts = Series(np.random.randn(4), index=pd.date_range('27/3/2018',periods=4, freq='M'))

In [207]: ts
Out[207]:
2018-03-31    0.590246
2018-04-30   -0.425245
2018-05-31    0.505558
2018-06-30   -0.467728
Freq: M, dtype: float64

In [208]: ts.shift(2)#后移两位
Out[208]:
2018-03-31         NaN
2018-04-30         NaN
2018-05-31    0.590246
2018-06-30   -0.425245
Freq: M, dtype: float64

In [209]: ts.shift(-2)#前移两位
Out[209]:
2018-03-31    0.505558
2018-04-30   -0.467728
2018-05-31         NaN
2018-06-30         NaN
Freq: M, dtype: float64

In [212]: ts.shift(2,freq='M') #通过频率对时间戳进行移位，后移两个月
Out[212]:
2018-05-31    0.590246
2018-06-30   -0.425245
2018-07-31    0.505558
2018-08-31   -0.467728
Freq: M, dtype: float64

In [213]: ts.shift(-3,freq='D') #通过频率对时间戳进行移位，前移3天
Out[213]:
2018-03-28    0.590246
2018-04-27   -0.425245
2018-05-28    0.505558
2018-06-27   -0.467728
dtype: float64

In [214]: ts.shift(-1,freq='3D') #通过频率对时间戳进行移位，前移3天
Out[214]:
2018-03-28    0.590246
2018-04-27   -0.425245
2018-05-28    0.505558
2018-06-27   -0.467728
dtype: float64
```

#### 通过偏移量对日期进行位移
pandas的日期偏移量可以用在datetime或Timestamp对象上；如果是锚点偏移量(比如MethodEnd)，第一次增量会将原日期向前滚动到符合频率规则的下一个日期；通过锚点偏移量的`rollforward`和`rollback`方法，可显式地将日期向前或向后滚动；也可以通过`groupby`或者`resample`方法来滚动:
```Python
In [219]: #在datetime或Timestamp对象上使用日期偏移量

In [220]: from pandas.tseries.offsets import Day, MonthEnd

In [221]: now = datetime.now()

In [222]: now
Out[222]: datetime.datetime(2018, 3, 27, 20, 19, 34, 880551)

In [223]: now + 3* Day()
Out[223]: Timestamp('2018-03-30 20:19:34.880551')

In [224]: #加上锚点偏移量

In [225]: now + MonthEnd()
Out[225]: Timestamp('2018-03-31 20:19:34.880551')

In [226]: now + MonthEnd(2)
Out[226]: Timestamp('2018-04-30 20:19:34.880551')

In [231]: #使用rollforward和rollback方法显式向前或向后滚动日期

In [232]: offset = MonthEnd()

In [233]: offset.rollforward(now) #向前滚动
Out[233]: Timestamp('2018-03-31 20:19:34.880551')

In [234]: offset.rollback(now) #向后滚动
Out[234]: Timestamp('2018-02-28 20:19:34.880551')

In [238]: #使用groupby使用滚动

In [239]: ts = Series(np.random.randn(20), index=pd.date_range('27/3/2018',periods=20, freq='4d'))

In [240]: ts.groupby(offset.rollforward).mean()
Out[240]:
2018-03-31    0.847476
2018-04-30   -0.194661
2018-05-31    0.092392
2018-06-30   -0.710720
dtype: float64

In [243]: # 使用resample

In [244]: ts.resample('M').mean()
Out[244]:
2018-03-31    0.847476
2018-04-30   -0.194661
2018-05-31    0.092392
2018-06-30   -0.710720
Freq: M, dtype: float64
```
## 时区处理
时区是以UTC偏移量的形式表示。在Python中时区信息来自第三方库pytz，它使Python可以使用Olson数据库(汇编了世界时区信息)。而pandas包装了pytz的功能，所以一般不需要单独学习，只需要记住时区名即可。时区名既可以在[官方文档](https://pypi.python.org/pypi/pytz/)中查看也可以通过交互式的方式查看；要从pytz中获取时区对象，使用pytz.timezone即可，pandas方法虽然接收时区名和时区对象，但建议使用时区名：
```Python
In [3]: # 使用交互式方式查看时区名

In [4]: import pytz

In [5]: pytz.common_timezones[-5:]
Out[5]: ['US/Eastern', 'US/Hawaii', 'US/Mountain', 'US/Pacific', 'UTC']

In [6]: # 从pytz中获取时区对象

In [7]: tz = pytz.timezone('US/Hawaii')

In [8]: tz
Out[8]: <DstTzInfo 'US/Hawaii' LMT-1 day, 13:29:00 STD>
```
### 本地化和转换
默认情况下pandas中的时间序列是 **单纯的(naive)** 时区，其索引的tz字段为 *None*，在生成日期范围的时候可以加上`tz=`时区集；从单纯到本地化的转换可以通过`tz_localize`方法处理，一旦时间序列被本地化到某个特定时区，就可以用`tz_convert`将其转换到别的时区;`tz_localize`和`tz_convert`两个方法都是DatetimeIndex的实例方法:
```Python
In [9]: # 生成时间序列

In [10]: rng = pd.date_range('3/29/2018 8:51', periods=6, freq='D')

In [11]: ts = Series(np.random.randn(len(rng)), index=rng)

In [13]: print(ts.index.tz)
None

In [16]: # 在生成日期范围时加上时区集

In [17]: pd.date_range('3/28/2018 8:53',periods=10, freq='D', tz='UTC')
Out[17]:
DatetimeIndex(['2018-03-28 08:53:00+00:00', '2018-03-29 08:53:00+00:00',
               '2018-03-30 08:53:00+00:00', '2018-03-31 08:53:00+00:00',
               '2018-04-01 08:53:00+00:00', '2018-04-02 08:53:00+00:00',
               '2018-04-03 08:53:00+00:00', '2018-04-04 08:53:00+00:00',
               '2018-04-05 08:53:00+00:00', '2018-04-06 08:53:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='D')

In [18]: # 使用tz_localize方法将单纯转换为本地化

In [19]: ts
Out[19]:
2018-03-29 08:51:00   -2.496207
2018-03-30 08:51:00    0.632944
2018-03-31 08:51:00    1.018756
2018-04-01 08:51:00   -0.017984
2018-04-02 08:51:00   -2.522974
2018-04-03 08:51:00    1.096955
Freq: D, dtype: float64

In [20]: ts_utc = ts.tz_localize('UTC')

In [21]: ts_utc
Out[21]:
2018-03-29 08:51:00+00:00   -2.496207
2018-03-30 08:51:00+00:00    0.632944
2018-03-31 08:51:00+00:00    1.018756
2018-04-01 08:51:00+00:00   -0.017984
2018-04-02 08:51:00+00:00   -2.522974
2018-04-03 08:51:00+00:00    1.096955
Freq: D, dtype: float64

In [22]: ts_utc.index
Out[22]:
DatetimeIndex(['2018-03-29 08:51:00+00:00', '2018-03-30 08:51:00+00:00',
               '2018-03-31 08:51:00+00:00', '2018-04-01 08:51:00+00:00',
               '2018-04-02 08:51:00+00:00', '2018-04-03 08:51:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='D')

In [23]: # 使用tz_covert方法转换到别的时区

In [24]: ts_utc.tz_convert('US/Eastern')
Out[24]:
2018-03-29 04:51:00-04:00   -2.496207
2018-03-30 04:51:00-04:00    0.632944
2018-03-31 04:51:00-04:00    1.018756
2018-04-01 04:51:00-04:00   -0.017984
2018-04-02 04:51:00-04:00   -2.522974
2018-04-03 04:51:00-04:00    1.096955
Freq: D, dtype: float64

In [25]: # 将ts本地化到EST再转换为UTC或柏林时间

In [26]: ts_eastern = ts.tz_localize('US/Eastern')

In [27]: ts_eastern.tz_convert('UTC')
Out[27]:
2018-03-29 12:51:00+00:00   -2.496207
2018-03-30 12:51:00+00:00    0.632944
2018-03-31 12:51:00+00:00    1.018756
2018-04-01 12:51:00+00:00   -0.017984
2018-04-02 12:51:00+00:00   -2.522974
2018-04-03 12:51:00+00:00    1.096955
Freq: D, dtype: float64

In [28]: ts_eastern.tz_convert('Europe/Berlin')
Out[28]:
2018-03-29 14:51:00+02:00   -2.496207
2018-03-30 14:51:00+02:00    0.632944
2018-03-31 14:51:00+02:00    1.018756
2018-04-01 14:51:00+02:00   -0.017984
2018-04-02 14:51:00+02:00   -2.522974
2018-04-03 14:51:00+02:00    1.096955
Freq: D, dtype: float64

In [29]: # tz_localize和tz_convert是DatetimeIndex的实例方法

In [30]: ts.index.tz_localize('Asia/Shanghai')
Out[30]:
DatetimeIndex(['2018-03-29 08:51:00+08:00', '2018-03-30 08:51:00+08:00',
               '2018-03-31 08:51:00+08:00', '2018-04-01 08:51:00+08:00',
               '2018-04-02 08:51:00+08:00', '2018-04-03 08:51:00+08:00'],
              dtype='datetime64[ns, Asia/Shanghai]', freq='D')
```

### 操作时区意识型Timestamp对象
跟时间序列和日期范围一样，Timestamp对象也能被从 **单纯型(naive)** 本地化为 **时区意识型(time zone-aware)**，并从一个时区转换到另一个时区；可以在创建Timestamp对象时，传入一个时区信息。时区意识型Timestamp对象在内部保存了一个UTC时间戳值(自UNIX纪元(1970年1月1日)算起的纳秒数)，而这个UTC值在时区转换过程中不会变化，当使用pandas的DateOffset对象执行时间算术运算时，运算过程会自动关注是否存在夏令时转变期:
```Python
In [34]: # 创建Timestamp对象并本地化，转换时区

In [35]: stamp = pd.Timestamp('2018-3-28 9:08')

In [36]: stamp_utc = stamp.tz_localize('UTC') #本地化为UTC

In [37]: stamp_utc
Out[37]: Timestamp('2018-03-28 09:08:00+0000', tz='UTC')

In [38]: stamp_utc.tz_convert('US/Eastern') #转换到USE时区
Out[38]: Timestamp('2018-03-28 05:08:00-0400', tz='US/Eastern')

In [39]: # 创建一个带有时区信息的Timestamp

In [40]: stamp_moscow = pd.Timestamp('2018-3-28 9:00', tz='Asia/Shanghai')

In [41]: stamp_moscow
Out[41]: Timestamp('2018-03-28 09:00:00+0800', tz='Asia/Shanghai')

In [43]: stamp_moscow.value
Out[43]: 1522198800000000000

In [44]: stamp_moscow.tz_convert('US/Eastern').value
Out[44]: 1522198800000000000


In [52]: # DateOffset对象执行算术运算

In [53]: stamp = pd.Timestamp('2012-3-12 1:30', tz='US/Eastern') #夏令时转变前30min

In [54]: stamp + Hour()
Out[54]: Timestamp('2012-03-12 02:30:00-0400', tz='US/Eastern')

In [55]: stamp = pd.Timestamp('2012-11-4 00:30', tz='US/Eastern') #夏令时转变前90min

In [56]: stamp
Out[56]: Timestamp('2012-11-04 00:30:00-0400', tz='US/Eastern')

In [57]: stamp + 2*Hour()
Out[57]: Timestamp('2012-11-04 01:30:00-0500', tz='US/Eastern')
```
### 不同时区之间的运算
如果两个时间序列的时区不同，在将它们合并到一起时，最终结果就会是UTC；而由于时间戳是以UTC存储的，所以不需要发生任何转换:
```Python
In [78]: rng = pd.date_range('3/29/2018 8:51', periods=6, freq='B')

In [79]: ts = Series(np.random.randn(len(rng)), index=rng)

In [80]: # 分别设置时区

In [81]: ts1 = ts[:6].tz_localize('Asia/Shanghai')

In [82]: ts2 = ts1[2:].tz_convert('Europe/Moscow')

In [83]: ts1
Out[83]:
2018-03-29 08:51:00+08:00   -0.685011
2018-03-30 08:51:00+08:00    0.257992
2018-04-02 08:51:00+08:00   -0.650380
2018-04-03 08:51:00+08:00    0.050511
2018-04-04 08:51:00+08:00   -0.441419
2018-04-05 08:51:00+08:00   -1.618306
Freq: B, dtype: float64

In [84]: ts2
Out[84]:
2018-04-02 03:51:00+03:00   -0.650380
2018-04-03 03:51:00+03:00    0.050511
2018-04-04 03:51:00+03:00   -0.441419
2018-04-05 03:51:00+03:00   -1.618306
Freq: B, dtype: float64

In [85]: result = ts1+ts2

In [86]: result.index
Out[86]:
DatetimeIndex(['2018-03-29 00:51:00+00:00', '2018-03-30 00:51:00+00:00',
               '2018-04-02 00:51:00+00:00', '2018-04-03 00:51:00+00:00',
               '2018-04-04 00:51:00+00:00', '2018-04-05 00:51:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')
```
[^1]: 闰秒，是指为保持协调世界时接近于世界时时刻，由国际计量局统一规定在年底或年中（也可能在季末）对协调世界时增加或减少1秒的调整
[^2]: dateutil.parser并不完美，它会将一些原本不是日期的字符串认作是日期(例如将'23'解析成当月的23号，而大于日期的例如'32'会被解析为2032年的今天)
[^3]: 来源于书上的叫法(《利用Python进行数据分析》)
