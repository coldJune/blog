---
title: 时间序列
date: 2018-03-27 09:00:40
categories: 数据分析
copyright: true
tags:
    - 时间序列
    - 数据分析
description: 无论在什么领域中，时间序列(time series)数据是一种重要的结构化数据，
---
在多个时间点观察或测量到的任何事物都可以形成一段时间序列。很多时间序列是固定频率的，数据点是根据某种规律定期出现的(比如没15秒、每5分钟、每月出现一次)。时间序列也可以是不定期的。时间序列数据的意义取决于具体的应用场景，主要有几种:
1. 时间戳(timestamp)，特定的时刻
2. 固定时期(period)，如2018年3月或2018年全年
3. 时间间隔(interval),由起始和结束时间戳表示。时期(period)可以被看做间隔(interval)的特例。
4. 实验或过程时间，每个时间点都是相对于特定起始时间的一个度量。例如，从放入烤箱时起，每秒钟饼干的直径

## 日期和时间数据类型及工具
Python标准库包含用于日期(date)和时间(time)数据的数据类型，而且有日历方面的功能。主要用到的事`datetime`、`time`、`canlendar`模块；`datetime`以毫秒形式存储日期和时间；`datetime.timedelta`表示两个datetime对象之间的时间差，可以给datetime对象加上(或减去)一个或多个timedelta产生一个新对象
* datetime模块中的数据类型
|   类型    |                   说明                   |
|:---------:|:----------------------------------------:|
|   date    |    以公历形式存储日历日期(年、月、日)    |
|   time    |       将时间存储为时、分、秒、毫秒       |
| datetime  |              存储日期和时间              |
| timedelta | 表示两个datetime值之间的差(日、秒、毫秒) |

```Python
In [1]: from datetime import datetime

In [2]: now  = datetime.now()

In [3]: now
Out[3]: datetime.datetime(2018, 3, 27, 9, 18, 40, 701738)

In [4]: now.year, now.month, now.day
Out[4]: (2018, 3, 27)

In [5]: # 使用timedelta

In [6]: delta = datetime.now() - datetime(2017,8,4)

In [7]: delta
Out[7]: datetime.timedelta(235, 33622, 69715)

In [8]: delta.days
Out[8]: 235

In [9]: delta.seconds
Out[9]: 33622

In [10]: # 加减timedelta

In [11]: from datetime import timedelta

In [12]: start = datetime.now()

In [13]: start+timedelta(12)
Out[13]: datetime.datetime(2018, 4, 8, 9, 21, 53, 280284)

In [14]: start - 2*timedelta(2)
Out[14]: datetime.datetime(2018, 3, 23, 9, 21, 53, 280284)
```

### 字符串和datetime的相互转换
利用`str`或`strftime`方法(传入一个格式化字符串),datetime对象和pandas的Timestamp对象可以被格式化为字符串`datetime.strptime`可以使用相应的格式化编码将字符串转换为日期[^1]
* datetime格式定义

| 代码 |                                             说明                                             |
|:----:|:--------------------------------------------------------------------------------------------:|
|  %Y  |                                          4位数的年                                           |
|  %y  |                                          2位数的年                                           |
|  %m  |                                       2位数的月[01,12]                                       |
|  %d  |                                       2位数的日[01,31]                                       |
|  %H  |                                     时(24小时制)[00,23]                                      |
|  %I  |                                     是(12小时制)[01,12]                                      |
|  %M  |                                       2位数的分[00,59]                                       |
|  %S  |                                 秒[00,61](秒60和61用于闰秒)                                  |
|  %w  |                               用整数表示的星期几[0(星期天),6]                                |
|  %U  | 每年的第几周[00,53]。星期天被认为是每周的第一天，每年第一个星期天之前的那几天被认为是"第0周" |
|  %W  | 每年的第几周[00,53]。星期一被认为是每周的第一天，每年第一个星期一之前的那几天被认为是"第0周" |
|  %z  |                      以+HHMM或-HHMM表示的UTC时区为naive，则返回空字符串                      |
|  %F  |                               %Y0%m-%d简写形式，例如2018-03-27                               |
|  %D  |                                 %m%d%y简写形式，例如03/27/18                                 |

* 特定于当前环境的日期格式
| 代码 |                              说明                               |
|:----:|:---------------------------------------------------------------:|
|  %a  |                          星期几的简写                           |
|  %A  |                          星期几的全称                           |
|  %b  |                           月份的简写                            |
|  %B  |                           月份的全称                            |
|  %c  |       完整的日期和时间。例如"Tue 01 May 2012 04:20:57 PM"       |
|  %p  |                       不同环境中的AM或PM                        |
|  %x  | 适用于当前环境的日期格式，在美国“May 1, 2012”会产生"05/01/2012" |
|  %X  |           适用于当前环境的时间格式，例如"04:24:12 PM"           |

`datetime.strptime`是通过已知格式进行日期解析的最佳方式，而对于一些常见的日期格式，可以使用`dateutil`这个三方包中的`parser.parse`方法来避免编写格式定义；`dateutil`可以解析除中文外几乎所有人类能够理解的日期表现形式[^2]
```Python
In [18]: #将日期转换为字符串

In [19]: stamp = datetime.now()

In [20]: str(stamp)
Out[20]: '2018-03-27 14:19:08.645810'

In [21]: stamp.strftime('%Y-%m-%d')
Out[21]: '2018-03-27'

In [22]: #将字符串转换为日期

In [23]: value = '2018-03-27'

In [24]: datetime.strptime(value,'%Y-%m-%d')
Out[24]: datetime.datetime(2018, 3, 27, 0, 0)

In [25]: datestrs = ['8/4/2017','3/27/2018']

In [27]: [datetime.strptime(x, '%m/%d/%Y') for x in datestrs]
Out[27]: [datetime.datetime(2017, 8, 4, 0, 0), datetime.datetime(2018, 3, 27, 0, 0)]

In [30]: from dateutil.parser import parse

In [31]: parse('2018/03/27')
Out[31]: datetime.datetime(2018, 3, 27, 0, 0)

In [32]: parse('Jan 31, 1997 10:45 PM')
Out[32]: datetime.datetime(1997, 1, 31, 22, 45)

In [33]: # 日出现在月的前面，传入dayfirst = True

In [34]: parse('4/8/2017', dayfirst=True)
Out[34]: datetime.datetime(2017, 8, 4, 0, 0)
```
pandas通常是用于处理成组日期的，不管这些日期时DataFrame的轴索引还是列。`to_datetime`方法可以解析多种不同的日期表示形式，并且它还可以处理缺失值(None、空字符串等)，*NaT(Not a Time)* 是pandas中时间戳数据的NA值
```Python
In [45]: datestrs
Out[45]: ['8/4/2017', '3/27/2018']

In [46]: pd.to_datetime(datestrs)
Out[46]: DatetimeIndex(['2017-08-04', '2018-03-27'], dtype='datetime64[ns]', freq=None)

In [47]: idx = pd.to_datetime(datestrs + [None])

In [48]: idx
Out[48]: DatetimeIndex(['2017-08-04', '2018-03-27', 'NaT'], dtype='datetime64[ns]', freq=None)

In [49]: idx[2]
Out[49]: NaT

In [50]: pd.isnull(idx)
Out[50]: array([False, False,  True], dtype=bool)
```
## 时间序列基础
pandas最基本的时间序列类型是以时间戳(以字符串或datetime对象表示)为索引的Series，datetime对象实际上是被放在DatetimeIndex中的，不同索引的时间序列之间的算数运算会自动按日期对齐；pandas使用NumPy的datetime64数据类型以纳秒形式存储时间戳，而DatetimeIndex中各个标量值是pandas的Timestamp对象，在需要的时候Timestamp可以随时自动转换为datetime对象，并且它还可以存储频率信息，且知道如何执行时区转换以及其他操作：
```Python
In [58]: # 创建时间序列

In [59]: dates = [datetime(2018,3,d) for d in range(21,27)]

In [60]: ts = Series(np.random.randn(6), index=dates)

In [61]: ts
Out[61]:
2018-03-21    0.555044
2018-03-22   -0.404548
2018-03-23   -1.334704
2018-03-24   -0.550604
2018-03-25    0.037230
2018-03-26    0.298817
dtype: float64

In [62]: # ts的类型

In [63]: type(ts)
Out[63]: pandas.core.series.Series

In [64]: ts.index
Out[64]:
DatetimeIndex(['2018-03-21', '2018-03-22', '2018-03-23', '2018-03-24',
               '2018-03-25', '2018-03-26'],
              dtype='datetime64[ns]', freq=None)

In [65]: # 不同索引的时间序列之间的算数运算会自动按日期对齐

In [66]: ts+ts[::2]
Out[66]:
2018-03-21    1.110088
2018-03-22         NaN
2018-03-23   -2.669409
2018-03-24         NaN
2018-03-25    0.074461
2018-03-26         NaN
dtype: float64

In [67]: # 时间戳类型

In [68]: ts.index.dtype
Out[68]: dtype('<M8[ns]')

In [69]: #DateIndex中的各个标量值是pandas的Timestamp对象

In [70]: stamp =ts.index[0]

In [71]: stamp
Out[71]: Timestamp('2018-03-21 00:00:00')
```

### 索引、选取、子集构造
索引和数据选取和Series的行为相同，也可以传入一个被解释为日期的字符串；对于较长的时间序列，可以传入 **"年"** 或 **"年月"** 选取数据的切片，而通过日期切片的方式只对规则Series有效；对大部分时间序列的数据来说都是按照时间先后排序的，因此可以用不存在于改时间序列中的时间戳进行切片(即范围查找)，而这里同样可以传入字符串日期、datetime或Timestamp，**和NumPy一样都是产生原时间序列的视图**。可以调用`truncate`方法并传入`before`和`after`来实现相同的效果。而这些对DataFrame同样有效:
```Python
In [73]: # 选取索引和数据

In [74]: stamp = ts.index[2]

In [75]: ts[stamp]
Out[75]: -1.3347042513067129

In [81]: # 通过"年"或"年月"切片

In [82]: long_ts = Series(np.random.randn(1000),index=pd.date_range('1/1/2018', periods=1000))

In [83]: long_ts
Out[83]:
2018-01-01    0.047281
2018-01-02   -0.630386
2018-01-03    0.630630
                ...
2020-09-26    0.993575
Freq: D, Length: 1000, dtype: float64

In [84]: long_ts['2019']
Out[84]:
2019-01-01    0.890328
2019-01-02   -1.131193
2019-01-03   -0.225457
2019-01-04   -0.097514
                ...
2019-12-28    1.096610
2019-12-29    0.534131
2019-12-30   -1.859665
2019-12-31   -0.408150
Freq: D, Length: 365, dtype: float64

In [85]: long_ts['2019-09']
Out[85]:
2019-09-01    0.950379
2019-09-02    0.508369
2019-09-03    0.631864
                ...
2019-09-26    1.982801
2019-09-27    1.626522
2019-09-28    0.546744
2019-09-29   -0.971617
2019-09-30    0.106587
Freq: D, dtype: float64

In [88]: # 通过日期进行切片

In [89]: ts[datetime(2018,3,24):]
Out[89]:
2018-03-24   -0.550604
2018-03-25    0.037230
2018-03-26    0.298817
dtype: float64

In [95]: # 按时间戳进行切片

In [96]: ts
Out[96]:
2018-03-21    0.555044
2018-03-22   -0.404548
2018-03-23    1.000000
2018-03-24    1.000000
2018-03-25    1.000000
2018-03-26    0.298817
dtype: float64

In [97]: ts['23/3/2018':'25/3/2018']
Out[97]:
2018-03-23    1.0
2018-03-24    1.0
2018-03-25    1.0
dtype: float64

In [119]: #切片数据是源数据的视图

In [120]: ts = Series(np.random.randn(6), index=dates)

In [121]: ts
Out[121]:
2018-03-21   -0.209784
2018-03-22   -0.034117
2018-03-23   -0.383131
2018-03-24    1.207778
2018-03-25   -1.419493
2018-03-26    0.019064
dtype: float64

In [122]: ts_slice = ts['23/3/2018':'25/3/2018']

In [123]: ts_slice[0]=1

In [124]: ts
Out[124]:
2018-03-21   -0.209784
2018-03-22   -0.034117
2018-03-23    1.000000
2018-03-24    1.207778
2018-03-25   -1.419493
2018-03-26    0.019064
dtype: float64

In [125]: #通过truncate实现切片并实现复制

In [126]: ts.truncate(after='24/3/2018', copy=True)
Out[126]:
2018-03-21   -0.209784
2018-03-22   -0.034117
2018-03-23    1.000000
2018-03-24    1.207778
dtype: float64

In [127]: ts_slice = ts.truncate(after='24/3/2018', copy=True)

In [128]: ts_slice[0]=1

In [129]: ts
Out[129]:
2018-03-21   -0.209784
2018-03-22   -0.034117
2018-03-23    1.000000
2018-03-24    1.207778
2018-03-25   -1.419493
2018-03-26    0.019064
dtype: float64

In [130]: # 对DataFrame的行进行索引

In [131]: date = pd.date_range('1/3/2018', periods=100, freq='W-WED')

In [132]: long_df = DataFrame(np.random.randn(100,4),
     ...:                     index=date,
     ...:                     columns=['col1','col2','col3','col4'])
     ...:

In [133]: long_df.loc['5-2018']
Out[133]:
                col1      col2      col3      col4
2018-05-02 -1.217853 -0.052510  1.854937  0.187870
2018-05-09  0.555552 -0.276599 -0.145089 -0.676329
2018-05-16  0.704234  0.316785 -0.057501  0.033567
2018-05-23  0.451673  0.367754  0.121129 -0.861855
2018-05-30 -1.057437 -0.904105 -0.025711 -2.689067

```

### 带有重复索引的时间序列
当多个观测数据落在同一个时间点上的时候，可以通过检查索引的`is_unique`属性来确定它是否唯一，而对这个时间序列进行索引要么产生 **标量值**(不重复)，要么产生 **切片**(重复)；如果需要对具有非唯一时间戳的数据进行聚合，使用groupby并传入`level=0`(索引的唯一一层):
```Python
In [137]: # 生成时间索引的Series

In [138]: dates = pd.DatetimeIndex(['1/3/2018','1/3/2018','2/3/2018','2/3/2018','3/3/2018'])

In [139]: dup_ts = Series(np.arange(5), index=dates)

In [140]: dup_ts
Out[140]:
2018-01-03    0
2018-01-03    1
2018-02-03    2
2018-02-03    3
2018-03-03    4
dtype: int32

In [141]: #检查索引是否唯一

In [142]: dup_ts.index.is_unique
Out[142]: False

In [143]: #对时间序列进行索引

In [144]: dup_ts['3/3/2018'] #不重复
Out[144]: 4

In [145]: dup_ts['2/3/2018'] #重复
Out[145]:
2018-02-03    2
2018-02-03    3
dtype: int32

In [150]: # 进行分组聚合

In [151]: grouped = dup_ts.groupby(level=0)

In [152]: grouped.count()
Out[152]:
2018-01-03    2
2018-02-03    2
2018-03-03    1
dtype: int64

In [153]: grouped.mean()
Out[153]:
2018-01-03    0.5
2018-02-03    2.5
2018-03-03    4.0
dtype: float64
```

## 日期的范围、频率以及移动
pandas有一整套标准时间序列频率以及用于重采样、频率推断、生成固定频率日期范围的工具。调用`resample`方法将时间序列转换为一个具有固定频率的时间序列:
```Python
In [176]: dates = [datetime(2018,3,d) for d in arange(21, 31, step=2)]

In [177]: ts.resample('D').sum()
Out[177]:
2018-03-21   -2.084044
2018-03-22         NaN
2018-03-23    1.075880
2018-03-24         NaN
2018-03-25    0.045201
2018-03-26         NaN
2018-03-27   -0.754086
2018-03-28         NaN
2018-03-29   -0.448258
Freq: D, dtype: float64

In [178]: dates = [datetime(2018,3,d) for d in arange(21, 31, step=2)]

In [179]: ts = Series(np.random.randn(5), index=dates)

In [180]: ts.resample('D').sum() #转换成固定频率(每日)
Out[180]:
2018-03-21   -0.376527
2018-03-22         NaN
2018-03-23    0.282788
2018-03-24         NaN
2018-03-25   -0.014975
2018-03-26         NaN
2018-03-27    1.209955
2018-03-28         NaN
2018-03-29   -1.279524
Freq: D, dtype: float64

```
### 生成日期范围
`pandas.data_range`用于生成指定长度的DatatimeIndex，默认情况下`data_range`会产生按天计算的时间点。如果只传入起始或结束时间，那么的传入一个表示一段时间的数字`periods`。起始和结束日期定义了日期索引的严格边界(*如果想要生成一个由每个月最后一个工作日组成的日期索引，传入"BM"频率，这样只会包含时间间隔内(或刚好在边界上)符合频率要求的日期*)。`data_range`默认会保留起始或结束时间戳的 **时间** 信息(有的话)。如果希望产生一组被规范化到午夜的时间戳，可以设置`normalize=True`：
```Python
In [182]: index = pd.date_range('8/4/2017','3/27/2018')

In [183]: index
Out[183]:
DatetimeIndex(['2017-08-04', '2017-08-05', '2017-08-06', '2017-08-07',
               '2017-08-08', '2017-08-09', '2017-08-10', '2017-08-11',
               '2017-08-12', '2017-08-13',
               ...
               '2018-03-18', '2018-03-19', '2018-03-20', '2018-03-21',
               '2018-03-22', '2018-03-23', '2018-03-24', '2018-03-25',
               '2018-03-26', '2018-03-27'],
              dtype='datetime64[ns]', length=236, freq='D')

In [185]: #传入起始日期或结束日期并设置一段时间

In [186]: pd.date_range(start='8/4/2017',periods=20)
Out[186]:
DatetimeIndex(['2017-08-04', '2017-08-05', '2017-08-06', '2017-08-07',
               '2017-08-08', '2017-08-09', '2017-08-10', '2017-08-11',
               '2017-08-12', '2017-08-13', '2017-08-14', '2017-08-15',
               '2017-08-16', '2017-08-17', '2017-08-18', '2017-08-19',
               '2017-08-20', '2017-08-21', '2017-08-22', '2017-08-23'],
              dtype='datetime64[ns]', freq='D')

In [187]: pd.date_range(end='8/4/2017',periods=20)
Out[187]:
DatetimeIndex(['2017-07-16', '2017-07-17', '2017-07-18', '2017-07-19',
               '2017-07-20', '2017-07-21', '2017-07-22', '2017-07-23',
               '2017-07-24', '2017-07-25', '2017-07-26', '2017-07-27',
               '2017-07-28', '2017-07-29', '2017-07-30', '2017-07-31',
               '2017-08-01', '2017-08-02', '2017-08-03', '2017-08-04'],
              dtype='datetime64[ns]', freq='D')

In [188]: #传入频率

In [189]: pd.date_range('8/4/2017','3/27/2018', freq='BM')
Out[189]:
DatetimeIndex(['2017-08-31', '2017-09-29', '2017-10-31', '2017-11-30',
               '2017-12-29', '2018-01-31', '2018-02-28'],
              dtype='datetime64[ns]', freq='BM')

In [193]: #保留时间信息

In [194]: pd.date_range('8/4/2017 12:21:56', periods=5)
Out[194]:
DatetimeIndex(['2017-08-04 12:21:56', '2017-08-05 12:21:56',
               '2017-08-06 12:21:56', '2017-08-07 12:21:56',
               '2017-08-08 12:21:56'],
              dtype='datetime64[ns]', freq='D')

In [203]: #规范化时间

In [204]: date_r = pd.date_range('8/4/2017 12:21:56', periods=5, normalize=True)

In [205]: date_r[1]
Out[205]: Timestamp('2017-08-05 00:00:00', freq='D')
```

### 频率和日期偏移量
pandas中的频率由一个 **基础频率** 和一个 **乘数** 组成。基础频率通常以一个字符串别名表示，比如“M”表示每月，“H”表示每小时。对于每个基础频率，都有一个被称为 **日期偏移量** 的对象与之对应。按小时计算可以使用Hour类，传入一个整数即可定义偏移量的倍数。一般来说无需显式创建便宜对象，直接使用诸如"H"或"4H"这样的字符串别名即可，在基础频率前加上一个整数可创建倍数；大部分的偏移量对象可以通过加法进行连接，而传入"1h30min"这样的频率字符串也能被高效地解析为等效的表达式。有些频率描述的时间点并不是均匀分隔的。(*"M"(日历月末)和"BM"(每月最后一个工作日)就取决于每月的天数，对于后者还要考虑月末是不是周末*)。

* 时间序列的基础频率

|         别名          |      偏移量类型      |                                                         说明                                                         |
|:---------------------:|:--------------------:|:--------------------------------------------------------------------------------------------------------------------:|
|           D           |         Day          |                                                       每日历日                                                       |
|           B           |     BusinessDay      |                                                       每工作日                                                       |
|           H           |         Hour         |                                                        每小时                                                        |
|        T或min         |        Minute        |                                                         每分                                                         |
|           S           |        Second        |                                                         每秒                                                         |
|         L或ms         |        Milli         |                                                每毫秒(即每千分之一秒)                                                |
|           U           |        Micro         |                                               每微秒(即每百万分之一秒)                                               |
|           M           |       MonthEnd       |                                                  每月最后一个日历日                                                  |
|          BM           |   BusinessMonthEnd   |                                                  每月最后一个工作日                                                  |
|          MS           |      MonthBegin      |                                                   每月第一个日历日                                                   |
|          BMS          |  BusinessMonthBegin  |                                                   每月第一个工作日                                                   |
|    W-MON、W-TUE...    |         Week         |                           从指定的星期几(MON、TUE、WED、THU、FRI、SAT、SUN)开始算起，每周                            |
| WOM-1MON、WOM-2MON... |     WeekOfMonth      |                    产生每月第一、第二、第三或第四轴的星期几。例如，WOM-3FRI表示每月的第三个星期五                    |
|    Q-JAN、Q-FEB...    |      QuaterEnd       | 对于以指定月份(JAN、FEB、MAR、APR、MAY、JUN、JUL、AUG、SEP、OCT、NOV、DEC)结束的年度，每季度最后一月的最后一个日历日 |
|   BQ-JAN、BQ-FEB...   |  BusinessQuarterEnd  |                              对于以指定月份结束的年度，每季度最后一个月的最后一个工作日                              |
|   QS-JAN、QS-FEB...   |     QuarterBegin     |                                对于以指定月份结束的年度，每季度最后一月的第一个日历日                                |
|  BQS-JAN、BQS-FEB...  | BusinessQuarterBegin |                                对于以指定月份结束的年度，每季度最后一月的第一个工作日                                |
|    A-JAN、A-FEB...    |       YearEnd        |               每年指定月份(JAN、FEB、MAR、APR、MAY、JUN、JUL、AUG、SEP、OCT、NOV、DEC)的最后一个日历日               |
|   BA-JAN、BA-FEB...   |   BusinessYearEnd    |                                             每年指定月份的最后一个工作日                                             |
|   AS-JAN、AS-FEB...   |      YearBegin       |                                             每年指定月份的最后一个日历日                                             |
|  BAS-JAN、BAS-FEB...  |  BusinessYearBegin   |                                             每年指定月份的最后一个工作日                                             |
[^1]: 闰秒，是指为保持协调世界时接近于世界时时刻，由国际计量局统一规定在年底或年中（也可能在季末）对协调世界时增加或减少1秒的调整
[^2]: dateutil.parser并不完美，它会将一些原本不是日期的字符串认作是日期(例如将'23'解析成当月的23号，而大于日期的例如'32'会被解析为32年的今天)
