---
title: numpy基础(二)
date: 2018-03-17 11:33:50
categories: true
copyright: true
tags:
    - NumPy
    - 数据分析
description:
---
## 通用函数
通用函数(即ufunc)是一种对ndarray中的数据执行元素级运算的函数。它是简单函数(接受一个或多个标量值，并产生一个或多个标量值)的矢量化包装器。

* 一元ufunc

|                        函数                       |                                      说明                                      |
| :-----------------------------------------------: | :----------------------------------------------------------------------------: |
|                     abs、fabs                     |            计算整数、浮点数或复数的绝对值。对于非复数值，可以使fabs            |
|                        sqrt                       |                       计算各元素的平方根。相当于arr**0.5                       |
|                       square                      |                         计算各元素的平方。相当于arr**2                         |
|                        exp                        |                              计算各元素的指数e^x                               |
|              log、log10、log2、log1p              |            分别对自然对数(底为e)、底为10的log、底为2的log、log(1+x)            |
|                        sign                       |                  计算各元素的正负号:1(正数)、0(零)、-1(负数)                   |
|                        ceil                       |                计算各元素的ceiling值，即大于等于该值的最小整数                 |
|                       floor                       |                 计算各元素的floor值，即小于等于该值的最大整数                  |
|                        rint                       |                   将各元素四舍五入到最接近的整数，保留dtype                    |
|                        modf                       |                   将数组的小数和整数部分以独立数组的形式返回                   |
|                       isnan                       |              返回一个表示“哪些值是NaN(这不是一个数字)”的布尔型数组             |
|                  isfinite、isinf                  | 分别返回一个表示“哪些元素是有穷的(非inf、非NaN)”或“哪些元素是无穷的”布尔型数组 |
|          cos、cosh、sin、sinh、tan、tanh          |                             普通型和双曲型三角函数                             |
| arccos、arccosh、arcsin、arcsinh、arctan、arctanh |                                   反三角函数                                   |
|                    logical_not                    | 计算各元素not x的真值。相当于-arr                                                                               |

* 二元ufunc

|                            函数                            |                                      说明                                      |
| :--------------------------------------------------------: | :----------------------------------------------------------------------------: |
|                            add                             |                             将数组中对应的元素相加                             |
|                          subtract                          |                      从第一个数组中减去第二个数组中的元素                      |
|                          multiply                          |                                  数组元素相乘                                  |
|                    divide、floor_divide                    |                          除法或向下圆整除法(丢弃余数)                          |
|                           power                            |           对第一个数组中的元素A，根据第二个数组中的相应元素B，计算A^B          |
|                        maximum、fmax                       |                        元素级的最大值计算。fmax将忽略NaN                       |
|                        minimum、fmin                       |                        元素级的最小值计算。fmin将忽略NaN                       |
|                            mod                             |                          元素级的求模计算(除法的余数)                          |
|                          copysign                          |                 将第二个数组中的值的符号复制给第一个数组中的值                 |
| greater、greater_equal、less、less_equal、equal、not_equal | 执行元素级的比较运算，最终产生布尔型数组。相当于中缀运算符>、>=、<、<=、==、!= |
|            logical_and、logical_or、logical_xor            | 执行元素级的真值逻辑运算。相当于中缀运算符&、&#124;、^                                                                               |

许多ufunc都是简单的元素级变体，一元的ufunc接受一个数组，二元的接受两个并返回一个结果数组：
```
In [2]: arr  = np.arange(10)

In [3]: arr
Out[3]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

In [4]: np.sqrt(arr)
Out[4]:
array([0.        , 1.        , 1.41421356, 1.73205081, 2.        ,
       2.23606798, 2.44948974, 2.64575131, 2.82842712, 3.        ])

In [5]: np.exp(arr)
Out[5]:
array([1.00000000e+00, 2.71828183e+00, 7.38905610e+00, 2.00855369e+01,
       5.45981500e+01, 1.48413159e+02, 4.03428793e+02, 1.09663316e+03,
       2.98095799e+03, 8.10308393e+03])

In [6]: x = randn(5)

In [7]: y = randn(5)

In [8]: x
Out[8]:
array([-9.27415622e-01, -1.67964296e-03, -1.91023663e+00, -1.31307986e-01,
       -1.17927352e+00])

In [9]: y
Out[9]: array([ 0.82239493,  0.43695129, -0.00905311,  0.31991891, -0.34529735])

In [10]: np.maximum(x,y)
Out[10]: array([ 0.82239493,  0.43695129, -0.00905311,  0.31991891, -0.34529735])
```

## 利用数组进行数据处理
****矢量化**将数据处理任务表述为简洁的数组表达式，用数组表达式代替循环。例如计算函数sqrt(x^2+y^2)。`np.meshgrid`接受两个一维数组，并产生两个二维矩阵(对应两个数组中所有(x,y)对):
```
In [11]: points = np.arange(-5, 5, 0.01)

In [12]: xs, ys = np.meshgrid(points,points)

In [13]: xs
Out[13]:
array([[-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
       ...,
       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99]])

In [14]: z = np.sqrt(np.square(xs)+np.square(ys))

In [15]: z
Out[15]:
array([[7.07106781, 7.06400028, 7.05693985, ..., 7.04988652, 7.05693985,
        7.06400028],
       [7.06400028, 7.05692568, 7.04985815, ..., 7.04279774, 7.04985815,
        7.05692568],
       [7.05693985, 7.04985815, 7.04278354, ..., 7.03571603, 7.04278354,
        7.04985815],
       ...,
       [7.04988652, 7.04279774, 7.03571603, ..., 7.0286414 , 7.03571603,
        7.04279774],
       [7.05693985, 7.04985815, 7.04278354, ..., 7.03571603, 7.04278354,
        7.04985815],
       [7.06400028, 7.05692568, 7.04985815, ..., 7.04279774, 7.04985815,
        7.05692568]])
```

### 将条件逻辑表述为数组运算
`np.where`是三元表达式`x if condition else y`的矢量化版本。`np.wehere`接受三个参数`cond、xarr、yarr`,当判定`cond`为true时选择执行`xarr`否则执行`yarr`。因此`np.where`也可以嵌套使用。`np.where`的第二个和第三个参数不必时数组，可以是标量值。`where`通常用于根据另一个数组产生新的数组。
```
In [23]: xarr = np.array([0.1,0.2,0.3])

In [24]: yarr = np.array([1.1,1.2,1.3])

In [25]: cond = np.array([True,False,True])

In [26]: result = np.where(cond,xarr,yarr)

In [27]: result
Out[27]: array([0.1, 1.2, 0.3])

In [28]: arr = randn(4,4)

In [29]: arr
Out[29]:
array([[ 0.17276546, -1.27954884, -0.07326268, -2.40995669],
       [-0.15796552, -1.85102248,  0.53499154, -0.1332765 ],
       [ 0.81853502,  1.35768841,  1.55543773,  1.01407613],
       [-1.05967769,  0.39289449,  0.13509303, -0.68143339]])

In [30]: np.where(arr>0,1,-1)
Out[30]:
array([[ 1, -1, -1, -1],
       [-1, -1,  1, -1],
       [ 1,  1,  1,  1],
       [-1,  1,  1, -1]])

In [31]: np.where(arr>0,1,arr)
Out[31]:
array([[ 1.        , -1.27954884, -0.07326268, -2.40995669],
       [-0.15796552, -1.85102248,  1.        , -0.1332765 ],
       [ 1.        ,  1.        ,  1.        ,  1.        ],
       [-1.05967769,  1.        ,  1.        , -0.68143339]])

In [32]: cond2 = np.array([False,False,True])

In [33]: np.where(cond&cond2,0,np.where(cond,1,np.where(cond,2,3)))
Out[33]: array([1, 3, 0])
```

### 数学和统计方法
可以通过数组上的一组数学函数对整个数组或某个轴向的数据进行统计。`sum`、`mean`以及标准差`std`等聚合计算(aggregation)既可以当做数组的实例方法调用，也可以当做顶级NumPy函数使用。

* 基本数组统计方法
|      方法      |                         说明                         |
| :------------: | :--------------------------------------------------: |
|      sum       | 对数组中全部或某轴向的元素求和。零长度的数组的sum为0 |
|      mean      |         算数平均数。零长度的数组的mean为NaN          |
|    std、var    |       分别为标准差和方差，自由度可调(默认为n)        |
| argmin、argmax |              分别为最大和最小元素的索引              |
|     cumsum     |                   所有元素的累计和                   |
|    cumprod     |                   所有元素的累计积                   |

`mean`和`sum`这类的函数接受一个axis参数(用于计算该轴向上的统计值)，最终结果是一个少一维的数组:
```
In [36]: arr =  np.random.randn(5,4)

In [37]: arr
Out[37]:
array([[-0.00502805,  0.23545272,  0.04886622, -0.46971953],
       [-1.08918278,  1.19958904, -0.54808552, -1.60148873],
       [-0.60059372, -0.9743709 ,  1.39660621, -0.97132217],
       [-0.11917925,  1.99922758, -1.58943388,  1.60237969],
       [-0.28361465, -2.57463163, -0.96786527, -0.00376026]])

In [38]: arr.mean()
Out[38]: -0.26580774446749256

In [39]: np.mean(arr)
Out[39]: -0.26580774446749256

In [40]: arr.mean(axis=1)
Out[40]: array([-0.04760716, -0.509792  , -0.28742014,  0.47324854, -0.95746796])
```
`cumsum`和`cumprod`之类的方法不聚合，而是产生一个由中间结果组成的数组：
```
In [47]: arr = np.array([[0,1,2],[3,4,5],[6,7,8]])

In [48]: arr.cumsum(0)
Out[48]:
array([[ 0,  1,  2],
       [ 3,  5,  7],
       [ 9, 12, 15]])

In [49]: arr.cumsum(1)
Out[49]:
array([[ 0,  1,  3],
       [ 3,  7, 12],
       [ 6, 13, 21]])

In [50]: arr.cumprod(0)
Out[50]:
array([[ 0,  1,  2],
       [ 0,  4, 10],
       [ 0, 28, 80]])

In [51]: arr.cumprod(1)
Out[51]:
array([[  0,   0,   0],
       [  3,  12,  60],
       [  6,  42, 336]])
```