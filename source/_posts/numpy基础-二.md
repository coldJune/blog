---
title: numpy基础(二)
date: 2018-03-17 11:33:50
categories: NumPy
copyright: true
tags:
    - NumPy
    - 数据分析
description:
---
## 通用函数
通用函数(即ufunc)是一种对ndarray中的数据执行元素级运算的函数。它是简单函数(接受一个或多个标量值，并产生一个或多个标量值)的矢量化包装器。

* 一元ufunc

|                        函数                       |                                      说明                                      |
| :-----------------------------------------------: | :----------------------------------------------------------------------------: |
|                     abs、fabs                     |            计算整数、浮点数或复数的绝对值。对于非复数值，可以使fabs            |
|                        sqrt                       |                       计算各元素的平方根。相当于arr**0.5                       |
|                       square                      |                         计算各元素的平方。相当于arr**2                         |
|                        exp                        |                              计算各元素的指数e^x                               |
|              log、log10、log2、log1p              |            分别对自然对数(底为e)、底为10的log、底为2的log、log(1+x)            |
|                        sign                       |                  计算各元素的正负号:1(正数)、0(零)、-1(负数)                   |
|                        ceil                       |                计算各元素的ceiling值，即大于等于该值的最小整数                 |
|                       floor                       |                 计算各元素的floor值，即小于等于该值的最大整数                  |
|                        rint                       |                   将各元素四舍五入到最接近的整数，保留dtype                    |
|                        modf                       |                   将数组的小数和整数部分以独立数组的形式返回                   |
|                       isnan                       |              返回一个表示“哪些值是NaN(这不是一个数字)”的布尔型数组             |
|                  isfinite、isinf                  | 分别返回一个表示“哪些元素是有穷的(非inf、非NaN)”或“哪些元素是无穷的”布尔型数组 |
|          cos、cosh、sin、sinh、tan、tanh          |                             普通型和双曲型三角函数                             |
| arccos、arccosh、arcsin、arcsinh、arctan、arctanh |                                   反三角函数                                   |
|                    logical_not                    | 计算各元素not x的真值。相当于-arr                                                                               |

* 二元ufunc

|                            函数                            |                                      说明                                      |
| :--------------------------------------------------------: | :----------------------------------------------------------------------------: |
|                            add                             |                             将数组中对应的元素相加                             |
|                          subtract                          |                      从第一个数组中减去第二个数组中的元素                      |
|                          multiply                          |                                  数组元素相乘                                  |
|                    divide、floor_divide                    |                          除法或向下圆整除法(丢弃余数)                          |
|                           power                            |           对第一个数组中的元素A，根据第二个数组中的相应元素B，计算A^B          |
|                        maximum、fmax                       |                        元素级的最大值计算。fmax将忽略NaN                       |
|                        minimum、fmin                       |                        元素级的最小值计算。fmin将忽略NaN                       |
|                            mod                             |                          元素级的求模计算(除法的余数)                          |
|                          copysign                          |                 将第二个数组中的值的符号复制给第一个数组中的值                 |
| greater、greater_equal、less、less_equal、equal、not_equal | 执行元素级的比较运算，最终产生布尔型数组。相当于中缀运算符>、>=、<、<=、==、!= |
|            logical_and、logical_or、logical_xor            | 执行元素级的真值逻辑运算。相当于中缀运算符&、&#124;、^                                                                               |

许多ufunc都是简单的元素级变体，一元的ufunc接受一个数组，二元的接受两个并返回一个结果数组：
```
In [2]: arr  = np.arange(10)

In [3]: arr
Out[3]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

In [4]: np.sqrt(arr)
Out[4]:
array([0.        , 1.        , 1.41421356, 1.73205081, 2.        ,
       2.23606798, 2.44948974, 2.64575131, 2.82842712, 3.        ])

In [5]: np.exp(arr)
Out[5]:
array([1.00000000e+00, 2.71828183e+00, 7.38905610e+00, 2.00855369e+01,
       5.45981500e+01, 1.48413159e+02, 4.03428793e+02, 1.09663316e+03,
       2.98095799e+03, 8.10308393e+03])

In [6]: x = randn(5)

In [7]: y = randn(5)

In [8]: x
Out[8]:
array([-9.27415622e-01, -1.67964296e-03, -1.91023663e+00, -1.31307986e-01,
       -1.17927352e+00])

In [9]: y
Out[9]: array([ 0.82239493,  0.43695129, -0.00905311,  0.31991891, -0.34529735])

In [10]: np.maximum(x,y)
Out[10]: array([ 0.82239493,  0.43695129, -0.00905311,  0.31991891, -0.34529735])
```

## 利用数组进行数据处理
**矢量化**将数据处理任务表述为简洁的数组表达式，用数组表达式代替循环。例如计算函数sqrt(x^2+y^2)。`np.meshgrid`接受两个一维数组，并产生两个二维矩阵(对应两个数组中所有(x,y)对):
```
In [11]: points = np.arange(-5, 5, 0.01)

In [12]: xs, ys = np.meshgrid(points,points)

In [13]: xs
Out[13]:
array([[-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
       ...,
       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99]])

In [14]: z = np.sqrt(np.square(xs)+np.square(ys))

In [15]: z
Out[15]:
array([[7.07106781, 7.06400028, 7.05693985, ..., 7.04988652, 7.05693985,
        7.06400028],
       [7.06400028, 7.05692568, 7.04985815, ..., 7.04279774, 7.04985815,
        7.05692568],
       [7.05693985, 7.04985815, 7.04278354, ..., 7.03571603, 7.04278354,
        7.04985815],
       ...,
       [7.04988652, 7.04279774, 7.03571603, ..., 7.0286414 , 7.03571603,
        7.04279774],
       [7.05693985, 7.04985815, 7.04278354, ..., 7.03571603, 7.04278354,
        7.04985815],
       [7.06400028, 7.05692568, 7.04985815, ..., 7.04279774, 7.04985815,
        7.05692568]])
```

### 将条件逻辑表述为数组运算
`np.where`是三元表达式`x if condition else y`的矢量化版本。`np.wehere`接受三个参数`cond、xarr、yarr`,当判定`cond`为true时选择执行`xarr`否则执行`yarr`。因此`np.where`也可以嵌套使用。`np.where`的第二个和第三个参数不必时数组，可以是标量值。`where`通常用于根据另一个数组产生新的数组。
```
In [23]: xarr = np.array([0.1,0.2,0.3])

In [24]: yarr = np.array([1.1,1.2,1.3])

In [25]: cond = np.array([True,False,True])

In [26]: result = np.where(cond,xarr,yarr)

In [27]: result
Out[27]: array([0.1, 1.2, 0.3])

In [28]: arr = randn(4,4)

In [29]: arr
Out[29]:
array([[ 0.17276546, -1.27954884, -0.07326268, -2.40995669],
       [-0.15796552, -1.85102248,  0.53499154, -0.1332765 ],
       [ 0.81853502,  1.35768841,  1.55543773,  1.01407613],
       [-1.05967769,  0.39289449,  0.13509303, -0.68143339]])

In [30]: np.where(arr>0,1,-1)
Out[30]:
array([[ 1, -1, -1, -1],
       [-1, -1,  1, -1],
       [ 1,  1,  1,  1],
       [-1,  1,  1, -1]])

In [31]: np.where(arr>0,1,arr)
Out[31]:
array([[ 1.        , -1.27954884, -0.07326268, -2.40995669],
       [-0.15796552, -1.85102248,  1.        , -0.1332765 ],
       [ 1.        ,  1.        ,  1.        ,  1.        ],
       [-1.05967769,  1.        ,  1.        , -0.68143339]])

In [32]: cond2 = np.array([False,False,True])

In [33]: np.where(cond&cond2,0,np.where(cond,1,np.where(cond,2,3)))
Out[33]: array([1, 3, 0])
```

### 数学和统计方法
可以通过数组上的一组数学函数对整个数组或某个轴向的数据进行统计。`sum`、`mean`以及标准差`std`等聚合计算(aggregation)既可以当做数组的实例方法调用，也可以当做顶级NumPy函数使用。

* 基本数组统计方法

|      方法      |                         说明                         |
| :------------: | :--------------------------------------------------: |
|      sum       | 对数组中全部或某轴向的元素求和。零长度的数组的sum为0 |
|      mean      |         算数平均数。零长度的数组的mean为NaN          |
|    std、var    |       分别为标准差和方差，自由度可调(默认为n)        |
| argmin、argmax |              分别为最大和最小元素的索引              |
|     cumsum     |                   所有元素的累计和                   |
|    cumprod     |                   所有元素的累计积                   |

`mean`和`sum`这类的函数接受一个axis参数(用于计算该轴向上的统计值)，最终结果是一个少一维的数组:
```
In [36]: arr =  np.random.randn(5,4)

In [37]: arr
Out[37]:
array([[-0.00502805,  0.23545272,  0.04886622, -0.46971953],
       [-1.08918278,  1.19958904, -0.54808552, -1.60148873],
       [-0.60059372, -0.9743709 ,  1.39660621, -0.97132217],
       [-0.11917925,  1.99922758, -1.58943388,  1.60237969],
       [-0.28361465, -2.57463163, -0.96786527, -0.00376026]])

In [38]: arr.mean()
Out[38]: -0.26580774446749256

In [39]: np.mean(arr)
Out[39]: -0.26580774446749256

In [40]: arr.mean(axis=1)
Out[40]: array([-0.04760716, -0.509792  , -0.28742014,  0.47324854, -0.95746796])
```
`cumsum`和`cumprod`之类的方法不聚合，而是产生一个由中间结果组成的数组：
```
In [47]: arr = np.array([[0,1,2],[3,4,5],[6,7,8]])

In [48]: arr.cumsum(0)
Out[48]:
array([[ 0,  1,  2],
       [ 3,  5,  7],
       [ 9, 12, 15]])

In [49]: arr.cumsum(1)
Out[49]:
array([[ 0,  1,  3],
       [ 3,  7, 12],
       [ 6, 13, 21]])

In [50]: arr.cumprod(0)
Out[50]:
array([[ 0,  1,  2],
       [ 0,  4, 10],
       [ 0, 28, 80]])

In [51]: arr.cumprod(1)
Out[51]:
array([[  0,   0,   0],
       [  3,  12,  60],
       [  6,  42, 336]])
```
### 用于布尔型数组的方法
上面罗列的方法中，布尔值会被强制转换为1(True)和0(False)。所以`sum`可以用来对布尔型数组中的True值计数。而`any`方法用来测试数组中是否存在一个或多个True，`all`用来检查数组中所有值是否都是True：
```
In [52]: arr = randn(20)

In [53]: (arr > 0).sum()
Out[53]: 11

In [54]: bools=np.array([False,True,False])

In [55]: bools.any()
Out[55]: True

In [56]: np.all(bools)
Out[56]: False
```

### 排序
NumPy数组通过`sort`方法就地排序，多维数组可以在任何一个轴向上进行排序，只需将轴编号传给`sort`。顶级方法`np.sort`返回的是数组的已排序副本，而就地排序则会修改数组本身：
```
In [57]: arr = randn(6)

In [58]: arr
Out[58]:
array([ 0.20563118, -0.6733116 , -1.44713961,  0.49352122,  0.73564391,
        1.71627219])

In [59]: arr.sort()

In [60]: arr
Out[60]:
array([-1.44713961, -0.6733116 ,  0.20563118,  0.49352122,  0.73564391,
        1.71627219])

In [61]: arr = rand(5,3)

In [62]: arr
Out[62]:
array([[0.18125744, 0.10766187, 0.46160903],
       [0.34363544, 0.28353683, 0.06096776],
       [0.52424935, 0.13756835, 0.78614215],
       [0.12944147, 0.95273729, 0.09078996],
       [0.85118943, 0.18928544, 0.23857278]])

In [63]: np.sort(arr,1)
Out[63]:
array([[0.10766187, 0.18125744, 0.46160903],
       [0.06096776, 0.28353683, 0.34363544],
       [0.13756835, 0.52424935, 0.78614215],
       [0.09078996, 0.12944147, 0.95273729],
       [0.18928544, 0.23857278, 0.85118943]])

In [64]: arr
Out[64]:
array([[0.18125744, 0.10766187, 0.46160903],
       [0.34363544, 0.28353683, 0.06096776],
       [0.52424935, 0.13756835, 0.78614215],
       [0.12944147, 0.95273729, 0.09078996],
       [0.85118943, 0.18928544, 0.23857278]])
```
### 唯一化及其他集合逻辑
NumPy提供了一些针对一维ndarray的基本集合运算。

* 数组的集合运算

|       方法       |                     说明                     |
| :--------------: | :------------------------------------------: |
|    unique(x)     |      计算x中的唯一元素，并返回有序结果       |
| intersect1d(x,y) |     计算x和y中的公共元素，并返回有序结果     |
|   union1d(x,y)   |        计算x和y的并集，并返回有序结果        |
|    in1d(x,y)     | 得到一个表示“x的元素是否包含于y”的布尔型数组 |
|  setdiff1d(x,y)  |        集合的差，即元素在x中且不在y中        |
|  setxor1d(x,y)   | 集合的对称差，即存在于一个数组中单不同时存在于两个数组中的元素(异或)                                             |
```
In [66]: np.unique(names)
Out[66]: array(['Jim', 'Tom', 'bob'], dtype='<U3')
```

## 用于数组的文件输入输出
### 将数组以二进制格式保存到磁盘
`np.save`和`np.load`是读写磁盘数组数据的两个组药函数。默认情况下数组以未压缩的原始二进制格式保存在扩展名为 *.npy*的文件中。`np.savez`可以将多个数组保存到一个压缩文件中，将数组以关键字参数的形式传入即可。加载 *.npz*文件时，将会得到一个类似字典的对象，该对象对各个数组进行延迟加载:
```
In [68]: arr = np.arange(10)

In [69]: np.save('arr',arr)

In [70]: np.load('arr.npy')
Out[70]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

In [71]: np.savez('arr_more',a=arr,b=arr)

In [72]: arr_more = np.load('arr_more.npz')

In [73]: arr_more['a']
Out[73]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
```

## 线性代数

* numpy.linalg函数

| 函数  | 说明                                                                                      |
| :---: | :---:                                                                                   |
| diag  | 以一维数组的形式返回方阵的对角线(或非对角线)元素，或将一维数组转换为方阵(非对角线元素为0) |
| dot   | 矩阵乘法                                                                                  |
| trace | 计算对角线的和                                                                            |
| det   | 计算矩阵行列式                                                                            |
| eig   | 计算方阵的特征值和特征向量                                                                |
| inv   | 计算方阵的逆                                                                              |
| pinv  | 计算矩阵的Moore-Penrose伪逆                                                               |
| qr    | 计算QR分解                                                                                |
| svd   | 计算奇异值分解(SVD)                                                                       |
| solve | 解线性方程组Ax=b，其中A为一个方阵                                                         |
| lstsq | 计算Ax=b的最小二乘解                                                                      |


```
In [83]: x = randn(3,3)

In [84]: x
Out[84]:
array([[ 0.45880764, -0.90269718, -1.62963467],
       [-0.76727739,  2.24799683,  0.65118256],
       [ 0.43217346, -2.47319723, -0.48442667]])

In [85]: mat = x.T.dot(x)

In [86]: mat
Out[86]:
array([[ 0.98599295, -3.20785172, -1.45668284],
       [-3.20785172, 11.9850565 ,  4.13300564],
       [-1.45668284,  4.13300564,  3.31441709]])

In [87]: inv(mat)
Out[87]:
array([[16.03043111,  3.2650856 ,  2.97386734],
       [ 3.2650856 ,  0.8114194 ,  0.42317945],
       [ 2.97386734,  0.42317945,  1.08102824]])

In [88]: mat
Out[88]:
array([[ 0.98599295, -3.20785172, -1.45668284],
       [-3.20785172, 11.9850565 ,  4.13300564],
       [-1.45668284,  4.13300564,  3.31441709]])

In [89]: mat.dot(inv(mat))
Out[89]:
array([[ 1.00000000e+00, -1.71619808e-16,  2.22044605e-16],
       [ 1.06801676e-14,  1.00000000e+00,  0.00000000e+00],
       [ 3.55271368e-15,  8.88178420e-16,  1.00000000e+00]])

In [90]: q,r = qr(mat)

In [91]: r
Out[91]:
array([[-3.65847231, 13.01900838,  5.33621718],
       [ 0.        , -1.23249681,  1.27109691],
       [ 0.        ,  0.        ,  0.31324131]])
```

## 随机数生成

* 部分numpy.random函数

|     函数    |                      说明                      |
| :---------: | :--------------------------------------------: |
|     seed    |             确定随机数生成器的种子             |
| permutation | 返回一个序列的随机排列或返回一个随机排列的范围 |
|   shuffle   |             对一个序列就地随机排序             |
|     rand    |              产生均匀分布的样本值              |
|   randint   |        从给定的上下限范围内随机选取整数        |
|    randn    |   产生正态分布(平均值为0，标准差为1)的样本值   |
|    normal   |           产生正态(高斯)分布的样本值           |
|   binomial  |              产生二项分布的样本值              |
|     beta    |              产生Beta分布的样本值              |
|  chisquare  |              产生卡方分布的样本值              |
|    gamma    |             产生Gamma分布的样本值              |
|   uniform   |         产生在[0,1）中均匀分布的样本值         |

### 随机漫步
使用`np.random`模块一次性产生1000个“掷硬币”结果(即两个数中任选一个),将其分别设置为1或-1，然后计算累计和,然后可以做求取最大值最小值的简单统计：
```
In [96]: nsteps = 1000

In [97]: draws = np.random.randint(0, 2, size=nsteps)

In [98]: steps = np.where(draws>0,1,-1)

In [99]: walk = steps.cumsum()

In [101]: walk.min()
Out[101]: -24

In [102]: walk.max()
Out[102]: 9
```
然后可以计算首次穿越时间，即随机漫步过程中第一次到达某个特定值的时间。使用`np.abs(walk)>=10`得到一个布尔型数组，它表示的距离是否达到或超过10，使用`argmax`(并不高效，会对数组进行完全扫描)找到布尔型数组第一个最大值索引(True就是最大值):
```
In [103]: (np.abs(walk)>=10).argmax()
Out[103]: 107
```

### 一次模拟多个随机漫步
通过给`numpy.random`函数传入一个二元元组产生一个二维数组,然后使用累计和创建随机漫步过程(一行一个)，接着计算最大值和最小值。得到这些数据后来计算30或-30的最小穿越时间。因为不是5000个都达到了30，所以使用`any`进行检查，然后利用检查后的布尔数组选出哪些穿越了30(绝对值)的随机漫步(行)，并调用`argmax`在轴1上获取穿越时间
```
In [104]: nwalks = 5000

In [105]: nsteps = 5000

In [106]: draws = np.random.randint(0,2,size=(nwalks,nsteps))

In [107]: steps = np.where(draws>0,1,-1)

In [108]: walks = steps.cumsum(1)

In [109]: walks
Out[109]:
array([[  -1,   -2,   -1, ...,   20,   19,   18],
       [  -1,    0,    1, ...,   16,   17,   18],
       [  -1,    0,    1, ...,   80,   79,   78],
       ...,
       [   1,    2,    3, ...,    6,    5,    6],
       [   1,    0,   -1, ..., -130, -131, -132],
       [   1,    0,    1, ...,  -16,  -17,  -16]])

In [110]: walks.max()
Out[110]: 255

In [111]: walks.min()
Out[111]: -235

In [112]: hits30 = (np.abs(walks)>=30).any(1)

In [113]: hits30
Out[113]: array([ True,  True,  True, ...,  True,  True,  True])

In [115]: hits30.sum()
Out[115]: 4992

In [117]: crossing_time  =(np.abs(walks[hits30])>=30).argmax(1)

In [118]: crossing_time.mean()
Out[118]: 883.0564903846154
```
