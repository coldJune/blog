---
title: numpy基础(一)
date: 2018-03-16 08:38:29
categories: 数据分析
copyright: true
tags:
    - NumPy
    - 数据分析
description: NumPy(Numerical Python的简称)是高性能科学计算和数据分析的基础包。NumPy本身并没有提供多么高级的数据分析功能，理解NumPy数组及面向数组的计算将在使用Pandas之类的工具时更加高效。
---
NumPy[^1]的部分功能如下：
* ndarray，一个具有矢量运算和复杂广播能力的快熟且节省空间的多维数组
* 用于对数组数据进行快速运算的标准数学函数
* 线性代数、随机数生成及傅里叶变换功能
* 用于集成C、C++、Fortran等语言编写的代码的工具

对于大部分数据分析应用，关注的功能集中在：
* 用于数据整理和清理、子集构造和过滤、转换等快速的矢量化数组运算
* 常用的数组算法，如排序、唯一化、集合运算等
* 高效的描述统计和数据聚合/摘要运算
* 用于异构数据集的合并/连接运算的数据对齐和关系型数据运算
* 将条件逻辑表述为数组表达式(而不是带有if-ekif-else分支的循环)
* 数据的分组运算(聚合、转换、函数应用等)

## 多维数组对象(ndarray)
N维数组对象(即ndarray)是一个快速而灵活的大数据集容器。可以利用这种数组执行一些数学运算，语法和标量元素之间的运算一样：
```
In [4]: data = np.array([[1,2,3],[3,4,5]])

In [5]: data
Out[5]:
array([[1, 2, 3],
       [3, 4, 5]])

In [6]: data*10
Out[6]:
array([[10, 20, 30],
       [30, 40, 50]])

In [7]: data+data
Out[7]:
array([[ 2,  4,  6],
       [ 6,  8, 10]])
```

### 创建ndarray
array函数是创建数组最简单的方法，它接受一切序列型的对象(包括其他数组)，然后产生一个新的含有传入数据的NumPy数组。
* 数组创建函数

|       函数        |                                                    说明                                                     |
|:-----------------:|:-----------------------------------------------------------------------------------------------------------:|
|       array       | 将输入数据(列表、元组或其他序列类型)转换为ndarray。要么推断出dtype，要么显示指定dtype。默认直接复制输入数据 |
|      asarray      |                        将输入转换为ndarray，如果输入本身就是一个ndarray就不进行复制                         |
|      arange       |                             类似于内置的range，但返回的是一个ndarray而不是列表                              |
|  ones、ones_like  |    根据指定的形状和dtype创建一个全1数组。ones_like以另一个数组为参数，并根据其形状和dtype创建一个全1数组    |
| zeros、zeros_like |                                     类似于ones、ones_like，产生全0数组                                      |
| empty、empty_like |                                  创建新数组，只分配内存空间但不填充任何值                                   |
|   eye、identity   |                                创建一个正方的NXN单位矩阵(对角线为1，其余为0)                                |
* 列表转换

```
In [8]: arr1 = np.array([1,2,3])

In [9]: arr1
Out[9]: array([1, 2, 3])
```
* 嵌套序列将会被转换为一个多维数组:

```
In [10]: arr2 = np.array([[1,2,3],[1,2,3]])

In [11]: arr2
Out[11]:
array([[1, 2, 3],
       [1, 2, 3]])
```
除非显式说明，`np.array`会尝试为新建的数组推断一个合适的数据类型。数据类型保存在一个特殊的dtype对象中:
```
In [12]: arr1.dtype
Out[12]: dtype('int32')
```
除了`np.array`之外，`zeros`和`ones`可以创建指定长度或形状的全0或全1数组。`empty`可以创建一个没有任何具体值的数组。使用这些方法创建数组，只需传入一个表示形状的元组:
```
In [15]: np.zeros(10)
Out[15]: array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])

In [16]: np.zeros((3,2))
Out[16]:
array([[ 0.,  0.],
       [ 0.,  0.],
       [ 0.,  0.]])

In [17]: np.empty((3,2,3))
Out[17]:
array([[[  6.23042070e-307,   4.67296746e-307,   1.69121096e-306],
        [  1.33511290e-306,   1.15711989e-306,   1.42418987e-306]],

       [[  1.37961641e-306,   1.60220528e-306,   1.24611266e-306],
        [  9.34598925e-307,   1.24612081e-306,   1.11260755e-306]],

       [[  1.60220393e-306,   1.51320640e-306,   9.34609790e-307],
        [  1.86921279e-306,   1.24610723e-306,   0.00000000e+000]]])
```
**使用empty方法创建的数组返回的是一些未初始化的垃圾值，而不是0**
`arange`是Python内置函数`range`的数组版:
```
In [18]: np.arange(5)
Out[18]: array([0, 1, 2, 3, 4])
```

### ndarray的数据类型
* NumPy的数据类型

|               类型                | 类型代码 |                                       说明                                       |
|:---------------------------------:|:--------:|:--------------------------------------------------------------------------------:|
|            int8、uint8            |  i1、u1  |                         有符号和无符号的8位(1个字节)整型                         |
|           int16、uint16           |  i2、u2  |                        有符号和无符号的18位(2个字节)整型                         |
|           int32、uint32           |  i4、u4  |                        有符号和无符号的32位(4个字节)整型                         |
|           int64、uint64           |  i8、u8  |                        有符号和无符号的64位(8个字节)整型                         |
|              float16              |    f2    |                                   半精度浮点数                                   |
|              float32              |  f4或f   |                        标准的单精度浮点数。与C的float兼容                        |
|              float64              |  f8或d   |              标准的双精度浮点数。与C的double和Python的float对象兼容              |
|             float128              |  f16或g  |                                  扩展精度浮点数                                  |
| complex64、complex128、complex256 |   c32    |                                       复数                                       |
|               bool                |    ?     |                            存储True和False的布尔类型                             |
|              object               |    O     |                                  Python对象类型                                  |
|              string_              |    S     | 固定长度的字符串类型(每个字符1个字节)。例如要创建一个长度为10的字符串，应使用S10 |
|             unicode_              |    U     |      固定长度的unicode类型(字节数由平台决定)。跟字符串的定义方式一样(如U10)      |

可以再创建array对象时使用`dtype`参数设定数据类型，也可以通过`astype`方法显示转换其`dtype`,如果将浮点数转换成整数，则小数部分将会被截断；如果字符串数组全是数字，也可以用`astype`将其转换为数值形式：
```
In [19]: arr = np.array([1.2,-3.4,5.6], dtype='f8')

In [20]: arr.dtype
Out[20]: dtype('float64')

In [21]: arr.astype(np.int32)
Out[21]: array([ 1, -3,  5])

In [22]: numeric_string = np.array(['1.5','2.5','1.1'],dtype=np.string_)

In [23]: numeric_string.astype(np.float64)
Out[23]: array([ 1.5,  2.5,  1.1])
```

### 数组和标量之间的运算
**矢量化** 是指数组不用编写任何循环即可对数据执行批量运算。大小相等的数组之间的任何算术运算都会将运算应用到元素级：
```
In [24]: arr = np.array([[1,1,1],[2,2,2]])

In [25]: arr*arr
Out[25]:
array([[1, 1, 1],
       [4, 4, 4]])

In [26]: arr+arr
Out[26]:
array([[2, 2, 2],
       [4, 4, 4]])
```
数组和标量的运算会将标量值传播到各个元素:
```
In [27]: 1/arr
Out[27]:
array([[ 1. ,  1. ,  1. ],
       [ 0.5,  0.5,  0.5]])

In [28]: arr ** 0.5
Out[28]:
array([[ 1.        ,  1.        ,  1.        ],
       [ 1.41421356,  1.41421356,  1.41421356]])
```

### 基本的索引和切片
将一个标量赋值给一个切片时。改值会自动传播到整个选区。跟列表最重要的区别在于数组切片是原始数组的视图。这说明数据不会被复制，视图上的任何修改都会直接反映到原数组上:[^2]

```
In [35]: arr = np.arange(10)

In [36]: arr
Out[36]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

In [37]: arr_slice = arr[2:5]

In [38]: arr_slice
Out[38]: array([2, 3, 4])

In [39]: arr_slice[1:2] = 1000

In [40]: arr
Out[40]: array([   0,    1,    2, 1000,    4,    5,    6,    7,    8,    9])

In [41]: arr_slice
Out[41]: array([   2, 1000,    4])
```
对于高维数组，各索引的位置上的元素不在是标量，而是降维数组，索引对各个元素进行递归访问。对二维数组而言，一级索引对应的事一维数组，二级索引对应的是一维数组下的元素索引(这里一维数组的元素是标量),索引有两种方式:
```
In [42]: arr = np.array([[1,2,3],[4,5,6]])

In [43]: arr
Out[43]:
array([[1, 2, 3],
       [4, 5, 6]])

In [44]: arr[0]
Out[44]: array([1, 2, 3])

In [45]: arr[0][1]
Out[45]: 2

In [46]: arr[0,2]
Out[46]: 3
```
对于高维数组而言，不添加索引返回整个数组，添加一级索引，返回一个降维数组(这里是2x3的数组)，添加二级索引则在一级索引的基础上添加索引返回(这里是一维数组):
```
In [47]: arr = np.array([[[1,2,3],[4,5,6]],[[7,8,9],[10,11,12]]])

In [48]: arr
Out[48]:
array([[[ 1,  2,  3],
        [ 4,  5,  6]],

       [[ 7,  8,  9],
        [10, 11, 12]]])

In [49]: arr[0]
Out[49]:
array([[1, 2, 3],
       [4, 5, 6]])

In [50]: arr[0,1]
Out[50]: array([4, 5, 6])
```
标量和数组都可以赋值给原数组:
```
In [67]: arr = np.array([[[1,2,3],[4,5,6]],[[7,8,9],[10,11,12]]])

In [68]: arr
Out[68]:
array([[[ 1,  2,  3],
        [ 4,  5,  6]],

       [[ 7,  8,  9],
        [10, 11, 12]]])

In [69]: old_arr = arr[0].copy()

In [70]: old_arr
Out[70]:
array([[1, 2, 3],
       [4, 5, 6]])

In [71]: arr[0]= 1

In [72]: arr
Out[72]:
array([[[ 1,  1,  1],
        [ 1,  1,  1]],

       [[ 7,  8,  9],
        [10, 11, 12]]])

In [73]: arr[0] = old_arr

In [74]: arr
Out[74]:
array([[[ 1,  2,  3],
        [ 4,  5,  6]],

       [[ 7,  8,  9],
        [10, 11, 12]]])
```
#### 切片索引
ndarray的切片语法跟Python列表的一维对象差不多，但是高纬度对象的花样很多，可以在一个或多个轴上进行切片，也可以跟整数索引混合使用,传入多个切片和索引相同都是递归切片:[^3]
```
In [75]: arr2d = np.array([[1,2,3],[3,4,5]])

In [76]: arr2d
Out[76]:
array([[1, 2, 3],
       [3, 4, 5]])

In [77]: arr2d[:2]
Out[77]:
array([[1, 2, 3],
       [3, 4, 5]])

In [78]: arr2d[:2,:1]
Out[78]:
array([[1],
       [3]])
```
同时传入索引和切片可以得到低纬度的切片:
```
In [80]: arr2d[1,:1]
Out[80]: array([3])
```
只有`:`表示选取整个轴，可以通过这个对高纬度的进行切片：
```
In [81]: arr2d[:,:1]
Out[81]:
array([[1],
       [3]])
```
同时对切片表达式的赋值也会扩展到整个选区：
```
In [82]: arr2d[:,:1] = 0

In [83]: arr2d
Out[83]:
array([[0, 2, 3],
       [0, 4, 5]])
```
#### 布尔型索引
可以对数组使用比较运算，其返回一个布尔型数组；可以使用布尔型数组进行数组索引，会返回`True`对应的数组，布尔型数组的长度必须跟被索引的轴长度一致:
```
In [84]: names = np.array(['bob','john','tom'])

In [85]: data = randn(3,6)

In [86]: names
Out[86]:
array(['bob', 'john', 'tom'],
      dtype='<U4')

In [87]: data
Out[87]:
array([[-1.38783828,  1.53823048, -0.83396793,  2.53149852, -0.55033656,
         0.13621489],
       [-1.92912846,  1.45011928,  0.76228734,  1.37168505,  0.71817348,
        -0.48010419],
       [-0.27052654,  0.72243318, -0.53976533, -0.55488584, -0.18700473,
        -0.06341261]])

In [88]: names == 'bob'
Out[88]: array([ True, False, False], dtype=bool)

In [90]: data[names == 'bob']
Out[90]:
array([[-1.38783828,  1.53823048, -0.83396793,  2.53149852, -0.55033656,
         0.13621489]])

```
布尔型数组还可以和切片、整数(或整数序列)混合使用:
```
In [91]: data[names == 'bob',2:]
Out[91]: array([[-0.83396793,  2.53149852, -0.55033656,  0.13621489]])

In [92]: data[names == 'bob',2]
Out[92]: array([-0.83396793])
```
要选取除某个元素以外的值，可以使用不等号(`!=`)，也可以通过`~`对条件进行否定；同时也可以使用`&`(和)、`|`(或)之类的布尔运算符：
```
In [93]: data[names != 'bob']
Out[93]:
array([[-1.92912846,  1.45011928,  0.76228734,  1.37168505,  0.71817348,
        -0.48010419],
       [-0.27052654,  0.72243318, -0.53976533, -0.55488584, -0.18700473,
        -0.06341261]])

In [95]: data[~(names == 'bob')]
Out[95]:
array([[-1.92912846,  1.45011928,  0.76228734,  1.37168505,  0.71817348,
        -0.48010419],
       [-0.27052654,  0.72243318, -0.53976533, -0.55488584, -0.18700473,
        -0.06341261]])

In [97]: data[(names == 'bob')| (names=='tom')]
Out[97]:
array([[-1.38783828,  1.53823048, -0.83396793,  2.53149852, -0.55033656,
         0.13621489],
       [-0.27052654,  0.72243318, -0.53976533, -0.55488584, -0.18700473,
        -0.06341261]])

In [98]: data[(names == 'bob')& (names=='tom')]
Out[98]: array([], shape=(0, 6), dtype=float64)

```
通过布尔索引选取数组中的数据，总是创建数据的副本，即使返回一模一样的数组。

#### 花式索引
花式索引(Fancy indexing)指的是利用整数数组进行索引。为了以特定顺序选取行子集，只需传入一个指定顺序的整数列表或ndarray即可：
```
In [102]: arr = np.empty((7,4))

In [103]: for i in range(7):
     ...:     arr[i]=i
     ...:

In [104]: arr
Out[104]:
array([[ 0.,  0.,  0.,  0.],
       [ 1.,  1.,  1.,  1.],
       [ 2.,  2.,  2.,  2.],
       [ 3.,  3.,  3.,  3.],
       [ 4.,  4.,  4.,  4.],
       [ 5.,  5.,  5.,  5.],
       [ 6.,  6.,  6.,  6.]])

In [105]: arr[[4,3,1,2]]
Out[105]:
array([[ 4.,  4.,  4.,  4.],
       [ 3.,  3.,  3.,  3.],
       [ 1.,  1.,  1.,  1.],
       [ 2.,  2.,  2.,  2.]])
```
使用负数索引将会从末尾开始选取行:
```
In [106]: arr[[-4,-3,-1,-2]]
Out[106]:
array([[ 3.,  3.,  3.,  3.],
       [ 4.,  4.,  4.,  4.],
       [ 6.,  6.,  6.,  6.],
       [ 5.,  5.,  5.,  5.]])
```
一次性传入多个索引数组返回的事一个以为数组，其中的元素对应各个索引元组：
```
In [107]: arr = np.arange(32).reshape((8,4))

In [108]: arr
Out[108]:
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15],
       [16, 17, 18, 19],
       [20, 21, 22, 23],
       [24, 25, 26, 27],
       [28, 29, 30, 31]])

In [109]: arr[[1,2,3,4],[1,2,3,4]]

In [110]: arr[[1,2,3,4],[0,1,2,3]]
Out[110]: array([ 4,  9, 14, 19])
```
其中选出的元素是(1,0),(2,1),(3,2),(4,3)。而选取矩阵的行列子集的方法如下：
```
In [111]: arr[[1,2,3,4]][:,[0,1,2,3]]
Out[111]:
array([[ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15],
       [16, 17, 18, 19]])
```
选取矩阵的另一个方法是使用`np.ix_`函数，它可以将两个一维整数数组转换为一个用于选取方形区域的索引器：
```
In [112]: arr[np.ix_([1,2,3,4],[0,1,2,3])]
Out[112]:
array([[ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15],
       [16, 17, 18, 19]])
```
花式索引总是将数据复制到新数组中。

### 数组转置和轴对换
转置(transpose)是重塑的一种特殊形式，它返回的是源数据的视图。数组不仅有`transpose`方法，还有一个特殊的`T`属性，在计算内积的时候经常需要用到：
```
In [114]: arr.T
Out[114]:
array([[ 0,  4,  8, 12, 16, 20, 24, 28],
       [ 1,  5,  9, 13, 17, 21, 25, 29],
       [ 2,  6, 10, 14, 18, 22, 26, 30],
       [ 3,  7, 11, 15, 19, 23, 27, 31]])

In [115]: np.dot(arr.T, arr)
Out[115]:
array([[2240, 2352, 2464, 2576],
       [2352, 2472, 2592, 2712],
       [2464, 2592, 2720, 2848],
       [2576, 2712, 2848, 2984]])
```
`transpose`需要得到一个由轴编号组成的元组才能对这些轴进行转置:
```
In [126]: arr
Out[126]:
array([[[ 0,  1,  2],
        [ 3,  4,  5]],

       [[ 6,  7,  8],
        [ 9, 10, 11]]])

In [127]: arr.shape
Out[127]: (2, 2, 3)

In [128]: arr.transpose((1,2,0))
Out[128]:
array([[[ 0,  6],
        [ 1,  7],
        [ 2,  8]],

       [[ 3,  9],
        [ 4, 10],
        [ 5, 11]]])

In [129]: arr.transpose((1,0,2))
Out[129]:
array([[[ 0,  1,  2],
        [ 6,  7,  8]],

       [[ 3,  4,  5],
        [ 9, 10, 11]]])

```
上面`arr.shape`返回的结果是*(2,2,3)* 表明这是一个三维数组，形状为2x2x3,执行`arr.transpose((1,2,0))`对三个轴进行了重新排列形状变成了2x3x2。在原数组中元素对应的下标为：
```
[[[(0,0,0), (0,0,1), (0,0,2)],
  [(0,1,0), (0,1,1), (0,1,2)]],
  [[(1,0,0), (1,0,1), (1,0,2)],
  [(1,1,0), (1,1,1),(1,1,2)]]
]
```
进行轴变换之后的原下标变为:
```
(0,0,0)->(0,0,0)
(0,0,1)->(0,1,0)
(0,0,2)->(0,2,0)

(0,1,0)->(1,0,0)
(0,1,1)->(1,1,0)
(0,1,2)->(1,2,0)

(1,0,0)->(0,0,1)
(1,0,1)->(0,1,1)
(1,0,2)->(0,2,1)

(1,1,0)->(1,0,1)
(1,1,1)->(1,1,1)
(1,1,2)->(1,2,1)
```
将将上面重新编号后的索引对应轴排列并将原数组对应的数字填入其中：
```
[[[(0,0,0), (0,0,1)],    ->  (0,0,0) ,(1,0,0) -> 0,6
  [(0,1,0), (0,1,1)],    ->  (0,0,1) ,(1,0,1) -> 1,7
  [(0,2,0), (0,2,1)]],   ->  (0,0,2) ,(1,0,2) -> 2,8
 [[(1,0,0), (1,0,1)],    ->  (0,1,0) ,(1,1,0) -> 3,9
  [(1,1,0), (1,1,1)],    ->  (0,1,1) ,(1,1,1) -> 4,10
  [(1,2,0), (1,2,1)]]    ->  (0,1,2) ,(1,1,2) -> 5, 11
```
所以最后的数组变为：
```
array([[[ 0,  6],
        [ 1,  7],
        [ 2,  8]],

       [[ 3,  9],
        [ 4, 10],
        [ 5, 11]]])
```
`swapaxes`方法需要接受一对轴编号,其返回的事源数据的视图:
```
array([[[ 0,  1,  2],
        [ 3,  4,  5]],

       [[ 6,  7,  8],
        [ 9, 10, 11]]])

In [138]: arr.swapaxes(0,1)
Out[138]:
array([[[ 0,  1,  2],
        [ 6,  7,  8]],

       [[ 3,  4,  5],
        [ 9, 10, 11]]])
```

[^1]: NumPy将通过语句`import numpy as np`导入
[^2]: 使用副本需要显式地进行复制操作，`arr[1:4].copy()`
[^3]: 轴根据shape返回元组的大小确认，如果arr.shape返回(2,2,3)则表示这是一个三维数组，0就是对应第一个2的数轴，指的第一维，1对应第二个2的数轴，指的第二维，2对应3的数轴，指的第三维
