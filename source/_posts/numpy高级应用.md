---
title: numpy高级应用
date: 2018-03-29 16:20:05
categories: 数据分析
copyright: true
tags:
    - NumPy
    - 数据分析
description:
---
## ndarray对象的内部机制
NumPy的ndarray提供了一种同质数据块(连续/跨越)解释为多维数组对象的方式。**数据类型(dtype)** 决定了数据的解释方式。ndarray所有数组对象都是数据块的一个跨度视图，ndarray由以下内容组成:
1. 一个指向数组(一个系统内存块)的指针
2. 数据类型或dtype
3. 一个表示数组形状(shape)的元组，例如一个2x2的数组形状为(2,2)
4. 一个跨度元组(stride)，其中整数指的是为了前进到当前维度的下一个元素需要跨过的字节数(C顺序的3x4x5的float64(8字节)数组跨度为(160,40,8))
* ndarray的内部结构
![ndarray的内部结构](numpy高级应用/ndarray的内部结构.png)
跨度可以是负数，这样会使数组在内存中后向移动，切片中obj[::-1]或obj[:,::-1]就是如此

### NumPy数据类型体系
`dtype`都有一个超类，可以跟`np.issubdtype`函数结合使用，调用`dtype`的`mro`方法查看其所有父类:
```Python
In [2]: ints = np.ones(10,dtype=np.uint16)

In [3]: floats = np.ones(10,dtype=np.float32)

In [4]: np.issubdtype(ints.dtype,np.integer)
Out[4]: True

In [5]: np.issubdtype(floats.dtype,np.floating)
Out[5]: True

In [6]: np.float64.mro()#查看父类
Out[6]:
[numpy.float64,
 numpy.floating,
 numpy.inexact,
 numpy.number,
 numpy.generic,
 float,
 object]

```
* NumPy的dtype体系
![NumPy的dtype体系](numpy高级应用/NumPy的dtype体系.png)

## 高级数组操作
### 数组重塑
**数组重塑** 只需向数组的实例方法`reshape`传入一个表示新形状的元组，一维数组和多维数组都能被重塑，当作为参数形状的其中一维为 *-1* 时表示该维度的大小由数据本身推断出来；可以将数组的`shape`属性传入`reshape`方法。与`reshape`将一维数组转换为多维数组的运算过程相反的运算叫做 **扁平化(flattening)** 或 **散开(raveling)**,`ravel`不会产生源数据的副本，`flatten`方法返回数据的副本:
```Python
In [7]: arr = np.arange(8)

In [8]: arr
Out[8]: array([0, 1, 2, 3, 4, 5, 6, 7])

In [9]: arr.reshape((4,2)) #转换为一个4x2的矩阵
Out[9]:
array([[0, 1],
       [2, 3],
       [4, 5],
       [6, 7]])

In [10]: arr.reshape((4,2)).reshape((2,4)) #重塑多维数组
Out[10]:
array([[0, 1, 2, 3],
       [4, 5, 6, 7]])


In [13]: arr = np.arange(15)

In [14]: arr.reshape((3,-1)) #设置-1，让其自动推断
Out[14]:
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])

In [15]: other_arr = np.ones((5,3))

In [16]: other_arr.shape
Out[16]: (5, 3)

In [17]: arr.reshape(other_arr.shape) #使用数组的shape属性
Out[17]:
array([[ 0,  1,  2],
       [ 3,  4,  5],
       [ 6,  7,  8],
       [ 9, 10, 11],
       [12, 13, 14]])


In [19]: arr = arr.reshape((5,3))

In [21]: arr
Out[21]:
array([[ 0,  1,  2],
       [ 3,  4,  5],
       [ 6,  7,  8],
       [ 9, 10, 11],
       [12, 13, 14]])

In [22]: arr.ravel() #扁平化
Out[22]: array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])

In [24]: arr.flatten()
Out[24]: array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])

```

### C和Fortran顺序
**C顺序** 是指行优先顺序，对于一个二维数组，每行中的数据项是被存放在相邻内存位置上的。 **Fortran顺序** 是指列优先顺序，每列中的数据项是被存放在相邻内存位置上。`reshape`和`reval`这样的含糊可以接受一个表示数组数据存放顺序的`order`参数，一般是'C'或'F';C和Fortran顺序的关键区别是维度的行进顺序:
* C/行优先顺序：先经过更高的维度(*轴1优先于轴0被处理*)
* Fortran/列优先顺序: 后经过更高的维度(*轴0会先于轴1被处理*)

```Python
In [26]: arr = np.arange(12).reshape((3,4))

In [27]: arr.ravel() #行优先
Out[27]: array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])

In [28]: arr.ravel('F') #列优先
Out[28]: array([ 0,  4,  8,  1,  5,  9,  2,  6, 10,  3,  7, 11])

```
* 按行或列优先进行重塑
![按行或列优先进行重塑](numpy高级应用/按行或列优先进行重塑.png)

### 数组的合并和拆分
* 数组连接/拆分函数

|          函数          |                       说明                       |
|:----------------------:|:------------------------------------------------:|
|      concatenate       |       最一般化的连接，沿一条轴连接一组数组       |
|   vstack、row_stack    |       以面向行的方式对数组进行堆叠(沿轴0)        |
|         hstack         |       以面向列的方式对数组进行堆叠(沿轴1)        |
|      column_stack      | 类似于hstack，但是会先将一维数组转换为二维列向量 |
|         dstack         |     以面向"深度"的方式对数组进行堆叠(沿轴2)      |
|         split          |           沿指定轴在指定的位置拆分数组           |
| hsplit、vsplit、dsplit |      split的便捷化函数，分别沿轴0、轴1、轴2      |

```Python
In [29]: #使用numpy.concatenate按指定轴将一个由数组组成的序列连接到一起

In [30]: arr1 = np.array([[1,2,3],[4,5,6]])

In [31]: arr2 = np.array([[7,8,9],[10,11,12]])

In [32]: np.concatenate([arr1,arr2],axis=0)
Out[32]:
array([[ 1,  2,  3],
       [ 4,  5,  6],
       [ 7,  8,  9],
       [10, 11, 12]])

In [33]: np.concatenate([arr1,arr2],axis=1)
Out[33]:
array([[ 1,  2,  3,  7,  8,  9],
       [ 4,  5,  6, 10, 11, 12]])

In [34]: #使用vstack和hstack

In [35]: np.vstack((arr1,arr2))
Out[35]:
array([[ 1,  2,  3],
       [ 4,  5,  6],
       [ 7,  8,  9],
       [10, 11, 12]])

In [36]: np.hstack((arr1,arr2))
Out[36]:
array([[ 1,  2,  3,  7,  8,  9],
       [ 4,  5,  6, 10, 11, 12]])

In [37]: arr = np.random.randn(5,2)

In [38]: arr
Out[38]:
array([[ 1.37094925,  0.05685231],
       [-0.95278187,  0.06863068],
       [ 0.00680745, -0.67222854],
       [ 0.40865965, -0.63241948],
       [ 1.1155423 ,  2.87073277]])

In [39]: #使用split将一个数组沿指定轴拆分为多个数组

In [40]: first,sencond,third = np.split(arr,[1,3])

In [41]: first
Out[41]: array([[ 1.37094925,  0.05685231]])

In [42]: sencond
Out[42]:
array([[-0.95278187,  0.06863068],
       [ 0.00680745, -0.67222854]])

In [43]: third
Out[43]:
array([[ 0.40865965, -0.63241948],
       [ 1.1155423 ,  2.87073277]])
```
#### 堆叠辅助类：r_和c_
NumPy命名空间有两个特殊的对象`r_`和`c_`，它们能简化数组的堆叠操作:
```Python
In [44]: arr1 = np.arange(6).reshape((3,2))

In [45]: arr2 = randn(3,2)

In [46]: np.r_[arr1,arr2] #在列上堆叠
Out[46]:
array([[ 0.        ,  1.        ],
       [ 2.        ,  3.        ],
       [ 4.        ,  5.        ],
       [ 0.76365569,  0.53019635],
       [ 0.10616532, -0.66130024],
       [-0.20727219,  0.82787646]])

In [47]: np.c_[np.r_[arr1,arr2],np.arange(6)]#在列上堆叠后在行上堆叠
Out[47]:
array([[ 0.        ,  1.        ,  0.        ],
       [ 2.        ,  3.        ,  1.        ],
       [ 4.        ,  5.        ,  2.        ],
       [ 0.76365569,  0.53019635,  3.        ],
       [ 0.10616532, -0.66130024,  4.        ],
       [-0.20727219,  0.82787646,  5.        ]])

In [48]: #将切片翻译成数组

In [49]: np.c_[1:3,-3:-1]
Out[49]:
array([[ 1, -3],
       [ 2, -2]])

In [50]: np.r_[1:3,-3:-1]
Out[50]: array([ 1,  2, -3, -2])

```
### 元素的重复操作:tile和repeat
`repeat`会将数组中各个元素重复一定的次数，从而产生一个更大的数组，默认情况下如果传入的是一个整数，则各元素都会被重复那么多次。如果传入的是一组整数，则各元素就可以重复不同的次数。
```Python

In [48]: #将切片翻译成数组

In [49]: np.c_[1:3,-3:-1]
Out[49]:
array([[ 1, -3],
       [ 2, -2]])

In [50]: np.r_[1:3,-3:-1]
Out[50]: array([ 1,  2, -3, -2])

In [51]: arr = np.arange(3)

In [52]: arr
Out[52]: array([0, 1, 2])

In [53]: arr.repeat(3)
Out[53]: array([0, 0, 0, 1, 1, 1, 2, 2, 2])

In [55]: arr.repeat([2,3,4])
Out[55]: array([0, 0, 1, 1, 1, 2, 2, 2, 2])

In [56]: #指定轴重复

In [57]: arr = np.random.randn(2,2)

In [58]: arr
Out[58]:
array([[ 0.1934937 ,  0.02686283],
       [-1.37329786,  1.04754158]])

In [59]: arr.repeat(2,axis=0)
Out[59]:
array([[ 0.1934937 ,  0.02686283],
       [ 0.1934937 ,  0.02686283],
       [-1.37329786,  1.04754158],
       [-1.37329786,  1.04754158]])

In [60]: arr.repeat([2,3],axis=0)
Out[60]:
array([[ 0.1934937 ,  0.02686283],
       [ 0.1934937 ,  0.02686283],
       [-1.37329786,  1.04754158],
       [-1.37329786,  1.04754158],
       [-1.37329786,  1.04754158]])

In [61]: arr.repeat([2,3],axis=1)
Out[61]:
array([[ 0.1934937 ,  0.1934937 ,  0.02686283,  0.02686283,  0.02686283],
       [-1.37329786, -1.37329786,  1.04754158,  1.04754158,  1.04754158]])
```
`tile`的功能是沿指定轴向堆叠数组的副本，第二个参数是堆叠的次数，对于标量，是水平堆叠的，它还可以是一个元组
```Python
In [62]: arr
Out[62]:
array([[ 0.1934937 ,  0.02686283],
       [-1.37329786,  1.04754158]])

In [63]: np.tile(arr,2)
Out[63]:
array([[ 0.1934937 ,  0.02686283,  0.1934937 ,  0.02686283],
       [-1.37329786,  1.04754158, -1.37329786,  1.04754158]])

In [64]: np.tile(arr,(2,1))
Out[64]:
array([[ 0.1934937 ,  0.02686283],
       [-1.37329786,  1.04754158],
       [ 0.1934937 ,  0.02686283],
       [-1.37329786,  1.04754158]])

In [65]: np.tile(arr,(3,2))
Out[65]:
array([[ 0.1934937 ,  0.02686283,  0.1934937 ,  0.02686283],
       [-1.37329786,  1.04754158, -1.37329786,  1.04754158],
       [ 0.1934937 ,  0.02686283,  0.1934937 ,  0.02686283],
       [-1.37329786,  1.04754158, -1.37329786,  1.04754158],
       [ 0.1934937 ,  0.02686283,  0.1934937 ,  0.02686283],
       [-1.37329786,  1.04754158, -1.37329786,  1.04754158]])
```
### 花式索引的等价函数:take和put
ndarray有两个方法专门用于获取和设置单个轴向上的选区，要在其他轴上使用`take`需要传入`axis`关键字；`put`不接受`axis`参数，它只会在数组的扁平化版本(一维，C顺序)上进行索引：
```Python
In [66]: arr = np.arange(10)*100

In [67]: inds = [4,2,5,6]

In [68]: arr.take(inds)
Out[68]: array([400, 200, 500, 600])

In [69]: arr.put(inds,66)

In [70]: arr
Out[70]: array([  0, 100,  66, 300,  66,  66,  66, 700, 800, 900])

In [71]: # 其他轴上使用take

In [72]: ins = [2,0,2,1]

In [74]: arr = np.random.randn(2,4)

In [75]: arr
Out[75]:
array([[-1.16866402, -0.38862055, -0.30056282, -0.11058824],
       [-2.17866244,  0.06630283,  0.47301188, -0.00937435]])

In [77]: arr.take(ins,axis=1)
Out[77]:
array([[-0.30056282, -1.16866402, -0.30056282, -0.38862055],
       [ 0.47301188, -2.17866244,  0.47301188,  0.06630283]])

```

## 广播
**广播(broadcasting)** 指的是不同形状的数组之间的算术运算的执行方式，只要遵循一定的规则[^1]，低纬度的值可以被广播到数组的任意维度
* 一维数组在轴0上的广播
```Python
In [80]: arr = randn(4,3)

In [81]: arr.mean(0)
Out[81]: array([-0.28703998, -0.39306773,  0.41940885])

In [82]: demeaned = arr-arr.mean(0)

In [83]: demeaned
Out[83]:
array([[-0.99338257,  0.87131685,  0.65287535],
       [ 0.75548156,  0.13286309,  1.0316277 ],
       [-0.05877416, -0.41411289, -1.13737663],
       [ 0.29667517, -0.59006705, -0.54712642]])

In [84]: demeaned.mean(0)
Out[84]: array([ -1.38777878e-17,  -2.77555756e-17,   0.00000000e+00])
```
由于`arr.mean(0)`的长度为3，所以它可以在0轴(这里的行)进行广播，因为arr的后缘维度是3，所以它们是兼容的
![一维数组在轴0上的广播](numpy高级应用/一维数组在轴0上的广播.png)

要在1轴上做减法(各行减去行平均值)，较小的那个数组必须是(4,1)：
```Python
In [85]: arr
Out[85]:
array([[-1.28042256,  0.47824912,  1.0722842 ],
       [ 0.46844158, -0.26020464,  1.45103655],
       [-0.34581414, -0.80718062, -0.71796778],
       [ 0.00963519, -0.98313478, -0.12771757]])

In [86]: row_means = arr.mean(1)

In [87]: row_means.reshape((4,1))
Out[87]:
array([[ 0.09003692],
       [ 0.55309117],
       [-0.62365418],
       [-0.36707239]])

In [88]: demeaned = arr-row_means.reshape((4,1))

In [89]: demeaned
Out[89]:
array([[-1.37045948,  0.3882122 ,  0.98224728],
       [-0.08464958, -0.8132958 ,  0.89794539],
       [ 0.27784004, -0.18352644, -0.0943136 ],
       [ 0.37670757, -0.61606239,  0.23935482]])

In [90]: demeaned.mean(1)
Out[90]:
array([  3.70074342e-17,   0.00000000e+00,   7.40148683e-17,
         0.00000000e+00])

```
* 二维数组在轴1上的广播
![二维数组在轴1上的广播](numpy高级应用/二维数组在轴1上的广播.png)

* 三维数组再轴0上的广播
![三维数组再轴0上的广播](numpy高级应用/三维数组再轴0上的广播.png)

### 沿其他轴向广播
根据广播的原则，较小数组的"广播维"必须为1，对于三维的情况，在三维的任何一维上广播其实就是将数据重塑为兼容的形状，于是变需要专门为了广播添加一个长度为1的轴。NumPy数组通过特殊的`np.newaxis`属性以及 **"全"切片** 的方式插入新轴：
```Python
In [91]: arr = np.zeros((4,4))

In [92]: arr_3d = arr[:,np.newaxis,:]

In [93]: arr_3d
Out[93]:
array([[[ 0.,  0.,  0.,  0.]],

       [[ 0.,  0.,  0.,  0.]],

       [[ 0.,  0.,  0.,  0.]],

       [[ 0.,  0.,  0.,  0.]]])

In [94]: arr_3d.shape
Out[94]: (4, 1, 4)

In [In [95]: arr_1d = np.random.normal(size=3)

In [96]: arr_1d
Out[96]: array([-1.22549157, -0.3134849 ,  2.53183583])

In [97]: arr_1d[:,np.newaxis]
Out[97]:
array([[-1.22549157],
       [-0.3134849 ],
       [ 2.53183583]])

In [98]: arr_1d[np.newaxis,]
Out[98]: array([[-1.22549157, -0.3134849 ,  2.53183583]])

In [99]: #对一个三维数组的轴二进行距平化

In [102]: arr = np.random.randn(3,4,5)

In [103]: depth_means = arr.mean(2)

In [104]: depth_means
Out[104]:
array([[ 0.97772551, -0.31477537, -0.07086849, -0.00903146],
       [-0.05710366, -0.21994819, -0.88640694, -1.13437736],
       [ 0.2764665 ,  0.21509737,  0.17401022, -0.02444951]])

In [105]: demeaned =arr - depth_means[:,:,np.newaxis]

In [106]: demeaned
Out[106]:
array([[[ 0.18417271, -0.6440984 ,  0.33705976, -0.72700844,  0.84987438],
        [ 0.62215472,  0.96952659, -0.83439414,  0.53091573, -1.28820289],
        [-0.82589887, -1.21061523, -0.65990178,  1.04349758,  1.6529183 ],
        [-0.96572226, -0.17109805,  0.47527161,  0.29543314,  0.36611556]],

       [[-0.74199902,  1.0335094 ,  0.79082135,  0.74965704, -1.83198878],
        [-0.13308665, -0.06519346, -1.25928735, -0.53072789,  1.98829536],
        [-1.29463221,  0.74406668,  0.11684248,  2.0569325 , -1.62320945],
        [ 0.16037305, -0.28538757, -0.52345196,  1.32871473, -0.68024825]],

       [[ 1.85145343, -1.72601091, -1.15556288, -0.10519721,  1.13531758],
        [-1.68513998,  1.01516175,  0.05503934,  1.32854393, -0.71360504],
        [-0.42673112,  0.17061598, -1.07571345, -0.05948793,  1.39131652],
        [ 0.2301913 , -1.45091258,  0.1423503 ,  0.52866008,  0.54971089]]])

In [107]: demeaned.mean(2)
Out[107]:
array([[  4.44089210e-17,  -4.44089210e-17,   0.00000000e+00,
          3.33066907e-17],
       [  0.00000000e+00,   0.00000000e+00,   1.33226763e-16,
          1.33226763e-16],
       [  0.00000000e+00,  -4.44089210e-17,   0.00000000e+00,
          0.00000000e+00]])
```
* 能在三维数组上广播的二维数组的形状示例
![能在三维数组上广播的二维数组的形状示例](numpy高级应用/能在三维数组上广播的二维数组的形状示例.png)

### 通过广播设置数组的值
算术运算所遵循的广播原则同样适用于通过索引机制设置数组值的操作
```Python

In [108]: arr = np.zeros((4,3))

In [109]: arr[:] = 5

In [110]: arr
Out[110]:
array([[ 5.,  5.,  5.],
       [ 5.,  5.,  5.],
       [ 5.,  5.,  5.],
       [ 5.,  5.,  5.]])

In [111]: #用一个一维数组来设置目标数组的各列

In [112]: col = np.array([1,2,3,4])

In [113]: arr[:]=col[:,np.newaxis]

In [114]: arr
Out[114]:
array([[ 1.,  1.,  1.],
       [ 2.,  2.,  2.],
       [ 3.,  3.,  3.],
       [ 4.,  4.,  4.]])

In [115]: arr[:2] =[[5],[6]]

In [116]: arr
Out[116]:
array([[ 5.,  5.,  5.],
       [ 6.,  6.,  6.],
       [ 3.,  3.,  3.],
       [ 4.,  4.,  4.]])
```
## ufunc高级应用

* ufunc的方法

|         方法        |                               说明                              |
| :-----------------: | :-------------------------------------------------------------: |
|      reduce(x)      |             通过连续执行原始运算的方式对值进行聚合              |
|    accumulate(x)    |                   聚合值，保留所有局部聚合结果                  |
| reduceat(x,indices) |     “局部”约简(groupby)。约简数据的各个切片以产生聚合型数组     |
|      outer(x,y)     | 对x和y中的每对元素应用原始运算。结果数组的形状为x.shape+y.shape |

NumPy的各个[二元ufunc](http://coldjune.com/2018/03/17/numpy%E5%9F%BA%E7%A1%80-%E4%BA%8C/#%E9%80%9A%E7%94%A8%E5%87%BD%E6%95%B0)有一些执行特定矢量化运算的特殊方法。
* reduce
`reduce`方法接受一个数组参数，并通过一系列的二元运算对其进行聚合(可指明轴向)，例如对于`np.add.reduce`对数组中各个元素进行求和，其起始值取决于ufunc(对于add是0)；如果设置了轴号，约简运算会沿该轴向进行：
```Python
In [4]: arr = np.arange(10)

In [5]: np.add.reduce(arr)
Out[5]: 45

In [6]: arr.sum()
Out[6]: 45

In [7]: #用np.logical_and检查数组中各行是否有序

In [8]: arr = randn(5,5)

In [9]: arr[::2].sort(1) #对部分进行排序

In [11]: arr[:,:-1]<arr[:,1:]
Out[11]:
array([[ True,  True,  True,  True],
       [False,  True, False,  True],
       [ True,  True,  True,  True],
       [ True, False,  True,  True],
       [ True,  True,  True,  True]])

In [13]: np.logical_and.reduce(arr[:,:-1]<arr[:,1:],axis=1)#logical_and.reduce和all方法等价
Out[13]: array([ True, False,  True, False,  True])
```

* accumulate
`accumulate`产生一个跟原数组大小相同的中间"累计"值数组，它与`reduce`就像`cunsun`和`sum`一样:
```Python
In [14]: arr = np.arange(15).reshape((3,5))

In [15]: np.add.accumulate(arr,axis=1)
Out[15]:
array([[ 0,  1,  3,  6, 10],
       [ 5, 11, 18, 26, 35],
       [10, 21, 33, 46, 60]])
```

*  reduceat
`reduceat`用于计算"局部约简"，相当于是一个对数据各切片进行聚合的groupby运算，它接受一组用于指示如何对值进行拆分和聚合的"面元边界":
```Python
In [16]: arr = np.arange(10)

In [17]: np.add.reduceat(arr,[0,5,8])#在arr[0:5],arr[5:8],arr[8:0]进行约简(这里是求和)(划分的是左闭区间)
Out[17]: array([10, 18, 17])

In [21]: #在指定轴上进行约简

In [22]: arr = np.arange(15).reshape((3,5))

In [23]: arr
Out[23]:
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])

In [24]: np.add.reduceat(arr,[0,2,4],axis=1)
Out[24]:
array([[ 1,  5,  4],
       [11, 15,  9],
       [21, 25, 14]])
```

* outer
`outer`用于计算两个数组的叉积，其输出结果的维度是两个输入数据的维度之和:
```Python
In [26]: arr = np.arange(3).repeat([1,2,2])

In [27]: arr
Out[27]: array([0, 1, 1, 2, 2])

In [28]: np.multiply.outer(arr,np.arange(5))
Out[28]:
array([[0, 0, 0, 0, 0],
       [0, 1, 2, 3, 4],
       [0, 1, 2, 3, 4],
       [0, 2, 4, 6, 8],
       [0, 2, 4, 6, 8]])

In [33]: result = np.subtract.outer(np.arange(12).reshape((3,4)),np.arange(5))

In [34]: result
Out[34]:
array([[[ 0, -1, -2, -3, -4],
        [ 1,  0, -1, -2, -3],
        [ 2,  1,  0, -1, -2],
        [ 3,  2,  1,  0, -1]],

       [[ 4,  3,  2,  1,  0],
        [ 5,  4,  3,  2,  1],
        [ 6,  5,  4,  3,  2],
        [ 7,  6,  5,  4,  3]],

       [[ 8,  7,  6,  5,  4],
        [ 9,  8,  7,  6,  5],
        [10,  9,  8,  7,  6],
        [11, 10,  9,  8,  7]]])

In [35]: result.shape
Out[35]: (3, 4, 5)
```

### 自定义ufunc
`numpy.frompyfunc`和`numpy.vectorize`两个方法可以将自定义函数像ufunc那样使用，`numpy.frompyfunc`接受一个Python函数以及两个分别表示输入输出参数数量的整数，用`frompyfunc`创建的函数总是返回Python对象数组；`numpy.vectorize`在类型推断方面更智能一些。(*由于在计算每个元素时都执行一次Python函数调用，相对于自带的这种创建的ufunc型函数会慢很多*):
```Python
In [36]: def add_elements(x,y):
    ...:     # 加法的简单函数
    ...:     return x+y
    ...:

In [37]: add_them = np.frompyfunc(add_elements, 2, 1)

In [38]: add_them(np.arange(8),np.arange(8))
Out[38]: array([0, 2, 4, 6, 8, 10, 12, 14], dtype=object)

In [39]: # 使用numpy.vecorize

In [40]: add_them = np.vectorize(add_elements,otypes=[np.float64])

In [41]: add_them(np.arange(8),np.arange(8))
Out[41]: array([ 0.,  2.,  4.,  6.,  8., 10., 12., 14.])

In [42]: # 比较自带的ufunc和自建的ufunc性能

In [43]: arr = randn(1000)

In [44]: %timeit add_them(arr,arr)
477 µs ± 44.4 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)

In [45]: %timeit np.add(arr,arr)
2.22 µs ± 110 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
```

## 结构化和记录式数组
**结构化数组** 是一种特殊的ndarray，其中各个元素可以被看作C语言中的结构体或SQL表中带有各个命名字段的行，定义`dtype`典型的方法是元祖列表，各元组的格式为 *(filed_name, field_data_type)*，这样数组的元素就成了元组式的对象，该对象中各个元素可以像字典那样进行访问，字段名保存在`dtypes.names`属性中。在访问结构化数组的某个字段时，返回的是该数据的视图，所以不会发生数据复制。
结构化数组可以将单个内存块解释为带有任意复杂嵌套列的 **表格型结构**，数组中的每个元素都在内存中被表示为固定的字节数。所以其能提供快速高效的磁盘数据读写、网络传输等功能.
```Python
In [50]: dtype = [('e1', np.float64),('e2',np.int32)]

In [51]: sarr = np.array([(1.5,6),(2,3.4)],dtype=dtype)

In [52]: sarr
Out[52]: array([(1.5, 6), (2. , 3)], dtype=[('e1', '<f8'), ('e2', '<i4')])

In [53]: sarr[0]
Out[53]: (1.5, 6)

In [54]: sarr[1]
Out[54]: (2., 3)

In [55]: sarr['e1']
Out[55]: array([1.5, 2. ])

In [56]: sarr[1]['e1']
Out[56]: 2.0
```

### 嵌套dtype和多维字段
在定义结构化`dtype`时，可以设置一个形状( *整数或元组*)，也可以嵌套`dtype`
```Python
In [58]: dtype = [('e1', np.float64,3),('e2',np.int32)] #e1字段表示的是一个长度为3的数组

In [59]: arr = np.zeros(4,dtype=dtype)

In [60]: arr
Out[60]:
array([([0., 0., 0.], 0), ([0., 0., 0.], 0), ([0., 0., 0.], 0),
       ([0., 0., 0.], 0)], dtype=[('e1', '<f8', (3,)), ('e2', '<i4')])

In [61]: arr['e1'] #访问e1得到一个二维数组
Out[61]:
array([[0., 0., 0.],
       [0., 0., 0.],
       [0., 0., 0.],
       [0., 0., 0.]])

In [62]: # 嵌套dtype

In [63]: dtype = [('out1',[('in1','f8'),('in2','f4')]),('out2',np.int16)]

In [64]: data = np.array([((1,2),5),((3,4,),6)],dtype=dtype)

In [65]: data
Out[65]:
array([((1., 2.), 5), ((3., 4.), 6)],
      dtype=[('out1', [('in1', '<f8'), ('in2', '<f4')]), ('out2', '<i2')])

In [66]: data['out1']
Out[66]: array([(1., 2.), (3., 4.)], dtype=[('in1', '<f8'), ('in2', '<f4')])

In [67]: data['out1']['in2']
Out[67]: array([2., 4.], dtype=float32)
```

## 排序
ndarray的`sort`实例方法是就地排序，数组内容的重新排列不会产生新数组，**如果目标数组只是一个视图**，则原始数组将会被修改；`numpy.sort`会为元素组创建一个已排序副本且接受和`ndarray.sort`一样的参数；两个排序方法都可以接受一个`axis`参数来沿指定轴向对数据块进行单独排序，这两个方法均不可以设置为降序，可以通过`values[::-1]`返回一个反序的列表
* 数组排序算法

|     kind    | 速度 | 稳定性 | 工作空间 |  最坏情况  |
| :---------: | :--: | :----: | :------: | :--------: |
| 'quicksort' |  1   |   否   |    0     |   O(n^2)   |
| 'mergesort' |  2   |   是   |   n/2    | O(n log n) |
|  'heapsort' |  3   |   否   |    0     | O(n log n) |

```Python
In [71]: arr = randn(7)

In [72]: arr.sort()

In [73]: arr
Out[73]:
array([-0.89170014, -0.80979003,  0.29783243,  0.54719346,  0.70813987,
        0.92117061,  1.180511  ])

In [74]: arr = randn(3,5)

In [75]: arr
Out[75]:
array([[ 0.15479476, -0.52233606,  0.43424726,  0.62303973,  0.97207718],
       [-0.63949636, -0.53976961, -0.82786402,  1.18934999, -0.03449638],
       [ 1.46898713,  1.34104614, -1.49118633, -0.80856518,  1.12933992]])

In [76]: arr[:,0].sort() #对视图进行排序

In [77]: arr
Out[77]:
array([[-0.63949636, -0.52233606,  0.43424726,  0.62303973,  0.97207718],
       [ 0.15479476, -0.53976961, -0.82786402,  1.18934999, -0.03449638],
       [ 1.46898713,  1.34104614, -1.49118633, -0.80856518,  1.12933992]])

In [78]: # numpy.sort()

In [79]: arr = randn(5)

In [80]: arr
Out[80]: array([ 0.48399707,  2.34420952, -0.2882468 ,  0.67498985, -0.13933173])

In [81]: np.sort(arr)
Out[81]: array([-0.2882468 , -0.13933173,  0.48399707,  0.67498985,  2.34420952])

In [82]: arr
Out[82]: array([ 0.48399707,  2.34420952, -0.2882468 ,  0.67498985, -0.13933173])

In [83]: # 沿指定轴进行排序

In [84]: arr = randn(3,5)

In [85]: arr
Out[85]:
array([[ 0.56629486, -0.80691028,  0.99998769,  3.37353894,  0.28443593],
       [-0.32536803, -2.1990948 ,  0.52076016, -2.36260719, -0.06325647],
       [ 0.46436748,  0.46770738, -1.22818396, -1.60317798,  1.27239436]])

In [86]: arr.sort(axis=1)

In [87]: arr
Out[87]:
array([[-0.80691028,  0.28443593,  0.56629486,  0.99998769,  3.37353894],
       [-2.36260719, -2.1990948 , -0.32536803, -0.06325647,  0.52076016],
       [-1.60317798, -1.22818396,  0.46436748,  0.46770738,  1.27239436]])

In [88]: arr[:,::-1]#反序
Out[88]:
array([[ 3.37353894,  0.99998769,  0.56629486,  0.28443593, -0.80691028],
       [ 0.52076016, -0.06325647, -0.32536803, -2.1990948 , -2.36260719],
       [ 1.27239436,  0.46770738,  0.46436748, -1.22818396, -1.60317798]])
```

### 间接排序：argsort和lexsort
当需要根据一个或多个键对数据集进行排序时，给定一个或多个键，可以得到一个由整数组成的索引数组，其中的索引值表示在原数据的位置取相应的值填充新数据，`argsort`和`np.lexsort`实现了该功能:
```Python
In [98]: values = np.array([5,0,1,3,2])

In [99]: values
Out[99]: array([5, 0, 1, 3, 2])

In [100]: indexer = values.argsort()

In [101]: indexer
Out[101]: array([1, 2, 4, 3, 0])

In [102]: values[indexer]
Out[102]: array([0, 1, 2, 3, 5])

In [103]: # 根据数组的第一行进行排序

In [104]: arr = randn(3,5)

In [105]: arr[0] = values

In [106]: arr
Out[106]:
array([[ 5.        ,  0.        ,  1.        ,  3.        ,  2.        ],
       [-0.9539872 ,  1.03268562,  1.81014861, -1.5252794 ,  0.47952654],
       [-0.82301317,  0.09471158, -1.64912658,  0.539759  , -0.47313276]])

In [107]: arr[:,arr[0].argsort()]
Out[107]:
array([[ 0.        ,  1.        ,  2.        ,  3.        ,  5.        ],
       [ 1.03268562,  1.81014861,  0.47952654, -1.5252794 , -0.9539872 ],
       [ 0.09471158, -1.64912658, -0.47313276,  0.539759  , -0.82301317]])
```
`lexsort`可以一次性对多个键数组执行间接排序(字典序)：
```Python
In [108]: first_name = np.array(['Jim','June','Steven','Bill','Tom','Barbara'])

In [109]: last_mame = np.array(['Jones','Deng','Jones','Walters','Lucy','Jone'])

In [110]: soter = np.lexsort((first_name,last_mame))

In [111]: soter
Out[111]: array([1, 5, 0, 2, 4, 3])

In [116]: list(zip(last_mame[soter],first_name[soter]))
Out[116]:
[('Deng', 'June'),
 ('Jone', 'Barbara'),
 ('Jones', 'Jim'),
 ('Jones', 'Steven'),
 ('Lucy', 'Tom'),
 ('Walters', 'Bill')]
```
### 其他排序算法
在上面的表格中罗列出了一些排序算法，**稳定的(stable)** 排序算法会保持等价元素的相对位置，`mergsort`是这些当中唯一的稳定排序，它的平均性能比默认的`quicksort`(快速排序)要差：
```Python
In [117]: values = np.array(['2:first','2:sencond','1:first','1:second','1:third'])

In [118]: key = np.array([2,2,1,1,1])

In [119]: indexer = key.argsort(kind='mergesort')

In [120]: indexer
Out[120]: array([2, 3, 4, 0, 1])

In [121]: values.take(indexer)
Out[121]:
array(['1:first', '1:second', '1:third', '2:first', '2:sencond'],
      dtype='<U9')
```
### 在有序数组中查找元素
`searchsorted`是一个在有序数组上执行二分查找的数组元素，只要将值插入到它返回的位置就能维持数组的有序性，而传入一组值就能得到一组索引；`searchsorted`默认行为时返回相等值组的左侧索引，可以通过`siede='right'`来使用右侧索引:
```Python
In [128]: arr = np.array([0,1,4,51,63])

In [129]: arr.searchsorted(9)
Out[129]: 3

In [130]: arr.searchsorted([0,4,56,34])#相等的值返回左侧索引
Out[130]: array([0, 2, 4, 3])

In [131]: arr.searchsorted([0,4,56,34],side='right')#相等的值返回右侧索引
Out[131]: array([1, 3, 4, 3])

In [132]: #使用表示面元边界的数组将数据数组拆分开

In [133]: data = np.floor(np.random.uniform(0,10000,size=50))

In [134]: data
Out[134]:
array([6492., 6539., 1800., 3197., 4684., 2820., 1159., 4291., 8972.,
       4913., 8830.,  317., 1816., 5768., 3665., 6927., 9655., 1436.,
       9965., 7518., 7971., 9228., 3169., 5788., 4565., 2223., 5867.,
       5507., 4079., 5724., 3676., 6847., 6003., 7755.,  421., 6624.,
       9067., 2729.,  929., 3215.,  340., 7163., 9407., 3527., 2332.,
       7660.,  813., 4194., 3100., 3013.])

In [135]: bins = np.array([0,100,1000,5000,10000])

In [136]: #使用searchsorted获取各数据点所属区间的编号(1表示[0,100))

In [137]: labels = bins.searchsorted(data)

In [138]: labels
Out[138]:
array([4, 4, 3, 3, 3, 3, 3, 3, 4, 3, 4, 2, 3, 4, 3, 4, 4, 3, 4, 4, 4, 4,
       3, 4, 3, 3, 4, 4, 3, 4, 3, 4, 4, 4, 2, 4, 4, 3, 2, 3, 2, 4, 4, 3,
       3, 4, 2, 3, 3, 3])

In [139]: #通过groupby使用该结果对原始数据集进行拆分

In [140]: Series(data).groupby(labels).sum()
Out[140]:
2      2820.0
3     69603.0
4    171277.0
dtype: float64

In [141]: #digitize函数可以得到面元编号

In [142]: np.digitize(data,bins)
Out[142]:
array([4, 4, 3, 3, 3, 3, 3, 3, 4, 3, 4, 2, 3, 4, 3, 4, 4, 3, 4, 4, 4, 4,
       3, 4, 3, 3, 4, 4, 3, 4, 3, 4, 4, 4, 2, 4, 4, 3, 2, 3, 2, 4, 4, 3,
       3, 4, 2, 3, 3, 3])
```

## NumPy的matrix类
NumPy提供了一个[matrix类](https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.html?highlight=matrix)，单行或列会以二维形式返回，且使用星号(`*`)的乘法就是矩阵乘法，matrix还有一个特殊的属性`I`返回矩阵的逆。(*对于个别带有大量线性代数运算的函数，可以将函数参数转换为matrix类型，然后在返回之前用np.asarray将其转换为正规的ndarray*)：
```Python
In [146]: X = np.random.randn(16).reshape((4,4))

In [147]: Xm = np.matrix(X)

In [148]: ym =Xm[:,0]

In [149]: Xm
Out[149]:
matrix([[-0.15559707, -0.99331439,  0.47359971, -0.01311698],
        [ 0.02949084,  1.44680113,  0.52641512,  0.35424227],
        [-0.08636669,  0.84882811, -0.44418401,  1.87720362],
        [ 2.50948611,  0.71447812,  0.37073346, -0.22516639]])

In [150]: ym
Out[150]:
matrix([[-0.15559707],
        [ 0.02949084],
        [-0.08636669],
        [ 2.50948611]])

In [151]: ym.T*Xm*ym
Out[151]: matrix([[-2.80055856]])

In [152]: Xm.I*X
Out[152]:
matrix([[ 1.00000000e+00,  0.00000000e+00,  0.00000000e+00,
          0.00000000e+00],
        [ 0.00000000e+00,  1.00000000e+00, -6.93889390e-17,
          0.00000000e+00],
        [-2.77555756e-17,  5.55111512e-17,  1.00000000e+00,
          0.00000000e+00],
        [-2.77555756e-17, -1.11022302e-16, -2.77555756e-17,
          1.00000000e+00]])
```

## 高级数组的输入输出
[`np.save`和`np.load`](http://coldjune.com/2018/03/17/numpy%E5%9F%BA%E7%A1%80-%E4%BA%8C/#%E5%B0%86%E6%95%B0%E7%BB%84%E4%BB%A5%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%A0%BC%E5%BC%8F%E4%BF%9D%E5%AD%98%E5%88%B0%E7%A3%81%E7%9B%98)可用于读写磁盘上以二进制格式存储的数组，而 **内存映像(memory map)**能处理内存中放不下的数据集。

### 内存映像文件
**内存映像文件**是一种将磁盘上的非常大的二进制数据文件当做内存中的数组进行处理的方式。NumPy实现的类似于`ndarray`的 **memmap对象允许将大文件分成小段进行读写而不是一次性将整个数组读入内存**，基本上能用于`ndarray`的算法也能用于`memmap`。对`memmap`切片返回磁盘上数据的视图，如果对视图进行赋值，数据会先缓存在内存中，调用`flush`方法将其写入磁盘；只要某个内存映像超出了作用域就会被垃圾回收器回收，之前做的任何修改会被写入磁盘。当打开一个窨井存在的内存映像时，需要指明 **数据类型**和 **形状**(*磁盘上只是一块二进制数据，没有任何元数据*)；**内存映像是存放在磁盘上的ndarray**，所以可以使用结构化dtype:
```Python
In [157]: # 使用np.memmap并传入一个文件路径，数据类型，形状以及文件模式

In [158]: mmap = np.memmap('mymmap',dtype='f8',mode='w+',shape=(10000,10000))

In [159]: mmap
Out[159]:
memmap([[0., 0., 0., ..., 0., 0., 0.],
        [0., 0., 0., ..., 0., 0., 0.],
        [0., 0., 0., ..., 0., 0., 0.],
        ...,
        [0., 0., 0., ..., 0., 0., 0.],
        [0., 0., 0., ..., 0., 0., 0.],
        [0., 0., 0., ..., 0., 0., 0.]])

In [160]: #对memmap进行切片返回磁盘数据的视图

In [162]: section = mmap[:5]

In [163]: # 对其赋值并写会磁盘映像

In [164]: section[:] = np.random.randn(5,10000)

In [165]: mmap.flush()

In [166]: mmap
Out[166]:
memmap([[-0.76334573, -0.63262078,  0.32267608, ...,  0.58519542,
          0.33744543,  0.15489497],
        [-1.5176626 , -0.56939983,  0.85359754, ..., -0.0471389 ,
         -0.69515072,  0.72046585],
        [ 1.35572875,  1.93748025, -0.50928442, ...,  0.49249934,
         -0.45443455,  1.04739763],
        ...,
        [ 0.        ,  0.        ,  0.        , ...,  0.        ,
          0.        ,  0.        ],
        [ 0.        ,  0.        ,  0.        , ...,  0.        ,
          0.        ,  0.        ],
        [ 0.        ,  0.        ,  0.        , ...,  0.        ,
          0.        ,  0.        ]])

In [167]: del mmap #删除mmap

In [168]: mmap
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
<ipython-input-168-49f7bdb78b33> in <module>()
----> 1 mmap

NameError: name 'mmap' is not defined

In [169]: #读取memmap需要指明数据类型和形状

In [170]: mmap = np.memmap('mymmap',dtype='f8',shape=(10000,10000))

In [171]: mmap
Out[171]:
memmap([[-0.76334573, -0.63262078,  0.32267608, ...,  0.58519542,
          0.33744543,  0.15489497],
        [-1.5176626 , -0.56939983,  0.85359754, ..., -0.0471389 ,
         -0.69515072,  0.72046585],
        [ 1.35572875,  1.93748025, -0.50928442, ...,  0.49249934,
         -0.45443455,  1.04739763],
        ...,
        [ 0.        ,  0.        ,  0.        , ...,  0.        ,
          0.        ,  0.        ],
        [ 0.        ,  0.        ,  0.        , ...,  0.        ,
          0.        ,  0.        ],
        [ 0.        ,  0.        ,  0.        , ...,  0.        ,
          0.        ,  0.        ]])

```

## 性能建议
1. 将Python循环和条件逻辑转换为数组运算和布尔数组运算
2. 尽量使用广播
3. 避免复制数据，尽量使用数组视图(即切片)
4. 利用ufunc及各种方法
[^1]: 广播的原则:如果两个数组的后缘维度(trailing dimension，即从末尾开始算起的维度)的轴长度相符或其中一方的长度为1，则认为它们是广播兼容的。广播会在缺失和(或)长度为1的维度上进行。
