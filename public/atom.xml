<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Stay Hungary</title>
  
  <subtitle>Programming is an art form</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://coldjune.com/"/>
  <updated>2018-02-23T07:31:50.758Z</updated>
  <id>http://coldjune.com/</id>
  
  <author>
    <name>邓小俊</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网络编程(一)</title>
    <link href="http://coldjune.com/2018/02/22/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E4%B8%80/"/>
    <id>http://coldjune.com/2018/02/22/网络编程-一/</id>
    <published>2018-02-22T07:53:42.000Z</published>
    <updated>2018-02-23T07:31:50.758Z</updated>
    
    <content type="html"><![CDATA[<p>使用Python的一些模块来创建网络应用程序<br><a id="more"></a></p><h2 id="socket-函数模块"><a href="#socket-函数模块" class="headerlink" title="socket()函数模块"></a>socket()函数模块</h2><p>要创建套接字，必须使用<code>socket.socket()</code>函数<code>socket(socket_family, socket_type, protocol = 0)</code>,<br>其中<code>socket_family</code>是 <em>AF_UNIX</em> 或 <em>AF_INET</em>,<code>socket_type</code>是 <em>SOCK_STREAM</em> 或 <em>SOCK_DGRAM</em>。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup><br><code>protocol</code>通常省略，默认为0。</p><ol><li><blockquote><p>创建TCP/IP套接字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br></pre></td></tr></table></figure></blockquote></li><li><blockquote><p>创建UDP/IP套接字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udpSock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br></pre></td></tr></table></figure></blockquote></li></ol><h2 id="套接字对象内接方法"><a href="#套接字对象内接方法" class="headerlink" title="套接字对象内接方法"></a>套接字对象内接方法</h2><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">服务器套接字方法</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">s.bind()</td><td style="text-align:center">将地址(主机名、端口号对)绑定到套接字上</td></tr><tr><td style="text-align:center">s.listen()</td><td style="text-align:center">设置并启动TCP监听器</td></tr><tr><td style="text-align:center">s.accept()</td><td style="text-align:center">被动接受TCP客户端连接，一直等待知道连接到达(阻塞)</td></tr><tr><td style="text-align:center">客户端套接字方法</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">s.connect()</td><td style="text-align:center">主动发起TCP服务器连接</td></tr><tr><td style="text-align:center">s.connect_ex()</td><td style="text-align:center">connect()的扩展版本，此时会以错误码的形式返回问题，而不是抛出一个异常</td></tr><tr><td style="text-align:center">普通的套接字方法</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">s.recv()</td><td style="text-align:center">接受TCP消息</td></tr><tr><td style="text-align:center">s.recv_into()</td><td style="text-align:center">接受TCP消息到指定的缓冲区</td></tr><tr><td style="text-align:center">s.send()</td><td style="text-align:center">发送TCP消息</td></tr><tr><td style="text-align:center">s.sendall()</td><td style="text-align:center">完整地发送TCP消息</td></tr><tr><td style="text-align:center">s.recvfrom()</td><td style="text-align:center">接受UDP消息</td></tr><tr><td style="text-align:center">s.recvfrom_into()</td><td style="text-align:center">接受UDP消息到指定的缓冲区</td></tr><tr><td style="text-align:center">s.sendto()</td><td style="text-align:center">发送UDP消息</td></tr><tr><td style="text-align:center">s.getpeername()</td><td style="text-align:center">连接到套接字(TCP)的远程地址</td></tr><tr><td style="text-align:center">s.getsockname()</td><td style="text-align:center">当前套接字的地址</td></tr><tr><td style="text-align:center">s.getsockopt()</td><td style="text-align:center">返回给定套接字选项的值</td></tr><tr><td style="text-align:center">s.setsockopt()</td><td style="text-align:center">设置给定套接字选项的值</td></tr><tr><td style="text-align:center">s.shutdown()</td><td style="text-align:center">关闭连接</td></tr><tr><td style="text-align:center">s.close()</td><td style="text-align:center">关闭套接字</td></tr><tr><td style="text-align:center">s.detach()</td><td style="text-align:center">在未关闭文件描述符的情况下关闭套接字，返回文件描述符</td></tr><tr><td style="text-align:center">s.ioctl()</td><td style="text-align:center">控制套接字的模式(仅支持Windows)</td></tr><tr><td style="text-align:center">面向阻塞的套接字方法</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">s.setblocking()</td><td style="text-align:center">设置套接字的阻塞或非阻塞模式</td></tr><tr><td style="text-align:center">s.settimeout()</td><td style="text-align:center">设置阻塞套接字操作的超时时间</td></tr><tr><td style="text-align:center">s.gettimeout()</td><td style="text-align:center">获取阻塞套接字操作的超时时间</td></tr><tr><td style="text-align:center">面向文件的套接字方法</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">s.fileno()</td><td style="text-align:center">套接字的文件描述符</td></tr><tr><td style="text-align:center">s.makefile()</td><td style="text-align:center">创建与套接字关联的文件对象</td></tr><tr><td style="text-align:center">数据属性</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">s.family</td><td style="text-align:center">套接字家族</td></tr><tr><td style="text-align:center">s.type</td><td style="text-align:center">套接字类型</td></tr><tr><td style="text-align:center">s.proto</td><td style="text-align:center">套接字协议</td></tr></tbody></table><h2 id="创建TCP服务器-客户端"><a href="#创建TCP服务器-客户端" class="headerlink" title="创建TCP服务器/客户端"></a>创建TCP服务器/客户端</h2><h3 id="TCP服务器"><a href="#TCP服务器" class="headerlink" title="TCP服务器"></a>TCP服务器</h3><ul><li><p>下面是TCP服务器端的通用伪码，这是设计服务器的一种方式，可根据需求修改来操作服务器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ss = socket()                 <span class="comment">#创建服务器套接字</span></span><br><span class="line">ss.bind()                     <span class="comment">#套接字与地址绑定</span></span><br><span class="line">ss.listen()                   <span class="comment">#监听连接</span></span><br><span class="line">inf_loop:                     <span class="comment">#服务器无线循环</span></span><br><span class="line">    cs = ss.accept()          <span class="comment">#接受客户端连接</span></span><br><span class="line">    comm_loop:                <span class="comment">#通信循环</span></span><br><span class="line">        cs.recv()/cs.send()   <span class="comment">#对话(接收/发送)</span></span><br><span class="line">    cs.close()                <span class="comment">#关闭客户端套接字</span></span><br><span class="line">ss.close()                    <span class="comment">#关闭服务器套接字</span></span><br></pre></td></tr></table></figure></li><li><p>TCP时间戳服务器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding:UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入socket模块和time.ctime()的所有属性</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime</span><br><span class="line"></span><br><span class="line"><span class="comment"># HOST变量是空白，这是对bind()方法的标识，标识它可以使用任何可用的地址</span></span><br><span class="line"><span class="comment"># 选择一个随机的端口号</span></span><br><span class="line"><span class="comment"># 缓冲区大小为1KB</span></span><br><span class="line">HOST = <span class="string">''</span></span><br><span class="line">PORT = <span class="number">12345</span></span><br><span class="line">BUFSIZE = <span class="number">1024</span></span><br><span class="line">ADDR = (HOST, PORT)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分配了TCP服务套接字</span></span><br><span class="line"><span class="comment"># 将套接字绑定到服务器地址</span></span><br><span class="line"><span class="comment"># 开启TCP的监听调用</span></span><br><span class="line"><span class="comment"># listen()方法的参数是在连接被转接或拒绝之前，传入连接请求的最大数</span></span><br><span class="line">tcpSerSock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">tcpSerSock.bind(ADDR)</span><br><span class="line">tcpSerSock.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="comment"># 服务器循环，等待客户端的连接的连接</span></span><br><span class="line">    print(<span class="string">'waiting for connection...'</span>)</span><br><span class="line">    tcpCliSock, addr = tcpSerSock.accept()</span><br><span class="line">    print(<span class="string">'...connected from:'</span>, addr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="comment"># 当一个连接请求出现时，进入对话循环，接收消息</span></span><br><span class="line">        data = tcpCliSock.recv(BUFSIZE)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="comment"># 当消息为空时，退出对话循环</span></span><br><span class="line">            <span class="comment"># 关闭客户端连接，等待下一个连接请求</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        tcpCliSock.send(bytes(<span class="string">'[%s] %s'</span> % (</span><br><span class="line">            ctime(), data.decode(<span class="string">'utf-8'</span>)), <span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">    tcpCliSock.close()</span><br></pre></td></tr></table></figure></li></ul><h3 id="TCP客户端"><a href="#TCP客户端" class="headerlink" title="TCP客户端"></a>TCP客户端</h3><ul><li><p>下面是TCP客户端的通用伪码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cs = socket()           <span class="comment">#创建客户端套接字</span></span><br><span class="line">cs.connect()            <span class="comment">#尝试连接服务器</span></span><br><span class="line">comm_loop:              <span class="comment">#通信循环</span></span><br><span class="line">    cs.send()/cs.recv   <span class="comment">#对话(发送/接收)</span></span><br><span class="line">cs.close()              <span class="comment">#关闭客户端套接字</span></span><br></pre></td></tr></table></figure></li><li><p>TCP时间戳客户端</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入socket模块所有属性</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务器的主机名</span></span><br><span class="line"><span class="comment"># 服务器的端口号,应与服务器设置的完全相同</span></span><br><span class="line"><span class="comment"># 缓冲区大小为1KB</span></span><br><span class="line">HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line">PORT = <span class="number">12345</span></span><br><span class="line">BUFSIZE = <span class="number">1024</span></span><br><span class="line">ADDR = (HOST, PORT)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分配了TCP客户端套接字</span></span><br><span class="line"><span class="comment"># 主动调用并连接到服务器</span></span><br><span class="line">tcpCliSock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">tcpCliSock.connect(ADDR)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="comment"># 无限循环，输入消息</span></span><br><span class="line">    data = bytes(input(<span class="string">'&gt; '</span>), <span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">        <span class="comment"># 消息为空则退出循环</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 发送输入的信息</span></span><br><span class="line">    <span class="comment"># 接收服务器返回的信息，最后打印</span></span><br><span class="line">    tcpCliSock.send(data)</span><br><span class="line">    data = tcpCliSock.recv(BUFSIZE)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">        <span class="comment"># 消息为空则退出循环</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(data.decode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="comment"># 关闭客户端</span></span><br><span class="line">tcpCliSock.close()</span><br></pre></td></tr></table></figure></li></ul><h3 id="TCP服务器和客户端运行结果"><a href="#TCP服务器和客户端运行结果" class="headerlink" title="TCP服务器和客户端运行结果"></a>TCP服务器和客户端运行结果</h3><p>  在运行程序时，必须 <strong>首先运行服务器</strong> 程序，然后再运行客户端程序。如果先运行客户端程序，将会报未连接到服务器的错误。<br>  按正确的顺序启动程序后，在客户端输入信息，将会接收到加上时间戳处理后的信息，如果直接输入回车，将会关闭客户端，而服务器将会等待下一个连接请求</p><ul><li><p>服务器运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">waiting for connection...</span><br><span class="line">...connected from: (&apos;127.0.0.1&apos;, 53220)</span><br><span class="line">waiting for connection...</span><br></pre></td></tr></table></figure></li><li><p>客户端运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; hello</span><br><span class="line">[Fri Feb 23 14:22:58 2018] hello</span><br><span class="line">&gt; hi</span><br><span class="line">[Fri Feb 23 14:23:02 2018] hi</span><br><span class="line">&gt; hello world</span><br><span class="line">[Fri Feb 23 14:23:09 2018] hello world</span><br><span class="line">&gt;</span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></li></ul><h2 id="创建UDP服务器-客户端"><a href="#创建UDP服务器-客户端" class="headerlink" title="创建UDP服务器/客户端"></a>创建UDP服务器/客户端</h2><h3 id="UDP服务器"><a href="#UDP服务器" class="headerlink" title="UDP服务器"></a>UDP服务器</h3><ul><li><p>下面是UDP服务器的伪码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ss = socket()                           <span class="comment">#创建服务器套接字</span></span><br><span class="line">ss.bind()                               <span class="comment">#绑定服务器套接字</span></span><br><span class="line">inf_loop:                               <span class="comment">#服务器无线循环</span></span><br><span class="line">    cs = ss.recvfrom()/ss.sendto()      <span class="comment">#关闭(接收/发送)</span></span><br><span class="line">ss.close()                              <span class="comment">#关闭服务器套接字</span></span><br></pre></td></tr></table></figure></li><li><p>UDP时间戳服务器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding:UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入socket模块和time.ctime()的全部属性</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 与TCP相同，由于是无连接，所以没有调用监听传入连接</span></span><br><span class="line">HOST = <span class="string">''</span></span><br><span class="line">PORT = <span class="number">12345</span></span><br><span class="line">BUFSIZE = <span class="number">1024</span></span><br><span class="line">ADDR = (HOST, PORT)</span><br><span class="line"></span><br><span class="line">udpSerSock = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line">udpSerSock.bind(ADDR)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="comment"># 进入循环等待消息，一条消息到达时，处理并返回它，然后等待下一条消息</span></span><br><span class="line">    print(<span class="string">'waiting for message...'</span>)</span><br><span class="line">    data, addr = udpSerSock.recvfrom(BUFSIZE)</span><br><span class="line">    udpSerSock.sendto(bytes(<span class="string">'[%s] %s'</span> % (</span><br><span class="line">        ctime(), data.decode(<span class="string">'utf-8'</span>)), <span class="string">'utf-8'</span>), addr)</span><br><span class="line">    print(<span class="string">'...received from and returned to:'</span>, addr)</span><br></pre></td></tr></table></figure></li></ul><h3 id="UDP客户端"><a href="#UDP客户端" class="headerlink" title="UDP客户端"></a>UDP客户端</h3><ul><li><p>下面是客户端的伪码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cs = socket()                         <span class="comment">#创建客户端套接字</span></span><br><span class="line">comm_loop:                            <span class="comment">#通信循环</span></span><br><span class="line">    cs.sendto()/cs.recvfrom()         <span class="comment">#对话(发送/接收)</span></span><br><span class="line">cs.close()                            <span class="comment">#关闭客户端套接字</span></span><br></pre></td></tr></table></figure></li><li><p>UDP时间戳客户端</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/python3</span></span><br><span class="line"> <span class="comment"># -*- coding:UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"> HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line"> PORT = <span class="number">12345</span></span><br><span class="line"> BUFSIZE = <span class="number">1024</span></span><br><span class="line"> ADDR = (HOST, PORT)</span><br><span class="line"></span><br><span class="line"> udpClienSock = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">     data = bytes(input(<span class="string">'&gt;'</span>), <span class="string">'utf-8'</span>)</span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">     udpClienSock.sendto(data, ADDR)</span><br><span class="line">     data, ADDR = udpClienSock.recvfrom(BUFSIZE)</span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">     print(data.decode(<span class="string">'utf-8'</span>))</span><br><span class="line"> udpClienSock.close()</span><br></pre></td></tr></table></figure></li></ul><h3 id="UDP服务器和客户端运行结果"><a href="#UDP服务器和客户端运行结果" class="headerlink" title="UDP服务器和客户端运行结果"></a>UDP服务器和客户端运行结果</h3><p>  因为UDP面向无连接的服务，所以程序的启动顺序没有要求。当服务器处理完一个数据报之后在等待下一个继续处理</p><ul><li><p>服务器运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">waiting for message...</span><br><span class="line">...received from and returned to: (&apos;127.0.0.1&apos;, 51434)</span><br><span class="line">waiting for message...</span><br><span class="line">...received from and returned to: (&apos;127.0.0.1&apos;, 51434)</span><br><span class="line">waiting for message...</span><br></pre></td></tr></table></figure></li><li><p>客户端运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;hello</span><br><span class="line">[Fri Feb 23 15:23:57 2018] hello</span><br><span class="line">&gt;hi</span><br><span class="line">[Fri Feb 23 15:24:03 2018] hi</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><em>AF_UNIX</em> 是基于文件的套接字，代表 <em>地址家族(address family):UNIX</em>，<em>AF_INET</em> 是基于网络的套接字，代表 <em>地址家族：因特网</em>， <em>AF_INET6</em> 用于底6版因特网协议(IPv6)寻址。 <em>SOCK_STREAM</em> 表示面向连接的TCP套接字， <em>SOCK_DGRAM</em> 代表无连接的UDP套接字。</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Python的一些模块来创建网络应用程序&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://coldjune.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://coldjune.com/tags/Python/"/>
    
      <category term="网络编程" scheme="http://coldjune.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python正则表达式(三)</title>
    <link href="http://coldjune.com/2018/02/12/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E4%B8%89/"/>
    <id>http://coldjune.com/2018/02/12/Python正则表达式-三/</id>
    <published>2018-02-12T01:55:17.000Z</published>
    <updated>2018-02-22T07:38:59.798Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的两篇博文中，已经对正则表达式基本及核心的知识点进行了罗列和总结。而对于正则表达式的使用却缺乏实践。本文将基于《Python核心编程(第三版)》的练习题进行一些练习。<br><a id="more"></a></p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ol><li><blockquote><p>识别后续的字符串：“bat”、“bit”、“but”、“hat”、“hit”或者“hut”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">mode = re.compile(<span class="string">r'bat|bit|but|hat|hit|hut'</span>)</span><br><span class="line"><span class="comment">#mode  = re.compile(r'[bh][iau]t')</span></span><br><span class="line">strs = [<span class="string">'bat'</span>, <span class="string">'bit'</span>, <span class="string">'but'</span>, <span class="string">'hat'</span>, <span class="string">'hit'</span>, <span class="string">'hut'</span>]</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">    <span class="keyword">if</span> mode.match(s) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:mode.match(s).group()</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="string">'bat'</span></span><br><span class="line"><span class="string">'bit'</span></span><br><span class="line"><span class="string">'but'</span></span><br><span class="line"><span class="string">'hat'</span></span><br><span class="line"><span class="string">'hit'</span></span><br><span class="line"><span class="string">'hut'</span></span><br></pre></td></tr></table></figure></blockquote></li><li><blockquote><p>匹配由单个空格分隔的任意单词对，也就是姓和名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">mode  = re.compile(<span class="string">r'^[A-Za-z]+ [A-Za-z]+$'</span>)</span><br><span class="line">strs = [<span class="string">'david Bob'</span>, <span class="string">'D.Jone Steven'</span>, <span class="string">'Lucy D May'</span>]</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">    <span class="keyword">if</span> mode.match(s) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:mode.match(s).group()</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="string">'david Bob'</span></span><br></pre></td></tr></table></figure></blockquote></li><li><blockquote><p>匹配由单个逗号和单个空白符分隔的任何单词和单个字母，如姓氏的首字母。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">mode = re.compile(<span class="string">r'[A-Za-z]+,\s[A-Za-z]+'</span>)</span><br><span class="line">strs = [<span class="string">'david, Bob'</span>, <span class="string">'D.Jone, Steven'</span>, <span class="string">'Lucy, D, May'</span>]</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">    <span class="keyword">if</span> mode.match(s) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:mode.match(s).group()</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="string">'david, Bob'</span></span><br><span class="line"><span class="string">'Lucy, D'</span></span><br></pre></td></tr></table></figure></blockquote></li><li><blockquote><p>匹配所有有效Python 标识符<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>的集合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">mode = re.compile(<span class="string">r'[^0-9][\w_]+'</span>)<span class="comment">#用in排除关键字</span></span><br><span class="line">strs = [<span class="string">'1var'</span>, <span class="string">'v_ar'</span>, <span class="string">'_var'</span>, <span class="string">'var'</span>, <span class="string">'var_9'</span>, <span class="string">'var_'</span>]</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">    <span class="keyword">if</span> mode.match(s) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:mode.match(s).group()</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="string">'v_ar'</span></span><br><span class="line"><span class="string">'_var'</span></span><br><span class="line"><span class="string">'var'</span></span><br><span class="line"><span class="string">'var_9'</span></span><br><span class="line"><span class="string">'var_'</span></span><br></pre></td></tr></table></figure></blockquote></li><li><blockquote><p>根据读者当地的格式，匹配街道地址（使你的正则表达式足够通用，来匹配任意数<br>量的街道单词，包括类型名称）。例如，美国街道地址使用如下格式：1180 Bordeaux<br>Drive。使你的正则表达式足够灵活，以支持多单词的街道名称，如3120 De la Cruz<br>Boulevard。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">mode = re.compile(<span class="string">r'^\d&#123;4&#125;( [A-Z][a-z]+)+$'</span>)</span><br><span class="line">strs = [<span class="string">'1221 Bordeaux Drive'</span>, <span class="string">'54565 Bordeaux Drive'</span>, <span class="string">'Bordeaux Drive'</span>, <span class="string">'1221 Bordeaux Drive Drive'</span>]</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">    <span class="keyword">if</span> mode.match(s) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:mode.match(s).group()</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="string">'1221 Bordeaux Drive'</span></span><br><span class="line"><span class="string">'1221 Bordeaux Drive Drive'</span></span><br></pre></td></tr></table></figure></blockquote></li><li><blockquote><p>匹配以“www”起始且以“.com”结尾的简单Web 域名；例如，www://www. yahoo.com/。<br>选做题：你的正则表达式也可以支持其他高级域名，如.edu、.net 等（例如，<br><a href="http://www.foothill.edu）。" target="_blank" rel="noopener">http://www.foothill.edu）。</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">mode = re.compile(<span class="string">r'^(http[s]?://)?www\.(\w+\.)+(com|net|edu)$'</span>)</span><br><span class="line">strs=[<span class="string">'https://www.baidu.com'</span>, <span class="string">'http://www.bilibili.com'</span>, <span class="string">'www.baidu.com'</span>, <span class="string">'baidu.com'</span>, <span class="string">'www.cqupt.edu'</span>]</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">    <span class="keyword">if</span> mode.match(s) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:mode.match(s).group()</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="string">'https://www.baidu.com'</span></span><br><span class="line"><span class="string">'http://www.bilibili.com'</span></span><br><span class="line"><span class="string">'www.baidu.com'</span></span><br><span class="line"><span class="string">'www.cqupt.edu'</span></span><br></pre></td></tr></table></figure></blockquote></li><li><blockquote><p>匹配所有能够表示Python 整数的字符串集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">mode = re.compile(<span class="string">r'^\d+[lL]?$'</span>)</span><br><span class="line">strs = [<span class="string">'123'</span>, <span class="string">'123l'</span>, <span class="string">'12312L'</span>]</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">    <span class="keyword">if</span> mode.match(s) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:mode.match(s).group()</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="string">'123'</span></span><br><span class="line"><span class="string">'123l'</span></span><br><span class="line"><span class="string">'12312L'</span></span><br></pre></td></tr></table></figure></blockquote></li><li><blockquote><p>匹配所有能够表示Python 长整数的字符串集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">mode = re.compile(<span class="string">r'^\d+[lL]$'</span>)</span><br><span class="line">strs = [<span class="string">'123'</span>, <span class="string">'123l'</span>, <span class="string">'12312L'</span>]</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">    <span class="keyword">if</span> mode.match(s) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:mode.match(s).group()</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="string">'123l'</span></span><br><span class="line"><span class="string">'12312L'</span></span><br></pre></td></tr></table></figure></blockquote></li><li><blockquote><p>匹配所有能够表示Python 浮点数的字符串集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">mode = re.compile(<span class="string">r'(0|[1-9]\d*)(\.\d+)?$'</span>)</span><br><span class="line">strs = [<span class="string">'00.10'</span>, <span class="string">'0.123'</span>, <span class="string">'12.23'</span>, <span class="string">'12'</span>, <span class="string">'12.36l'</span>]</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">    <span class="keyword">if</span> mode.match(s) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:mode.match(s).group()   </span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="string">'0.123'</span></span><br><span class="line"><span class="string">'12.23'</span></span><br><span class="line"><span class="string">'12'</span></span><br></pre></td></tr></table></figure></blockquote></li><li><blockquote><p>匹配所有能够表示Python 复数的字符串集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">mode = re.compile(<span class="string">r'^((0|[1-9]\d*)(\.\d+)?\+)?((0|[1-9]\d*)(\.\d+)?j)?$'</span>)</span><br><span class="line">strs = [<span class="string">'12.3+1.2j'</span>, <span class="string">'1+2j'</span>, <span class="string">'4j'</span>]</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">    <span class="keyword">if</span> mode.match(s) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:mode.match(s).group()   </span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="string">'12.3+1.2j'</span></span><br><span class="line"><span class="string">'1+2j'</span></span><br><span class="line"><span class="string">'4j'</span></span><br></pre></td></tr></table></figure></blockquote></li><li><blockquote><p>匹配所有能够表示有效电子邮件地址的集合（从一个宽松的正则表达式开始，然<br>后尝试使它尽可能严谨，不过要保持正确的功能）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">mode = re.compile(<span class="string">r'^\w+@(\w+\.)+(com|com\.cn|net)$'</span>)</span><br><span class="line">strs = [<span class="string">'12345@qq.com'</span>, <span class="string">'sina@163.com'</span>, <span class="string">'qq@sina.com.cn'</span>, <span class="string">'net@21cn.com'</span>, <span class="string">'new123@163.sina.com'</span>]</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">    <span class="keyword">if</span> mode.match(s) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:mode.match(s).group()   </span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="string">'12345@qq.com'</span></span><br><span class="line"><span class="string">'sina@163.com'</span></span><br><span class="line"><span class="string">'qq@sina.com.cn'</span></span><br><span class="line"><span class="string">'net@21cn.com'</span></span><br><span class="line"><span class="string">'new123@163.sina.com'</span></span><br></pre></td></tr></table></figure></blockquote></li><li><blockquote><p>type()。内置函数type()返回一个类型对象，如下所示，该对象将表示为一个Pythonic<br>类型的字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">mode = re.compile(<span class="string">r'&lt;type \'(.*)\'&gt;'</span>)</span><br><span class="line">strs = [<span class="string">'&lt;type \'int\'&gt;'</span>, <span class="string">'&lt;type \'float\'&gt;'</span>, <span class="string">'&lt;type \'builtin_function_or_method\'&gt;'</span>]</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">    <span class="keyword">if</span> mode.match(s) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:mode.match(s).group(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="string">'int'</span></span><br><span class="line"><span class="string">'float'</span></span><br><span class="line"><span class="string">'builtin_function_or_method'</span></span><br></pre></td></tr></table></figure></blockquote></li><li><blockquote><p>处理日期。1.2 节提供了来匹配单个或者两个数字字符串的正则表达式模式，来表示1～<br>9 的月份(0?[1-9])。创建一个正则表达式来表示标准日历中剩余三个月的数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">mode = re.compile(<span class="string">r'1[0-2]'</span>)</span><br><span class="line">strs = [<span class="string">'10'</span>, <span class="string">'11'</span>, <span class="string">'12'</span>]</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">     <span class="keyword">if</span> mode.match(s) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:mode.match(s).group()</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="string">'10'</span></span><br><span class="line"><span class="string">'11'</span></span><br><span class="line"><span class="string">'12'</span></span><br></pre></td></tr></table></figure></blockquote></li><li><blockquote><p>创建一个允许使用连字符的正则表达式，但是仅能用于正确的位置。例如，15 位的信用卡号<br>码使用4-6-5 的模式，表明4 个数字-连字符-6 个数字-连字符-5 个数字；16 位的信用卡号码使用4-4-4-4 的模式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">mode = re.compile(<span class="string">r'\d&#123;4&#125;-((\d&#123;6&#125;-\d&#123;5&#125;)|(\d&#123;4&#125;-\d&#123;4&#125;-\d&#123;4&#125;))'</span>)</span><br><span class="line">strs = [<span class="string">'1234-567890-12345'</span>, <span class="string">'1234-5678-8012-3456'</span>]</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">    <span class="keyword">if</span> mode.match(s) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:mode.match(s).group()</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="string">'1234-567890-12345'</span></span><br><span class="line"><span class="string">'1234-5678-8012-3456'</span></span><br></pre></td></tr></table></figure></blockquote></li></ol><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">标识符有字母、数字、下划线组成，但不能由数字开头</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前的两篇博文中，已经对正则表达式基本及核心的知识点进行了罗列和总结。而对于正则表达式的使用却缺乏实践。本文将基于《Python核心编程(第三版)》的练习题进行一些练习。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://coldjune.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://coldjune.com/tags/Python/"/>
    
      <category term="正则表达式" scheme="http://coldjune.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python正则表达式(二)</title>
    <link href="http://coldjune.com/2018/02/10/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E4%BA%8C/"/>
    <id>http://coldjune.com/2018/02/10/Python正则表达式-二/</id>
    <published>2018-02-10T13:28:04.000Z</published>
    <updated>2018-02-11T08:18:55.912Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式的匹配规则基本已经在上一篇博文中全部罗列出来了，下面便是结合到具体语言进行学习和练习了。<br>由于个人兴趣和想要专研的方向，在这里将会使用Python <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 语言进行描述。<br><a id="more"></a></p><h2 id="正则表达式和Python语言"><a href="#正则表达式和Python语言" class="headerlink" title="正则表达式和Python语言"></a>正则表达式和Python语言</h2><h3 id="re模块：核心函数和方法"><a href="#re模块：核心函数和方法" class="headerlink" title="re模块：核心函数和方法"></a>re模块：核心函数和方法</h3><table><thead><tr><th style="text-align:center">函数方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">仅仅是re函数模块</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">compile(pattern, flags=0)</td><td style="text-align:center">使用任何可选的标记来编译正则表达式的模式，然后返回一个正则表达式对象</td></tr><tr><td style="text-align:center">re模块函数和正则表达式对象的方法</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">match(pattern, string, flags=0)</td><td style="text-align:center">尝试使用带有可选的标记的正则表达式的模式来匹配字符串，如果匹配成功，就返回匹配对象；如果失败，就返回None</td></tr><tr><td style="text-align:center">search(pattern, string, flags=0)</td><td style="text-align:center">使用可选标记搜索字符串中第一次出现的正则表达式模式。如果匹配成功，则返回匹配对象；如果匹配失败，怎返回None</td></tr><tr><td style="text-align:center">findall(pattern, string [,flags])</td><td style="text-align:center">查找字符串中所有(非重复)出现的正则表达式模式，并返回一个匹配列表</td></tr><tr><td style="text-align:center">finditer(pattern, string[,flags])</td><td style="text-align:center">与findall()函数相同，但返回的不是一个列表，而是一个迭代器。对于每一次匹配，迭代器都返回一个匹配对象</td></tr><tr><td style="text-align:center">split(pattern, string, max=0)</td><td style="text-align:center">根据正则表达式的模式分隔符，split函数将字符串分割为列表，然后返回成功的列表，分割最多操作max次(默认分割所有匹配成功的位置)</td></tr><tr><td style="text-align:center">sub(pattern, repl, string, count=0)</td><td style="text-align:center">使用repl替换所有正则表达式的模式在字符串中出现的位置，除非定义count，否则就讲替换所有出现的位置（另见subn()函数，该函数返回替换操作的数目）</td></tr><tr><td style="text-align:center">purge()</td><td style="text-align:center">清除隐式编译的正则表达式模式</td></tr><tr><td style="text-align:center">常见的匹配对象方法</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">group(num=0)</td><td style="text-align:center">返回整个匹配对象，或者编号为num的特定子组</td></tr><tr><td style="text-align:center">groups(default=None)</td><td style="text-align:center">返回一个包含所有匹配子组的元组(如果没有成功匹配，则返回一个空元组)</td></tr><tr><td style="text-align:center">groupdict(default=None)</td><td style="text-align:center">返回一个包含所有匹配的命名子组的字典，所有的子组名称作为字典的键(如果没有成功匹配，则返回一个空字典)</td></tr><tr><td style="text-align:center">常用的模块属性（用于大多数正则表达式函数的标记）</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">re.I,re.IGNORECASE</td><td style="text-align:center">不去分大小写的匹配</td></tr><tr><td style="text-align:center">re.L,re.LOCALE</td><td style="text-align:center">根据所使用的本地语言环境通过\w、\w、\b、\B、\s、\S实现匹配</td></tr><tr><td style="text-align:center">re.M,re.MULTILINE</td><td style="text-align:center">^和$分别匹配目标字符串中行的起始和结尾，而不是严格匹配整个字符串本身的起始和结尾</td></tr><tr><td style="text-align:center">re.S,re.DOTALL</td><td style="text-align:center">“.”(点号)通常匹配除了\n(换行符)之外的所有单个字符：该标记表示”.”(点号)能匹配全部字符</td></tr><tr><td style="text-align:center">re.X,re.VERBOSE</td><td style="text-align:center">通过反斜线转移，否则所有空格加上#(以及在该行中后续文字)都被忽略，除非在一个字符类中或者允许注释并且提高可读性</td></tr></tbody></table><h3 id="部分方法总结"><a href="#部分方法总结" class="headerlink" title="部分方法总结"></a>部分方法总结</h3><ul><li><p><em>compile(pattern, flags=0)<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></em></p><blockquote><p>使用预编译使用推荐的方式，但不是必须的，可以通过设置标志位(上表已罗列出使用频繁的标记，详情可以<a href="https://docs.python.org/3/library/re.html?highlight=re#module-re" target="_blank" rel="noopener">查阅文档</a>),标志位通过 （|）合并</p></blockquote></li><li><p><em>group(num=0)</em> 和 <em>groups(default=None)</em></p><blockquote><p>匹配对象<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>的两个主要方法。 <em>group()</em> 要么返回整个匹配对象，要么按要求返回特定子组。 <em>groups()</em> 仅返回一个包含唯一或全部子组的元组。如果没有子组的要求，<em>group()</em> 返回整个匹配，<em>groups()</em> 返回一个空元组。</p></blockquote></li><li><p><em>match(pattern, string, flags=0)</em></p><blockquote><p><em>match()</em> 方法试图从字符串的<strong>起始部分</strong>对模式进行匹配。如果匹配成功，返回一个匹配对象；如果失败就返回None</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#匹配成功</span></span><br><span class="line"> m = re.match(<span class="string">'foo'</span>, <span class="string">'foo'</span>) <span class="comment">#模式匹配字符串</span></span><br><span class="line"> <span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:         <span class="comment">#如果匹配成功，就输出匹配内容</span></span><br><span class="line">     m.group()</span><br><span class="line"></span><br><span class="line"><span class="string">'foo'</span>                       <span class="comment">#输出结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#匹配失败</span></span><br><span class="line">m  = re.match(<span class="string">'foo'</span>, <span class="string">'Bfoo'</span>) <span class="comment">#模式匹配字符串</span></span><br><span class="line"><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:           <span class="comment">#如果匹配成功，就输出匹配内容</span></span><br><span class="line">    m.group()</span><br><span class="line"></span><br><span class="line">                            <span class="comment">#因为起始字符为'B',所以匹配不成功，无任何输出</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p><em>search(pattern, string, flags=0)</em></p><blockquote><p><em>search()</em> 的工作方式和 <em>match()</em> 相同，不同之处在于 <em>search()</em> 会用它的字符串参数在<strong>任意位置</strong>对给定正则表达式模式搜索<strong>第一次</strong>出现的匹配情况。如果搜索到成功的匹配，就返回一个匹配对象；否则，就返回None。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将上面使用match()方法匹配的串改用search()匹配</span></span><br><span class="line">m = re.search(<span class="string">'foo'</span>, <span class="string">'Bfoo'</span>) <span class="comment">#模式匹配字符串</span></span><br><span class="line"><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:            <span class="comment">#如果匹配成功，就输出匹配内容</span></span><br><span class="line">    m.group()</span><br><span class="line"></span><br><span class="line"><span class="string">'foo'</span>                        <span class="comment">#可以看到就算起始位置未能匹配，也能匹配成功</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p><em>findall(pattern, string[,flags])</em> 和 <em>finditer(pattern, string[,flags])</em></p><blockquote><p><em>findall()</em> 总是返回一个列表，如果没有找到匹配对象，返回一个空列表<br>  <em>finditer()</em> 是一个与 <em>findall()</em> 类似但更节省内存的变体，<em>finditer()</em> 在匹配对象中迭代<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#findall()匹配</span></span><br><span class="line">re.findall(<span class="string">'car'</span>, <span class="string">'carry the barcardi to the car'</span>) <span class="comment">#模式匹配字符串</span></span><br><span class="line"></span><br><span class="line">[<span class="string">'car'</span>, <span class="string">'car'</span>, <span class="string">'car'</span>]                              <span class="comment">#返回结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#finditer()匹配</span></span><br><span class="line">iter = re.finditer(<span class="string">'car'</span>, <span class="string">'carry the barcardi to the car'</span>) <span class="comment">#模式匹配字符串</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> iter:                                            <span class="comment">#遍历迭代器</span></span><br><span class="line">    print(i.group())</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line">car</span><br><span class="line">car</span><br><span class="line">car</span><br></pre></td></tr></table></figure></blockquote></li><li><p><em>sub(pattern, repl, string, count=0)</em> 和 <em>subn(pattern, repl, string, count=0)</em></p><blockquote><p><em>sub()</em> 和 <em>subn()</em> 用于实现搜索和替换功能。两者都是将某字符串中所有匹配正则表达式的部分进行某种形式的替换。和 <em>sub()</em> 不同的是，<em>subn()</em> 返回一个表示替换的总数，替换后的字符串和表示替换总数的数字一起作为一个拥有两个元素的元组返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sub()</span></span><br><span class="line">re.sub(<span class="string">'car'</span>, <span class="string">'cat'</span>, <span class="string">'My car is not only a car.'</span>) <span class="comment">#模式匹配字符串</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'My cat is not only a cat.'</span>                         <span class="comment">#输出结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#subn()</span></span><br><span class="line">re.subn(<span class="string">'car'</span>, <span class="string">'cat'</span>, <span class="string">'My car is not only a car.'</span>) <span class="comment">#模式匹配字符串</span></span><br><span class="line"></span><br><span class="line">(<span class="string">'My cat is not only a cat.'</span>, <span class="number">2</span>)                   <span class="comment">#输出结果</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p><em>split(pattern, string, max=0)</em></p><blockquote><p>正则表达式对象的 <em>split()</em> 方法和字符串的工作方式类似，但它是基于正则表达式的模式分割字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">re.split(<span class="string">':'</span>, <span class="string">'str1:str2:str3'</span>)               <span class="comment">#模式匹配字符串</span></span><br><span class="line"></span><br><span class="line">[<span class="string">'str1'</span>, <span class="string">'str2'</span>, <span class="string">'str3'</span>]                      <span class="comment">#输出结果，与'str1:str2:str3'.split(':')相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#split()复杂用法</span></span><br><span class="line"><span class="comment">#使用split()基于逗号分割字符串，如果空格紧跟在5个数字或者两个大写字母之后，就用split()分割该空格</span></span><br><span class="line"><span class="comment">#使用(?=)正向前视断言，不适用输入字符串 而是使用后面的空格作为分割字符串</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">DATA = (</span><br><span class="line">  <span class="string">'Mountain View, CA 94040'</span>,</span><br><span class="line">  <span class="string">'Sunnyvale, CA'</span>,</span><br><span class="line">  <span class="string">'Los Altos, 94023'</span>,</span><br><span class="line">  <span class="string">'Cupertino 95014'</span>,</span><br><span class="line">  <span class="string">'Palo Alto CA'</span>,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">for</span> datum <span class="keyword">in</span> DATA:</span><br><span class="line">    print(re.split(<span class="string">', |(?= (?:\d&#123;5&#125;|[A-Z]&#123;2&#125;)) '</span>, datum))</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line">[<span class="string">'Mountain View'</span>, <span class="string">'CA'</span>, <span class="string">'94040'</span>]</span><br><span class="line">[<span class="string">'Sunnyvale'</span>, <span class="string">'CA'</span>]</span><br><span class="line">[<span class="string">'Los Altos'</span>, <span class="string">'94023'</span>]</span><br><span class="line">[<span class="string">'Cupertino'</span>, <span class="string">'95014'</span>]</span><br><span class="line">[<span class="string">'Palo Alto'</span>, <span class="string">'CA'</span>]</span><br></pre></td></tr></table></figure></blockquote></li></ul><h3 id="符号的使用"><a href="#符号的使用" class="headerlink" title="符号的使用"></a>符号的使用</h3><h4 id="与-和"><a href="#与-和" class="headerlink" title="| 与 . 和 []"></a><code>|</code> 与 <code>.</code> 和 <code>[]</code></h4><blockquote><p>包括择一匹配符号<code>|</code>、点号<code>.</code>，点号不匹配非字符或换行付\n（即空字符）<br>    字符集<code>[]</code>中的字符只取其一</p></blockquote><h4 id="重复、特殊字符5以及分组"><a href="#重复、特殊字符5以及分组" class="headerlink" title="重复、特殊字符5以及分组"></a>重复、特殊字符<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>以及分组</h4><blockquote><p><code>?</code>操作符表示前面的模式出现零次或一次<br><code>+</code>操作符表示前面的模式出现至少一次<br><code>*</code>操作符表示前面的模式出现任意次(包括0次)<br>分组从左起第一个括号开始算第一个分组<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">m  = re.match(<span class="string">'(\w(\w\w))-(\d\d\d)'</span>,<span class="string">'abc-123'</span>)</span><br><span class="line">m.group()                           <span class="comment">#完整匹配</span></span><br><span class="line"><span class="string">'abc-123'</span>                           <span class="comment">#输出结果</span></span><br><span class="line"></span><br><span class="line">m.group(<span class="number">1</span>)                          <span class="comment">#第一组</span></span><br><span class="line"><span class="string">'abc'</span>                               <span class="comment">#输出结果    </span></span><br><span class="line"></span><br><span class="line">m.group(<span class="number">2</span>)                          <span class="comment">#第二组</span></span><br><span class="line"><span class="string">'bc'</span>                                <span class="comment">#输出结果</span></span><br><span class="line"></span><br><span class="line">m.group(<span class="number">3</span>)                          <span class="comment">#第三组</span></span><br><span class="line"><span class="string">'123'</span>                               <span class="comment">#输出结果</span></span><br><span class="line"></span><br><span class="line">m.groups()                          <span class="comment">#全部子组</span></span><br><span class="line">(<span class="string">'abc'</span>, <span class="string">'bc'</span>, <span class="string">'123'</span>)                <span class="comment">#输出结果</span></span><br></pre></td></tr></table></figure></p></blockquote><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">这里Python指代的是Python3.6.4</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">预编译可以提升执行效率，而 <code>re.compile()</code> 方法提供了这个功能。模块函数会对已编译的对象进行缓存，所以无论使用 <code>match()</code> 和 <code>search()</code> 在执行时编译的正则表达式,还是使用 <code>compile()</code> 编译的表达式,在再次使用时都会查询缓存。但使用 <code>compile()</code> 同样可以节省查询缓存的时间</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">除了正则表达式对象之外，还有另外一个对象类型：<strong>匹配对象</strong>。这些是成功调用 <code>match()</code> 和 <code>search()</code> 返回的对象。</span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;">如果遇到无法调用 <code>next()</code>方法，可以使用 <code>__next__()</code>方法代替。</span><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">5.</span><span style="display: inline-block; vertical-align: top;">特殊字符的详情可以参考<a href="http://coldjune.com/2018/02/09/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E4%B8%80/">上一篇博文</a></span><a href="#fnref:5" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正则表达式的匹配规则基本已经在上一篇博文中全部罗列出来了，下面便是结合到具体语言进行学习和练习了。&lt;br&gt;由于个人兴趣和想要专研的方向，在这里将会使用Python &lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; 语言进行描述。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://coldjune.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://coldjune.com/tags/Python/"/>
    
      <category term="正则表达式" scheme="http://coldjune.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python正则表达式(一)</title>
    <link href="http://coldjune.com/2018/02/09/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E4%B8%80/"/>
    <id>http://coldjune.com/2018/02/09/Python正则表达式-一/</id>
    <published>2018-02-09T07:08:05.000Z</published>
    <updated>2018-02-11T01:04:21.113Z</updated>
    
    <content type="html"><![CDATA[<p>在Python的学习过程中，正则表达式始终是一道绕不过去的坎.无论提取服务器日志文件还是爬取网页，正则表达式始终扮演着至关重要的角色。下面便对自己学习过程中的一些正则表达式基础做一个总结。<br><a id="more"></a></p><h2 id="特殊符号和字符"><a href="#特殊符号和字符" class="headerlink" title="特殊符号和字符"></a>特殊符号和字符</h2><table><thead><tr><th style="text-align:center">表示法</th><th style="text-align:center">描述</th><th style="text-align:center">正则表达式示例</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">符号</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">literal</td><td style="text-align:center">匹配文本字符串的字面值literal</td><td style="text-align:center">foo</td><td style="text-align:center">只是匹配foo，相当于取等</td></tr><tr><td style="text-align:center">re1&#124; re2</td><td style="text-align:center">匹配正则表达式re1或re2</td><td style="text-align:center">foo&#124; bar</td><td style="text-align:center">匹配foo或者bar，二选一</td></tr><tr><td style="text-align:center">.</td><td style="text-align:center">匹配任何字符(除了\n之外)</td><td style="text-align:center">a.a</td><td style="text-align:center">匹配axa、aaa、aca等，两个a中间可以是除了\n的任意字符</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">匹配字符串起始部分</td><td style="text-align:center">^Foo</td><td style="text-align:center">匹配Foo，不匹配aFoo</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">匹配字符串终止部分</td><td style="text-align:center">Bar$</td><td style="text-align:center">只匹配Bar,不匹配aBar等</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">匹配0次或者多次前面出现的正则表达式</td><td style="text-align:center">[A-Za-z0-9]*</td><td style="text-align:center">匹配任意多个字母或数字</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">匹配1次或者多次前面出现的正则表达式</td><td style="text-align:center">[A-Za-z0-9]+</td><td style="text-align:center">匹配一到多个个字母或数字</td></tr><tr><td style="text-align:center">?</td><td style="text-align:center">匹配0次或者1次前面出现的正则表达式</td><td style="text-align:center">[A-Za-z0-9]</td><td style="text-align:center">要么有一个字母或数字要么没有</td></tr><tr><td style="text-align:center">{N}</td><td style="text-align:center">匹配N次前面出现的正则表达式</td><td style="text-align:center">[0-9]{3}</td><td style="text-align:center">匹配三个数字</td></tr><tr><td style="text-align:center">{M,N}</td><td style="text-align:center">匹配M~N次前面出现的正则表达式</td><td style="text-align:center">[0-9]{5,9}</td><td style="text-align:center">匹配5到9个数字(包括5个和9个)</td></tr><tr><td style="text-align:center">[…]</td><td style="text-align:center">匹配来自字符集的任意单一字符</td><td style="text-align:center">[aeiou]</td><td style="text-align:center">匹配一个元音字母</td></tr><tr><td style="text-align:center">[..x~y..]</td><td style="text-align:center">匹配x~y范围内的任意单一字符</td><td style="text-align:center">[A-Za-z]</td><td style="text-align:center">匹配任意一个英文字母</td></tr><tr><td style="text-align:center">[^…]</td><td style="text-align:center">不匹配此字符集中出现的任何一个字符，包括某一范围的字符(如果在此字符集中出现)</td><td style="text-align:center">[\^aeiou][\^A-Za-z0-9]</td><td style="text-align:center">匹配一个非元音字母和一个非字母数字字符</td></tr><tr><td style="text-align:center">(*&#124;+&#124;?&#124;{})?</td><td style="text-align:center">用于匹配上面频繁出现/重复出现符号的非贪婪版本(*、+、?、{})</td><td style="text-align:center">.*?[a-z]</td><td style="text-align:center">(非贪婪是指尽可能少的匹配)</td></tr><tr><td style="text-align:center">(…)</td><td style="text-align:center">匹配封闭的正则表达式,然后另存为子组</td><td style="text-align:center">f(oo&#124; u)bar</td><td style="text-align:center">匹配foobar,fubar</td></tr><tr><td style="text-align:center">特殊字符</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">\d</td><td style="text-align:center">匹配任何十进制数字，与[0-9]一致(\D和\d相反，不匹配任何非数值型的数字)</td><td style="text-align:center">data\d+.txt</td><td style="text-align:center">匹配data1.txt、data12.txt</td></tr><tr><td style="text-align:center">\w</td><td style="text-align:center">匹配任何字母数字字符，与[A-Za-z0-9]相同(\W与之相反)</td><td style="text-align:center">[A-Za-z_]\w+</td><td style="text-align:center">匹配任意字母或_加一个或多个字母数字字符(asda,_asda)</td></tr><tr><td style="text-align:center">\s</td><td style="text-align:center">匹配任何空格字符，与[\n\t\r\v\f]相同(\S与之相反)</td><td style="text-align:center">of\sthe</td><td style="text-align:center">匹配of the (\n:换行符&#124;\t:水平制表符&#124;\r:回车&#124;\v:垂直制表符&#124;\f:换页符)</td></tr><tr><td style="text-align:center">\b</td><td style="text-align:center">匹配任何单词边界(\B与之相反)</td><td style="text-align:center">\bThe\b</td><td style="text-align:center">匹配of The a，不匹配ofThe a</td></tr><tr><td style="text-align:center">\N</td><td style="text-align:center">匹配已保存的子组N(与上面(…)配合使用)</td><td style="text-align:center">price:\16</td><td style="text-align:center">匹配price:和前面第16个子组的值</td></tr><tr><td style="text-align:center">\c</td><td style="text-align:center">逐字匹配任何特殊字符(即仅按字面意义匹配，不包含特殊含义，\为对特殊字符的转义表示)</td><td style="text-align:center">*</td><td style="text-align:center">匹配*</td></tr><tr><td style="text-align:center">\A(\Z)</td><td style="text-align:center">匹配字符串的起始(结束)(另见上面的^和$)</td><td style="text-align:center">\ADear</td><td style="text-align:center">匹配以Dear开头的</td></tr><tr><td style="text-align:center">扩展表示法</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">（?iLmsux）</td><td style="text-align:center">在正则表达式中嵌入一个或多个特殊”标记”参数(或者通过函数/方法)</td><td style="text-align:center">（?x）,(?im)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">(?:…)</td><td style="text-align:center">表示一个匹配不用保存的分组</td><td style="text-align:center">(?:\w+.)*</td><td style="text-align:center">匹配任意多个一个或多个字母数字字符与.的组合但不保存改分组</td></tr><tr><td style="text-align:center">(?P<name>…)</name></td><td style="text-align:center">像一个仅由name标识而不是数字ID标识的正则分组匹配</td><td style="text-align:center">(?P<data>)</data></td><td style="text-align:center">给匹配的分组命名为data</td></tr><tr><td style="text-align:center">(?P=name)</td><td style="text-align:center">在同一个字符串中匹配由(?P<name>)分组之前的文本</name></td><td style="text-align:center">(?P=data)</td><td style="text-align:center">匹配名字为data的串</td></tr><tr><td style="text-align:center">(?#…)</td><td style="text-align:center">表示注释，所有内容都被忽略</td><td style="text-align:center">(?#comment)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">(?=…)</td><td style="text-align:center">匹配条件是如果…出现在之后的位置，而不使用输入字符串；称作正向前视断言</td><td style="text-align:center">(?=.com)</td><td style="text-align:center">如果一个字符串后面跟着“.com”才做匹配操作，并不适用任何目标字符串</td></tr><tr><td style="text-align:center">(?!…)</td><td style="text-align:center">匹配条件是如果…不出现在之后的位置，而不使用输入字符串；称作负向前视断言</td><td style="text-align:center">(?!.net)</td><td style="text-align:center">如果一个字符串后面不是跟着“.net”，才做匹配操作</td></tr><tr><td style="text-align:center">(?&lt;=…)</td><td style="text-align:center">匹配条件是如果…出现在之前的位置，而不使用输入字符串；称作正向后视断言</td><td style="text-align:center">(?&lt;=800-)</td><td style="text-align:center">如果字符串之前为“800-”才做匹配，并不使用任何输入字符串</td></tr><tr><td style="text-align:center">(?&lt;!…)</td><td style="text-align:center">匹配条件是如果…不出现在之前的位置，而不使用输入字符串；称作负向后视断言</td><td style="text-align:center">(?&lt;!192\.168\.)</td><td style="text-align:center">如果一个字符串之前不是“192.168.”才做匹配，并不适用任何输入字符串</td></tr><tr><td style="text-align:center">(?(id/name)Y&#124;N</td><td style="text-align:center">如果分组所提供的id或name(名称)存在，就返回正则表达式的条件匹配Y，如果不存在，就返回N;N是可选项</td><td style="text-align:center">(?(1)y&#124;x)</td><td style="text-align:center">如果一个匹配组1(\1)存在就y匹配；否则，就与x匹配</td></tr></tbody></table><p>以上为正则表达式的一些基本的符号定义与用法，熟练掌握这些符号是写出高效表达式的基础。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Python的学习过程中，正则表达式始终是一道绕不过去的坎.无论提取服务器日志文件还是爬取网页，正则表达式始终扮演着至关重要的角色。下面便对自己学习过程中的一些正则表达式基础做一个总结。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://coldjune.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://coldjune.com/tags/Python/"/>
    
      <category term="正则表达式" scheme="http://coldjune.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
</feed>
