<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Stay Hungary</title>
  
  <subtitle>Programming is an art form</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://coldjune.com/"/>
  <updated>2018-02-26T07:51:08.777Z</updated>
  <id>http://coldjune.com/</id>
  
  <author>
    <name>邓小俊</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python多线程(一)</title>
    <link href="http://coldjune.com/2018/02/24/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%80/"/>
    <id>http://coldjune.com/2018/02/24/Python多线程-一/</id>
    <published>2018-02-24T08:13:37.000Z</published>
    <updated>2018-02-26T07:51:08.777Z</updated>
    
    <content type="html"><![CDATA[<p>多线程编程对于以下编程任务是非常理想的：</p><ul><li>本质上是异步的</li><li>需要多个并发活动</li><li>每个活动的处理顺序可能是不确定的(随机、不可预测的)<!--Mare-->使用多线程或者类似Queue的共享数据结构可以将一个串行程序规划成几个执行特定任务的线程</li><li>UserRequestThread: 负责读取客户端输入。程序将创建多个线程，每个客户端一个，客户端的请求将会被放入队列中</li><li>RequestProcessor: 该线程负责从队列中获取请求并进行处理，为第三个线程提供输出</li><li>ReplyThread: 负责向用户输出，将结果传回给用户，或者把数据写到本地文件系统或者数据库中</li></ul><h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><ul><li><p>进程</p><blockquote><p>计算机程序是储存在磁盘上的可执行二进制(或其他类型)的文件。<strong>进程</strong> （有时称为 <strong>重量级进程</strong>）则是一个执行中的程序。<br>  每一个进程都拥有自己的地址空间、内存、数据栈以及其他用于跟踪执行的辅助数据。操作系统管理其上的所有进程的执行，并为它们合理地分配时间。<br>进程可以通过 <strong>派生</strong>(fork或spawn)新的进程来执行任务,而进程之间的通信只能通过 <em>进程间通信(IPC)</em> 的方式共享信息</p></blockquote></li><li><p>线程</p><blockquote><p><strong>线程</strong>（有时称为 <strong>轻量级进程</strong>）共享相同的上下文。相当于在主进程中并行运行的一些“迷你进程”。当其他线程运行是，它可以被抢占（中断）<br>  和临时挂起（睡眠），这种做法叫 <em>让步(yielding)</em>。早单核CPU系统中，线程的实际规划是：每个线程运行一小会儿，然后让步给其他线程（再次排队<br>  等待更多的CPU时间）。在整个进程的执行当中，每个线程执行它自己特定的任务，在必要时和其他线程进行结果通信。</p></blockquote></li></ul><h2 id="线程与Python"><a href="#线程与Python" class="headerlink" title="线程与Python"></a>线程与Python</h2><h3 id="全局解释锁"><a href="#全局解释锁" class="headerlink" title="全局解释锁"></a>全局解释锁</h3><p>  对Python虚拟机的访问是由 <strong>全局解释锁(GIL)</strong> 控制的。这个锁用来保证同时只能有一个线程运行。在多线程环境中，Python虚拟机将按照下面的方式执行。</p><ol><li>设置GIL</li><li>切换进一个线程去运行</li><li>执行下面操作之一<br> a. 指定数量的字节码指令<br> b. 线程主动让出控制权(可以调用time.sleep(0)来完成)</li><li>把线程设置回睡眠状态(切换出线程)</li><li>解锁GIL</li><li><p>重复上述步骤</p><p>当调用外部代码(即，任意C/C++扩展的内置函数)时，GIL会保持锁定，直至函数执行结束。</p></li></ol><h3 id="退出线程"><a href="#退出线程" class="headerlink" title="退出线程"></a>退出线程</h3><p>  当一个线程完成函数的执行时，就会退出。还可以通过调用<code>thread.exit()</code>或者<code>sys.exit()</code>退出进程，或者抛出SystemExit异常，是线程退出。</p><h2 id="thread模块"><a href="#thread模块" class="headerlink" title="_thread模块"></a>_thread模块</h2><p>  <a href="https://docs.python.org/3/library/_thread.html?highlight=_thread#module-_thread" target="_blank" rel="noopener">_thread模块</a>提供了派生线程、基本的同步数据结构(<em>锁对象(lock object)</em>,也叫 <em>原语锁</em>、<em>简单锁</em>、<em>互斥锁</em>、<em>互斥</em> 和 <em>二进制信号量</em>)</p><ul><li>_thread模和锁对象</li></ul><table><thead><tr><th style="text-align:center">函数/方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">_thread模块的函数</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">start_new_thread(function, args, kwargs = None)</td><td style="text-align:center">派生一个新的线程，使用给定的args和可选的kwargs来执行function</td></tr><tr><td style="text-align:center">allocate_lock()</td><td style="text-align:center">分配LockType锁对象</td></tr><tr><td style="text-align:center">exit()</td><td style="text-align:center">给线程退出命令</td></tr><tr><td style="text-align:center">LockType锁对象的方法</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">acquire(wait = None)</td><td style="text-align:center">尝试获取锁对象</td></tr><tr><td style="text-align:center">locked()</td><td style="text-align:center">如果获取了锁对象则返回True，否则，返回False</td></tr><tr><td style="text-align:center">release()</td><td style="text-align:center">释放锁</td></tr></tbody></table><h3 id="使用线程"><a href="#使用线程" class="headerlink" title="使用线程"></a>使用线程</h3><h4 id="一般方式"><a href="#一般方式" class="headerlink" title="一般方式"></a>一般方式</h4><ul><li><p>程序</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding:UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> _thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime, sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_0</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'start loop_0 at:'</span>, ctime())</span><br><span class="line">    sleep(<span class="number">4</span>)</span><br><span class="line">    print(<span class="string">'loop_0 done at:'</span>, ctime())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'start loop_1 at:'</span>, ctime())</span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'loop_1 done at:'</span>, ctime())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'starting at:'</span>, ctime())</span><br><span class="line">    <span class="comment"># start_new_thread 方法即使要执行的</span></span><br><span class="line">    <span class="comment"># 函数不需要参数，也需要传递一个空元组</span></span><br><span class="line">    _thread.start_new_thread(loop_0, ())</span><br><span class="line">    _thread.start_new_thread(loop_1, ())</span><br><span class="line">    <span class="comment"># 阻止主线程的执行，保证其最后执行，</span></span><br><span class="line">    <span class="comment"># 后续去掉这种方式，引入锁的方式</span></span><br><span class="line">    sleep(<span class="number">6</span>)</span><br><span class="line">    print(<span class="string">'all done at'</span>, ctime())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li><li><p>执行结果</p><p>  在主线程中同时开启了两个线程，loop_1()由于只睡眠了2s，所以先执行完，其实执行完loo_0()，线程执行的总时间是最慢的那个线程(<em>loop_0()</em> )<br>  的运行时间</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">starting at: Mon Feb 26 08:52:10 2018</span><br><span class="line">start loop_0 at: Mon Feb 26 08:52:10 2018</span><br><span class="line">start loop_1 at: Mon Feb 26 08:52:10 2018</span><br><span class="line">loop_1 done at: Mon Feb 26 08:52:12 2018</span><br><span class="line">loop_0 done at: Mon Feb 26 08:52:14 2018</span><br><span class="line">all done at Mon Feb 26 08:52:16 2018</span><br></pre></td></tr></table></figure></li></ul><h4 id="使用锁对象"><a href="#使用锁对象" class="headerlink" title="使用锁对象"></a>使用锁对象</h4><ul><li><p>程序</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding:UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> _thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime, sleep</span><br><span class="line"></span><br><span class="line">loops = [<span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">(nloop, sec, lock)</span>:</span></span><br><span class="line">    <span class="comment"># nloop: 第几个线程</span></span><br><span class="line">    <span class="comment"># sec: 时间</span></span><br><span class="line">    <span class="comment"># lock: 分配的锁</span></span><br><span class="line">    print(<span class="string">'start loop'</span>, nloop, <span class="string">'at:'</span>, ctime())</span><br><span class="line">    sleep(sec)</span><br><span class="line">    print(<span class="string">'loop'</span>, nloop, <span class="string">'done at:'</span>, ctime())</span><br><span class="line">    <span class="comment"># 当时间到了的时候释放锁</span></span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'starting at:'</span>, ctime())</span><br><span class="line">    locks = []</span><br><span class="line">    nloops = range(len(loops))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nloops:</span><br><span class="line">        <span class="comment"># 生成锁对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 通过allocate_lock()函数得到锁对象</span></span><br><span class="line">        <span class="comment"># 通过acquire()取到每个锁</span></span><br><span class="line">        <span class="comment"># 添加进locks列表</span></span><br><span class="line">        lock = _thread.allocate_lock()</span><br><span class="line">        lock.acquire()</span><br><span class="line">        locks.append(lock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nloops:</span><br><span class="line">        <span class="comment"># 派生线程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 传递循环号，时间、锁对象</span></span><br><span class="line">        _thread.start_new_thread(loop, (i, loops[i], locks[i]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nloops:</span><br><span class="line">        <span class="comment"># 等待所有线程的锁都释放完了才执行主线程</span></span><br><span class="line">        <span class="keyword">while</span> locks[i].locked():</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">'all DONE at:'</span>, ctime())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li><li><p>执行结果</p><p>  未再设置时间等待所有线程执行结束，而是在线程全部结束后马上运行主线程代码</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">starting at: Mon Feb 26 09:37:39 2018</span><br><span class="line">start loop 1 at: Mon Feb 26 09:37:39 2018</span><br><span class="line">start loop 0 at: Mon Feb 26 09:37:39 2018</span><br><span class="line">loop 1 done at: Mon Feb 26 09:37:41 2018</span><br><span class="line">loop 0 done at: Mon Feb 26 09:37:43 2018</span><br><span class="line">all DONE at: Mon Feb 26 09:37:43 2018</span><br></pre></td></tr></table></figure></li></ul><h2 id="threading模块"><a href="#threading模块" class="headerlink" title="threading模块"></a>threading模块</h2><p><a href="https://docs.python.org/3/library/threading.html?highlight=threading#module-threading" target="_blank" rel="noopener">threading模块</a>提供了更高级别、功能更全面的线程管理,还包括许多非常好用的同步机制</p><ul><li>threading模块的对象</li></ul><table><thead><tr><th style="text-align:center">对象</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">Thread</td><td style="text-align:center">表示一个执行线程的对象</td></tr><tr><td style="text-align:center">Lock</td><td style="text-align:center">锁原语对象(和thread模块中的锁一样)</td></tr><tr><td style="text-align:center">RLock</td><td style="text-align:center">可重入锁对象，使单一线程可以（再次）获得已持有的锁（锁递归）</td></tr><tr><td style="text-align:center">Condition</td><td style="text-align:center">条件变量对象，使得一个线程等待另一个线程满足特定的“条件”，比如改变状态或某个数据值</td></tr><tr><td style="text-align:center">Event</td><td style="text-align:center">条件变量的通用版本，任何数量的线程等待某个事件的发生，在改事件发生后所有线程将被激活</td></tr><tr><td style="text-align:center">Semaphone</td><td style="text-align:center">为线程间共享的有限资源提供一个“计数器”，如果没有可用资源时会被阻塞</td></tr><tr><td style="text-align:center">BoundSemaphone</td><td style="text-align:center">与Semaphone相似，不过它不允许超过初始值</td></tr><tr><td style="text-align:center">Timer</td><td style="text-align:center">与Thread相似，不过它要在运行前等待一段时间</td></tr><tr><td style="text-align:center">Barrier</td><td style="text-align:center">创建一个“障碍”,必须达到指定数量的线程后才可以继续</td></tr></tbody></table><h3 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h3><ul><li>Thread对象的属性和方法</li></ul><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">name</td><td style="text-align:center">线程名</td></tr><tr><td style="text-align:center">ident</td><td style="text-align:center">线程的标识符</td></tr><tr><td style="text-align:center">daemon</td><td style="text-align:center">布尔标志，表示这个线程是否是守护线程</td></tr><tr><td style="text-align:center">Thread对象方法</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><em>init</em>(group=None, target=None, name=None, args=(), kwargs={}, verbose=None, daemon=就返回None)</td><td style="text-align:center">实例化一个线程对象，需要一个可调用的target，以及参数args或kargs。还可以传递name或group参数。daemon的值将会设定thread.daemon属性/标志</td></tr><tr><td style="text-align:center">start()</td><td style="text-align:center">开始执行该线程</td></tr><tr><td style="text-align:center">run()</td><td style="text-align:center">定义线程功能的方法(通常在子类中被应用开发者重写)</td></tr><tr><td style="text-align:center">join(timeout=None)</td><td style="text-align:center">直至启动的线程终止之前一直挂起；除非给出了timeout(秒)，否则会一直阻塞</td></tr></tbody></table><p>使用Thread类，可以有很多方法创建线程。其中比较相似的三种方法是：</p><ul><li>创建Thread的实例，传给它一个函数</li><li>创建Thread的实例，传给它一个可调用的类实例</li><li>派生Thread的子类，并创建子类的实例</li></ul><h4 id="创建Thread的实例，传给它一个函数"><a href="#创建Thread的实例，传给它一个函数" class="headerlink" title="创建Thread的实例，传给它一个函数"></a>创建Thread的实例，传给它一个函数</h4><p><code>join()</code> 方法可以让主线程等待所有线程执行完毕，或者在提供了超时时间的情况下达到超时时间。<code>join()</code>方法只有在需要等待线程完成的时候才是有用的。</p><ul><li>代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding:UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime, sleep</span><br><span class="line"></span><br><span class="line">loops = [<span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">(nloop, sec)</span>:</span></span><br><span class="line">    print(<span class="string">'start loop'</span>, nloop, <span class="string">'at:'</span>, ctime())</span><br><span class="line">    sleep(sec)</span><br><span class="line">    print(<span class="string">'loop'</span>, nloop, <span class="string">'done at:'</span>, ctime())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'starting at:'</span>, ctime())</span><br><span class="line">    threads = []</span><br><span class="line">    nloops = range(len(loops))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nloops:</span><br><span class="line">        t = threading.Thread(target=loop, args=(i, loops[i]))</span><br><span class="line">        threads.append(t)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nloops:</span><br><span class="line">        <span class="comment"># 启动线程</span></span><br><span class="line">        threads[i].start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nloops:</span><br><span class="line">        <span class="comment"># 等待所有线程结束</span></span><br><span class="line">        threads[i].join()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'all DONE at:'</span>, ctime())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><ul><li>结果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">starting at: Mon Feb 26 14:29:36 2018</span><br><span class="line">start loop 0 at: Mon Feb 26 14:29:36 2018</span><br><span class="line">start loop 1 at: Mon Feb 26 14:29:36 2018</span><br><span class="line">loop 1 done at: Mon Feb 26 14:29:38 2018</span><br><span class="line">loop 0 done at: Mon Feb 26 14:29:40 2018</span><br><span class="line">all DONE at: Mon Feb 26 14:29:40 2018</span><br></pre></td></tr></table></figure><h4 id="创建Thread的实例，传给它一个可调用的类实例"><a href="#创建Thread的实例，传给它一个可调用的类实例" class="headerlink" title="创建Thread的实例，传给它一个可调用的类实例"></a>创建Thread的实例，传给它一个可调用的类实例</h4><p>将传递进去一个可调用类(实例)而不仅仅是一个函数</p><ul><li>代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding:UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime, sleep</span><br><span class="line"></span><br><span class="line">loops = [<span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadFunc</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, args, name=<span class="string">''</span>)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.func = func</span><br><span class="line">        self.args = args</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Thread类的代码将调用ThreadFunc对象，此时会调用这个方法</span></span><br><span class="line">        <span class="comment"># 因为init方法已经设定相关值，所以不需要再将其传递给Thread()的构造函数</span></span><br><span class="line">        self.func(*self.args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">(nloop, sec)</span>:</span></span><br><span class="line">    print(<span class="string">'start loop'</span>, nloop, <span class="string">'at:'</span>, ctime())</span><br><span class="line">    sleep(sec)</span><br><span class="line">    print(<span class="string">'loop '</span>, nloop, <span class="string">'done at:'</span>, ctime())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'starting at:'</span>, ctime())</span><br><span class="line">    threads = []</span><br><span class="line">    nloops = range(len(loops))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nloops:</span><br><span class="line">        <span class="comment"># 创建所有线程</span></span><br><span class="line">        t = threading.Thread(target=ThreadFunc(loop, (i, loops[i])))</span><br><span class="line">        threads.append(t)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nloops:</span><br><span class="line">        threads[i].start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nloops:</span><br><span class="line">        <span class="comment"># 等待所有线程</span></span><br><span class="line">        threads[i].join()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'all DONE at:'</span>, ctime())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><ul><li>结果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">starting at: Mon Feb 26 14:47:28 2018</span><br><span class="line">start loop 0 at: Mon Feb 26 14:47:28 2018</span><br><span class="line">start loop 1 at: Mon Feb 26 14:47:28 2018</span><br><span class="line">loop  1 done at: Mon Feb 26 14:47:30 2018</span><br><span class="line">loop  0 done at: Mon Feb 26 14:47:32 2018</span><br><span class="line">all DONE at: Mon Feb 26 14:47:32 2018</span><br></pre></td></tr></table></figure><h4 id="派生Thread的子类，并创建子类的实例-推荐"><a href="#派生Thread的子类，并创建子类的实例-推荐" class="headerlink" title="派生Thread的子类，并创建子类的实例(推荐)"></a>派生Thread的子类，并创建子类的实例(推荐)</h4><p>将Thread子类化，而不是直接对其实例化。这将在定制线程对象的时候拥有更多的灵活性，也能简化线程创建的调用过程</p><ul><li>代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding:UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime, sleep</span><br><span class="line">loops = [<span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, args, name=<span class="string">''</span>)</span>:</span></span><br><span class="line">        <span class="comment"># 必须先调用基类的构造函数</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.name = name</span><br><span class="line">        self.func = func</span><br><span class="line">        self.args = args</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 必须重写run()方法</span></span><br><span class="line">        self.func(*self.args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">(nloop, sec)</span>:</span></span><br><span class="line">    print(<span class="string">'start loop'</span>, nloop, <span class="string">'at:'</span>, ctime())</span><br><span class="line">    sleep(sec)</span><br><span class="line">    print(<span class="string">'loop '</span>, nloop, <span class="string">'done at:'</span>, ctime())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'starting at:'</span>, ctime())</span><br><span class="line">    threads = []</span><br><span class="line">    nloops = range(len(loops))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nloops:</span><br><span class="line">        <span class="comment"># 创建所有线程</span></span><br><span class="line">        t = MyThread(loop, (i, loops[i]), loop.__name__)</span><br><span class="line">        threads.append(t)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nloops:</span><br><span class="line">        threads[i].start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nloops:</span><br><span class="line">        <span class="comment"># 等待所有线程</span></span><br><span class="line">        threads[i].join()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'all DONE at:'</span>, ctime())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><ul><li>结果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">starting at: Mon Feb 26 15:08:33 2018</span><br><span class="line">start loop 0 at: Mon Feb 26 15:08:33 2018</span><br><span class="line">start loop 1 at: Mon Feb 26 15:08:33 2018</span><br><span class="line">loop  1 done at: Mon Feb 26 15:08:35 2018</span><br><span class="line">loop  0 done at: Mon Feb 26 15:08:37 2018</span><br><span class="line">all DONE at: Mon Feb 26 15:08:37 2018</span><br></pre></td></tr></table></figure><h2 id="单线程和多线程执行的对比"><a href="#单线程和多线程执行的对比" class="headerlink" title="单线程和多线程执行的对比"></a>单线程和多线程执行的对比</h2><p>先后使用单线程和多线程执行三个独立的递归函数，代码中加入<code>sleep()</code>是为了减慢执行速度，能够更好的看到效果。</p><ul><li>myThread.py</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding:UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime, sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, args, name=<span class="string">''</span>)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.name = name</span><br><span class="line">        self.func = func</span><br><span class="line">        self.args = args</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_result</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 返回每一次的执行结果</span></span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'starting at:'</span>, ctime())</span><br><span class="line">        self.res = self.func(*self.args)</span><br><span class="line">        print(<span class="string">'done at:'</span>, ctime())</span><br></pre></td></tr></table></figure><ul><li>compare.py</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding:UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> myThread <span class="keyword">import</span> MyThread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime, sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="comment"># 斐波拉契</span></span><br><span class="line">    sleep(<span class="number">0.005</span>)</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fib(x<span class="number">-2</span>)+fib(x<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fac</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="comment"># 阶乘</span></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x*fac(x<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="comment"># 累加</span></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x + sum(x<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">funcs = [fib, fac, sum]</span><br><span class="line">n = <span class="number">12</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    nfuncs = range(len(funcs))</span><br><span class="line">    print(<span class="string">'***SINGLE THREAD***'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nfuncs:</span><br><span class="line">        <span class="comment"># 单线程顺序执行</span></span><br><span class="line">        print(<span class="string">'starting'</span>, funcs[i].__name__, <span class="string">'at:'</span>, ctime())</span><br><span class="line">        print(funcs[i](n))</span><br><span class="line">        print(funcs[i].__name__, <span class="string">'finished at:'</span>, ctime(), <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'\n ***MULTIPLE THREADS***'</span>)</span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nfuncs:</span><br><span class="line">        <span class="comment"># 多线程执行</span></span><br><span class="line">        t = MyThread(funcs[i], (n,),funcs[i].__name__)</span><br><span class="line">        threads.append(t)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nfuncs:</span><br><span class="line">        threads[i].start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nfuncs:</span><br><span class="line">        threads[i].join()</span><br><span class="line">        print(threads[i].get_result())</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'all DONE'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><ul><li>结果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">***SINGLE THREAD***</span><br><span class="line">starting fib at: Mon Feb 26 15:36:22 2018</span><br><span class="line">233</span><br><span class="line">fib finished at: Mon Feb 26 15:36:24 2018</span><br><span class="line"></span><br><span class="line">starting fac at: Mon Feb 26 15:36:24 2018</span><br><span class="line">479001600</span><br><span class="line">fac finished at: Mon Feb 26 15:36:25 2018</span><br><span class="line"></span><br><span class="line">starting sum at: Mon Feb 26 15:36:25 2018</span><br><span class="line">78</span><br><span class="line">sum finished at: Mon Feb 26 15:36:26 2018</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> ***MULTIPLE THREADS***</span><br><span class="line">starting at: Mon Feb 26 15:36:26 2018</span><br><span class="line">starting at: Mon Feb 26 15:36:26 2018</span><br><span class="line">starting at: Mon Feb 26 15:36:26 2018</span><br><span class="line">done at: Mon Feb 26 15:36:28 2018</span><br><span class="line">done at: Mon Feb 26 15:36:28 2018</span><br><span class="line">done at: Mon Feb 26 15:36:29 2018</span><br><span class="line">233</span><br><span class="line">479001600</span><br><span class="line">78</span><br><span class="line">all DONE</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;多线程编程对于以下编程任务是非常理想的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本质上是异步的&lt;/li&gt;
&lt;li&gt;需要多个并发活动&lt;/li&gt;
&lt;li&gt;每个活动的处理顺序可能是不确定的(随机、不可预测的)&lt;!--Mare--&gt;
使用多线程或者类似Queue的共享数据结构可以将一个串行程序
      
    
    </summary>
    
      <category term="Python" scheme="http://coldjune.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://coldjune.com/tags/Python/"/>
    
      <category term="多线程" scheme="http://coldjune.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python网络编程(二)</title>
    <link href="http://coldjune.com/2018/02/24/Python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E4%BA%8C/"/>
    <id>http://coldjune.com/2018/02/24/Python网络编程-二/</id>
    <published>2018-02-24T01:40:06.000Z</published>
    <updated>2018-02-24T08:13:04.925Z</updated>
    
    <content type="html"><![CDATA[<p>上篇对Python中的socket模块的简单应用做了描述和记录，下面便是对SocketServer模块和Twisted框架做一个简要的记录<br><a id="more"></a></p><h2 id="socketserver模块"><a href="#socketserver模块" class="headerlink" title="socketserver模块"></a>socketserver模块</h2><p><a href="https://docs.python.org/3/library/socketserver.html?highlight=socketserver#module-socketserver" target="_blank" rel="noopener">socketserver</a>是标准库的一个高级模块，它的目标是简化很多样板代码，它们是创建网络客户端和服务器所必需的代码。</p><h3 id="socketserver模块类"><a href="#socketserver模块类" class="headerlink" title="socketserver模块类"></a>socketserver模块类</h3><table><thead><tr><th style="text-align:center">类</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">BaseServer</td><td style="text-align:center">包含核心服务器功能和mix-in类的钩子；仅用于推导，这样不会创建这个类的实例；可以用TCPServer或UDPServer创建类的实例</td></tr><tr><td style="text-align:center">TCPServer/UDPServer</td><td style="text-align:center">基础的网络同步TCP/UDP服务器</td></tr><tr><td style="text-align:center">UnixStreamServer/UnixDatagramServer</td><td style="text-align:center">基于文件的基础同步TCP/UDP服务器</td></tr><tr><td style="text-align:center">ForkingMixIn/ThreadingMixIn</td><td style="text-align:center">核心派出或线程功能；只用作mix-in类与一个服务器类配合实现一些异步性；不能直接实例化这个类</td></tr><tr><td style="text-align:center">ForkingTCPServer/ForkingUDPServer</td><td style="text-align:center">ForkingMaxIn和TCPServer/UDPServer的组合</td></tr><tr><td style="text-align:center">ThreadingTCPServer/ThreadingUDPServer</td><td style="text-align:center">ThreadingMixIn和TCPServer/UDPServer的组合</td></tr><tr><td style="text-align:center">BaseRequestHandler</td><td style="text-align:center">包含处理服务请求的核心功能；仅用于推导，无法创建这个类的实例；可以使用StreamRequestHandler或DatagramRequestHandler创建类的实例</td></tr><tr><td style="text-align:center">StreamRequestHandler/DatagramRequestHandler</td><td style="text-align:center">实现TCP/UDP服务器的服务处理器</td></tr></tbody></table><h3 id="socketserver-TCP服务器-客户端"><a href="#socketserver-TCP服务器-客户端" class="headerlink" title="socketserver TCP服务器/客户端"></a>socketserver TCP服务器/客户端</h3><p>在原始服务器循环中，我们阻塞等待请求，当接收到请求时就对其提供服务，然后继续等待。在此处的服务器循环中，并非在服务器中创建代码，而是定义一个处理程序，当服务器接收到一个传入的请求时，服务器就可以调用</p><h4 id="TCP服务器"><a href="#TCP服务器" class="headerlink" title="TCP服务器"></a>TCP服务器</h4>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding:UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入socketserver相关的类和time.ctime()的全部属性</span></span><br><span class="line"><span class="keyword">from</span> socketserver <span class="keyword">import</span> (TCPServer <span class="keyword">as</span> TCP,</span><br><span class="line">                          StreamRequestHandler <span class="keyword">as</span> SRH)</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">''</span></span><br><span class="line">PORT = <span class="number">12345</span></span><br><span class="line">ADDR = (HOST, PORT)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRequestHandler</span><span class="params">(SRH)</span>:</span></span><br><span class="line">    <span class="comment"># MyRequestHandler继承自StreamRequestHandler</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 重写handle方法，当接收到一个客户端消息是，会调用handle()方法</span></span><br><span class="line">        print(<span class="string">'...connected from:'</span>, self.client_address)</span><br><span class="line">        <span class="comment"># StreamRequestHandler将输入和输出套接字看做类似文件的对象</span></span><br><span class="line">        <span class="comment"># 所以使用write()将字符串返回客户端，用readline()来获取客户端信息</span></span><br><span class="line">        self.wfile.write(bytes(<span class="string">'[%s] %s'</span> % (</span><br><span class="line">            ctime(), self.rfile.readline().decode(<span class="string">'utf-8'</span>)), <span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用给定的主机信息和请求处理类创建了TCP服务器</span></span><br><span class="line"><span class="comment"># 然后无限循环地等待并服务于客户端请求</span></span><br><span class="line">tcpServ = TCP(ADDR, MyRequestHandler)</span><br><span class="line">print(<span class="string">'waiting for connection...'</span>)</span><br><span class="line">tcpServ.serve_forever()</span><br></pre></td></tr></table></figure><h4 id="TCP客户端"><a href="#TCP客户端" class="headerlink" title="TCP客户端"></a>TCP客户端</h4>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding:UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line">PORT = <span class="number">12345</span></span><br><span class="line">BUFSIZE = <span class="number">1024</span></span><br><span class="line">ADDR = (HOST, PORT)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    tcpSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    tcpSocket.connect(ADDR)</span><br><span class="line">    data = input(<span class="string">'&gt; '</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 因为处理程序类对待套接字通信像文件一样，所以必须发送行终止符。</span></span><br><span class="line">    <span class="comment"># 而服务器只是保留并重用这里发送的终止符</span></span><br><span class="line">    tcpSocket.send(bytes(<span class="string">'%s\r\n'</span> % data, <span class="string">'utf-8'</span>))</span><br><span class="line">    data = tcpSocket.recv(BUFSIZE)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 得到服务器返回的消息时，用strip()函数对其进行处理并使用print()自动提供的换行符</span></span><br><span class="line">    print(data.decode(<span class="string">'utf-8'</span>).strip())</span><br><span class="line">    tcpSocket.close()</span><br></pre></td></tr></table></figure><h4 id="socketserver-TCP服务器和客户端运行结果"><a href="#socketserver-TCP服务器和客户端运行结果" class="headerlink" title="socketserver TCP服务器和客户端运行结果"></a>socketserver TCP服务器和客户端运行结果</h4><p>  在客户端启动的时候连接了一次服务器，而每一次发送一个请求连接一次，所以发送了三个请求连接了四次服务器</p><ul><li><p>TCP服务器运行结果</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">waiting for connection...</span><br><span class="line">...connected from: (&apos;127.0.0.1&apos;, 51835)</span><br><span class="line">...connected from: (&apos;127.0.0.1&apos;, 51877)</span><br><span class="line">...connected from: (&apos;127.0.0.1&apos;, 51893)</span><br><span class="line">...connected from: (&apos;127.0.0.1&apos;, 51901)</span><br></pre></td></tr></table></figure></li><li><p>TCP客户端运行结果</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; hello</span><br><span class="line">[Sat Feb 24 10:29:28 2018] hello</span><br><span class="line">&gt; hello</span><br><span class="line">[Sat Feb 24 10:29:44 2018] hello</span><br><span class="line">&gt; hi</span><br><span class="line">[Sat Feb 24 10:29:50 2018] hi</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Twisted框架的简单使用"><a href="#Twisted框架的简单使用" class="headerlink" title="Twisted框架的简单使用"></a>Twisted框架的简单使用</h2><p>  Twisted是一个完整的事件驱动的网络框架，利用它既能使用也能开发完整的异步网络应用程序和协议。它不是Python标准库的一部分，所以需要单独<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted" target="_blank" rel="noopener">下载</a>和安装它<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install Twisted-17.9.0-cp36-cp36m-win_amd64.whl</span><br></pre></td></tr></table></figure></p><p>  安装成功显示<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Processing e:\迅雷下载\twisted-17.9.0-cp36-cp36m-win_amd64.whl</span><br><span class="line">Requirement already satisfied: Automat&gt;=0.3.0 in e:\python\python36\lib\site-packages (from Twisted==17.9.0)</span><br><span class="line">Requirement already satisfied: zope.interface&gt;=4.0.2 in e:\python\python36\lib\site-packages (from Twisted==17.9.0)</span><br><span class="line">Requirement already satisfied: incremental&gt;=16.10.1 in e:\python\python36\lib\site-packages (from Twisted==17.9.0)</span><br><span class="line">Requirement already satisfied: hyperlink&gt;=17.1.1 in e:\python\python36\lib\site-packages (from Twisted==17.9.0)</span><br><span class="line">Requirement already satisfied: constantly&gt;=15.1 in e:\python\python36\lib\site-packages (from Twisted==17.9.0)</span><br><span class="line">Requirement already satisfied: attrs in e:\python\python36\lib\site-packages (from Automat&gt;=0.3.0-&gt;Twisted==17.9.0)</span><br><span class="line">Requirement already satisfied: six in e:\python\python36\lib\site-packages (from Automat&gt;=0.3.0-&gt;Twisted==17.9.0)</span><br><span class="line">Requirement already satisfied: setuptools in e:\python\python36\lib\site-packages (from zope.interface&gt;=4.0.2-&gt;Twisted==17.9.0)</span><br><span class="line">Installing collected packages: Twisted</span><br><span class="line">Successfully installed Twisted-17.9.0</span><br></pre></td></tr></table></figure></p><h3 id="Twisted-Reactor-TCP-服务器-客户端"><a href="#Twisted-Reactor-TCP-服务器-客户端" class="headerlink" title="Twisted Reactor TCP 服务器/客户端"></a>Twisted Reactor TCP 服务器/客户端</h3><h4 id="TCP服务器-1"><a href="#TCP服务器-1" class="headerlink" title="TCP服务器"></a>TCP服务器</h4>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding:UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 常用模块导入，特别是twisted.internet的protocol和reactor</span></span><br><span class="line"><span class="keyword">from</span> twisted.internet <span class="keyword">import</span> protocol, reactor</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置端口号</span></span><br><span class="line">PORT = <span class="number">12345</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TWServProtocol</span><span class="params">(protocol.Protocol)</span>:</span></span><br><span class="line">    <span class="comment"># 继承Protocol类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connectionMade</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 重写connectionMade()方法</span></span><br><span class="line">        <span class="comment"># 当一个客户端连接到服务器是会执行这个方法</span></span><br><span class="line">        client = self.client = self.transport.getPeer().host</span><br><span class="line">        print(<span class="string">'...connected from:'</span>, client)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dataReceived</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="comment"># 重写dataReceived()方法</span></span><br><span class="line">        <span class="comment"># 当服务器接收到客户端通过网络发送的一些数据的时候会调用此方法</span></span><br><span class="line">        self.transport.write(bytes(<span class="string">'[%s] %s'</span> % (</span><br><span class="line">            ctime(), data.decode(<span class="string">'utf-8'</span>)), <span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个协议工厂，每次得到一个接入连接是，制造协议的一个实例</span></span><br><span class="line"><span class="comment"># 在reactor中安装一个TCP监听器，以此检查服务请求</span></span><br><span class="line"><span class="comment"># 当接收到一个请求时，就是创建一个就是创建一个TWServProtocol实例来处理客户端事务</span></span><br><span class="line">factory = protocol.Factory()</span><br><span class="line">factory.protocol = TWServProtocol</span><br><span class="line">print(<span class="string">'waiting for connection...'</span>)</span><br><span class="line">reactor.listenTCP(PORT, factory)</span><br><span class="line">reactor.run()</span><br></pre></td></tr></table></figure><h4 id="TCP客户端-1"><a href="#TCP客户端-1" class="headerlink" title="TCP客户端"></a>TCP客户端</h4>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding:UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> twisted.internet <span class="keyword">import</span>  protocol, reactor</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line">PORT = <span class="number">12345</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TWClientProtocol</span><span class="params">(protocol.Protocol)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sendData</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 需要发送数据时调用</span></span><br><span class="line">        <span class="comment"># 会在一个循环中继续，直到不输入任何内容来关闭连接</span></span><br><span class="line">        data = input(<span class="string">'&gt; '</span>)</span><br><span class="line">        <span class="keyword">if</span> data:</span><br><span class="line">            print(<span class="string">'...send %s...'</span> % data)</span><br><span class="line">            self.transport.write(bytes(data, <span class="string">'utf-8'</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.transport.loseConnection()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connectionMade</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        self.sendData()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dataReceived</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        print(data.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">        self.sendData()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TWClientFactory</span><span class="params">(protocol.ClientFactory)</span>:</span></span><br><span class="line">    <span class="comment"># 创建了一个客户端工厂</span></span><br><span class="line">    protocol = TWClientProtocol</span><br><span class="line">    clientConnectionLost = clientConnectionFailed = \</span><br><span class="line">        <span class="keyword">lambda</span> self, connector, reason: reactor.stop()</span><br><span class="line"><span class="comment"># 创建了一个到服务器的连接并运行reactor，实例化了客户端工厂</span></span><br><span class="line"><span class="comment"># 因为这里不是服务器，需要等待客户端与我们通信</span></span><br><span class="line"><span class="comment"># 并且这个工厂为每一次连接都创建一个新的协议对象。</span></span><br><span class="line"><span class="comment"># 客户端创建单个连接到服务器的协议对象，而服务器的工厂则创建一个来与客户端通信</span></span><br><span class="line">reactor.connectTCP(HOST, PORT, TWClientFactory())</span><br><span class="line">reactor.run()</span><br></pre></td></tr></table></figure><h4 id="TCP服务器和客户端运行结果"><a href="#TCP服务器和客户端运行结果" class="headerlink" title="TCP服务器和客户端运行结果"></a>TCP服务器和客户端运行结果</h4><ul><li><p>服务器结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">waiting for connection...</span><br><span class="line">...connected from: 127.0.0.1</span><br></pre></td></tr></table></figure></li><li><p>客户端结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; hello</span><br><span class="line">...send hello...</span><br><span class="line">[Sat Feb 24 11:19:49 2018] hello</span><br><span class="line">&gt; hi</span><br><span class="line">...send hi...</span><br><span class="line">[Sat Feb 24 11:20:02 2018] hi</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">需要安装python对应的版本和位数</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇对Python中的socket模块的简单应用做了描述和记录，下面便是对SocketServer模块和Twisted框架做一个简要的记录&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://coldjune.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://coldjune.com/tags/Python/"/>
    
      <category term="网络编程" scheme="http://coldjune.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python网络编程(一)</title>
    <link href="http://coldjune.com/2018/02/22/Python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E4%B8%80/"/>
    <id>http://coldjune.com/2018/02/22/Python网络编程-一/</id>
    <published>2018-02-22T07:53:42.000Z</published>
    <updated>2018-02-26T00:30:48.048Z</updated>
    
    <content type="html"><![CDATA[<p>使用Python的一些模块来创建网络应用程序<br><a id="more"></a></p><h2 id="socket-函数模块"><a href="#socket-函数模块" class="headerlink" title="socket()函数模块"></a>socket()函数模块</h2><p>要创建套接字，必须使用<code>socket.socket()</code>函数<code>socket(socket_family, socket_type, protocol = 0)</code>,其中<code>socket_family</code>是 <em>AF_UNIX</em>或 <em>AF_INET</em>,<code>socket_type</code>是 <em>SOCK_STREAM</em> 或 <em>SOCK_DGRAM</em>。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup><code>protocol</code>通常省略，默认为0。</p><ul><li><blockquote><p>创建TCP/IP套接字</p></blockquote>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br></pre></td></tr></table></figure></li><li><blockquote><p>创建UDP/IP套接字</p></blockquote>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udpSock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br></pre></td></tr></table></figure></li></ul><h3 id="套接字对象内接方法"><a href="#套接字对象内接方法" class="headerlink" title="套接字对象内接方法"></a>套接字对象内接方法</h3><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">服务器套接字方法</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">s.bind()</td><td style="text-align:center">将地址(主机名、端口号对)绑定到套接字上</td></tr><tr><td style="text-align:center">s.listen()</td><td style="text-align:center">设置并启动TCP监听器</td></tr><tr><td style="text-align:center">s.accept()</td><td style="text-align:center">被动接受TCP客户端连接，一直等待知道连接到达(阻塞)</td></tr><tr><td style="text-align:center">客户端套接字方法</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">s.connect()</td><td style="text-align:center">主动发起TCP服务器连接</td></tr><tr><td style="text-align:center">s.connect_ex()</td><td style="text-align:center">connect()的扩展版本，此时会以错误码的形式返回问题，而不是抛出一个异常</td></tr><tr><td style="text-align:center">普通的套接字方法</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">s.recv()</td><td style="text-align:center">接受TCP消息</td></tr><tr><td style="text-align:center">s.recv_into()</td><td style="text-align:center">接受TCP消息到指定的缓冲区</td></tr><tr><td style="text-align:center">s.send()</td><td style="text-align:center">发送TCP消息</td></tr><tr><td style="text-align:center">s.sendall()</td><td style="text-align:center">完整地发送TCP消息</td></tr><tr><td style="text-align:center">s.recvfrom()</td><td style="text-align:center">接受UDP消息</td></tr><tr><td style="text-align:center">s.recvfrom_into()</td><td style="text-align:center">接受UDP消息到指定的缓冲区</td></tr><tr><td style="text-align:center">s.sendto()</td><td style="text-align:center">发送UDP消息</td></tr><tr><td style="text-align:center">s.getpeername()</td><td style="text-align:center">连接到套接字(TCP)的远程地址</td></tr><tr><td style="text-align:center">s.getsockname()</td><td style="text-align:center">当前套接字的地址</td></tr><tr><td style="text-align:center">s.getsockopt()</td><td style="text-align:center">返回给定套接字选项的值</td></tr><tr><td style="text-align:center">s.setsockopt()</td><td style="text-align:center">设置给定套接字选项的值</td></tr><tr><td style="text-align:center">s.shutdown()</td><td style="text-align:center">关闭连接</td></tr><tr><td style="text-align:center">s.close()</td><td style="text-align:center">关闭套接字</td></tr><tr><td style="text-align:center">s.detach()</td><td style="text-align:center">在未关闭文件描述符的情况下关闭套接字，返回文件描述符</td></tr><tr><td style="text-align:center">s.ioctl()</td><td style="text-align:center">控制套接字的模式(仅支持Windows)</td></tr><tr><td style="text-align:center">面向阻塞的套接字方法</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">s.setblocking()</td><td style="text-align:center">设置套接字的阻塞或非阻塞模式</td></tr><tr><td style="text-align:center">s.settimeout()</td><td style="text-align:center">设置阻塞套接字操作的超时时间</td></tr><tr><td style="text-align:center">s.gettimeout()</td><td style="text-align:center">获取阻塞套接字操作的超时时间</td></tr><tr><td style="text-align:center">面向文件的套接字方法</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">s.fileno()</td><td style="text-align:center">套接字的文件描述符</td></tr><tr><td style="text-align:center">s.makefile()</td><td style="text-align:center">创建与套接字关联的文件对象</td></tr><tr><td style="text-align:center">数据属性</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">s.family</td><td style="text-align:center">套接字家族</td></tr><tr><td style="text-align:center">s.type</td><td style="text-align:center">套接字类型</td></tr><tr><td style="text-align:center">s.proto</td><td style="text-align:center">套接字协议</td></tr></tbody></table><h3 id="socket模块属性"><a href="#socket模块属性" class="headerlink" title="socket模块属性"></a>socket模块属性</h3><table><thead><tr><th style="text-align:center">属性名称</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">数据属性</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">AF_UNIX、AF_INET、AF_INET6、AF_NETLINK、AF_TIPC</td><td style="text-align:center">Python中支持的套接字地址家族</td></tr><tr><td style="text-align:center">SO_STREAM、SO_DGRAM</td><td style="text-align:center">套接字类型(TCP=流，UDP=数据报)</td></tr><tr><td style="text-align:center">has_ipv6</td><td style="text-align:center">指示是否支持IPv6的布尔标记</td></tr><tr><td style="text-align:center">异常</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">error</td><td style="text-align:center">套接字相关错误</td></tr><tr><td style="text-align:center">herror</td><td style="text-align:center">主机和地址相关错误</td></tr><tr><td style="text-align:center">gaierror</td><td style="text-align:center">地址相关错误</td></tr><tr><td style="text-align:center">timeout</td><td style="text-align:center">超时时间</td></tr><tr><td style="text-align:center">函数</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">socket()</td><td style="text-align:center">以给定的地址家族、套接字类型和协议类型(可选) 创建一个套接字对象</td></tr><tr><td style="text-align:center">socketpair()</td><td style="text-align:center">以给定的地址家族、套接字类型和协议类型(可选) 创建一个套接字对象</td></tr><tr><td style="text-align:center">create_connection()</td><td style="text-align:center">常规函数，它接收一个地址(主机号，端口号)对，返回套接字对象</td></tr><tr><td style="text-align:center">fromfd()</td><td style="text-align:center">以一个打开的文件描述符创建一个套接字对象</td></tr><tr><td style="text-align:center">ssl()</td><td style="text-align:center">通过套接字启动一个安全套接字层连接；不执行证书验证</td></tr><tr><td style="text-align:center">getaddrinfo()</td><td style="text-align:center">获取一个五元组序列形式的地址信息</td></tr><tr><td style="text-align:center">getnameinfo()</td><td style="text-align:center">给定一个套接字地址，返回(主机名，端口号)二元组</td></tr><tr><td style="text-align:center">getfqdn()</td><td style="text-align:center">返回完整的域名</td></tr><tr><td style="text-align:center">gethostname()</td><td style="text-align:center">返回当前主机名</td></tr><tr><td style="text-align:center">gethostbyname()</td><td style="text-align:center">将一个主机名映射到它的IP地址</td></tr><tr><td style="text-align:center">gethostbyname_ex()</td><td style="text-align:center">gethostbyname()的扩展版本，它返回主机名、别名主机集合和IP地址列表</td></tr><tr><td style="text-align:center">gethostbyaddr()</td><td style="text-align:center">讲一个IP地址映射到DNS信息；返回与gethostbyname_ex()相同的三元组</td></tr><tr><td style="text-align:center">getprotobyname()</td><td style="text-align:center">将一个协议名(如‘TCP’)映射到一个数字</td></tr><tr><td style="text-align:center">getservbyname()/getservbyport()</td><td style="text-align:center">将一个服务名映射到一个端口号，或者反过来；对于任何一个函数来说，协议名都是可选的</td></tr><tr><td style="text-align:center">ntohl()/ntohs()</td><td style="text-align:center">将来自网络的整数装换为主机字节序</td></tr><tr><td style="text-align:center">htonl()/htons()</td><td style="text-align:center">将来自主机的整数转换为网络字节序</td></tr><tr><td style="text-align:center">inet_aton()/inet_ntoa()</td><td style="text-align:center">将IP地址八进制字符串转换成32位的包格式，或者反过来(仅用于IPv4地址)</td></tr><tr><td style="text-align:center">inet_pton()/inet_ntop()</td><td style="text-align:center">将IP地址字符串转换成打包的二进制格式，或者反过来(同时适用于IPv4和IPv6)</td></tr><tr><td style="text-align:center">getdefaulttimeout()/setdefaulttimeout()</td><td style="text-align:center">以秒(浮点数)为单位返回默认套接字超时时间；以秒(浮点数)为单位设置默认套接字超时时间</td></tr></tbody></table><p>详情参阅<a href="https://docs.python.org/3/library/socket.html?highlight=socket#module-socket" target="_blank" rel="noopener">socket模块文档</a></p><h2 id="创建TCP服务器-客户端"><a href="#创建TCP服务器-客户端" class="headerlink" title="创建TCP服务器/客户端"></a>创建TCP服务器/客户端</h2><h3 id="TCP服务器"><a href="#TCP服务器" class="headerlink" title="TCP服务器"></a>TCP服务器</h3><ul><li><p>下面是TCP服务器端的通用伪码，这是设计服务器的一种方式，可根据需求修改来操作服务器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ss = socket()                 <span class="comment">#创建服务器套接字</span></span><br><span class="line">ss.bind()                     <span class="comment">#套接字与地址绑定</span></span><br><span class="line">ss.listen()                   <span class="comment">#监听连接</span></span><br><span class="line">inf_loop:                     <span class="comment">#服务器无线循环</span></span><br><span class="line">    cs = ss.accept()          <span class="comment">#接受客户端连接</span></span><br><span class="line">    comm_loop:                <span class="comment">#通信循环</span></span><br><span class="line">        cs.recv()/cs.send()   <span class="comment">#对话(接收/发送)</span></span><br><span class="line">    cs.close()                <span class="comment">#关闭客户端套接字</span></span><br><span class="line">ss.close()                    <span class="comment">#关闭服务器套接字</span></span><br></pre></td></tr></table></figure></li><li><p>TCP时间戳服务器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding:UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入socket模块和time.ctime()的所有属性</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime</span><br><span class="line"></span><br><span class="line"><span class="comment"># HOST变量是空白，这是对bind()方法的标识，标识它可以使用任何可用的地址</span></span><br><span class="line"><span class="comment"># 选择一个随机的端口号</span></span><br><span class="line"><span class="comment"># 缓冲区大小为1KB</span></span><br><span class="line">HOST = <span class="string">''</span></span><br><span class="line">PORT = <span class="number">12345</span></span><br><span class="line">BUFSIZE = <span class="number">1024</span></span><br><span class="line">ADDR = (HOST, PORT)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分配了TCP服务套接字</span></span><br><span class="line"><span class="comment"># 将套接字绑定到服务器地址</span></span><br><span class="line"><span class="comment"># 开启TCP的监听调用</span></span><br><span class="line"><span class="comment"># listen()方法的参数是在连接被转接或拒绝之前，传入连接请求的最大数</span></span><br><span class="line">tcpSerSock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">tcpSerSock.bind(ADDR)</span><br><span class="line">tcpSerSock.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="comment"># 服务器循环，等待客户端的连接的连接</span></span><br><span class="line">    print(<span class="string">'waiting for connection...'</span>)</span><br><span class="line">    tcpCliSock, addr = tcpSerSock.accept()</span><br><span class="line">    print(<span class="string">'...connected from:'</span>, addr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="comment"># 当一个连接请求出现时，进入对话循环，接收消息</span></span><br><span class="line">        data = tcpCliSock.recv(BUFSIZE)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="comment"># 当消息为空时，退出对话循环</span></span><br><span class="line">            <span class="comment"># 关闭客户端连接，等待下一个连接请求</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        tcpCliSock.send(bytes(<span class="string">'[%s] %s'</span> % (</span><br><span class="line">            ctime(), data.decode(<span class="string">'utf-8'</span>)), <span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">    tcpCliSock.close()</span><br></pre></td></tr></table></figure></li></ul><h3 id="TCP客户端"><a href="#TCP客户端" class="headerlink" title="TCP客户端"></a>TCP客户端</h3><ul><li><p>下面是TCP客户端的通用伪码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cs = socket()           <span class="comment">#创建客户端套接字</span></span><br><span class="line">cs.connect()            <span class="comment">#尝试连接服务器</span></span><br><span class="line">comm_loop:              <span class="comment">#通信循环</span></span><br><span class="line">    cs.send()/cs.recv   <span class="comment">#对话(发送/接收)</span></span><br><span class="line">cs.close()              <span class="comment">#关闭客户端套接字</span></span><br></pre></td></tr></table></figure></li><li><p>TCP时间戳客户端</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入socket模块所有属性</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务器的主机名</span></span><br><span class="line"><span class="comment"># 服务器的端口号,应与服务器设置的完全相同</span></span><br><span class="line"><span class="comment"># 缓冲区大小为1KB</span></span><br><span class="line">HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line">PORT = <span class="number">12345</span></span><br><span class="line">BUFSIZE = <span class="number">1024</span></span><br><span class="line">ADDR = (HOST, PORT)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分配了TCP客户端套接字</span></span><br><span class="line"><span class="comment"># 主动调用并连接到服务器</span></span><br><span class="line">tcpCliSock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">tcpCliSock.connect(ADDR)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="comment"># 无限循环，输入消息</span></span><br><span class="line">    data = bytes(input(<span class="string">'&gt; '</span>), <span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">        <span class="comment"># 消息为空则退出循环</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 发送输入的信息</span></span><br><span class="line">    <span class="comment"># 接收服务器返回的信息，最后打印</span></span><br><span class="line">    tcpCliSock.send(data)</span><br><span class="line">    data = tcpCliSock.recv(BUFSIZE)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">        <span class="comment"># 消息为空则退出循环</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(data.decode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="comment"># 关闭客户端</span></span><br><span class="line">tcpCliSock.close()</span><br></pre></td></tr></table></figure></li></ul><h3 id="TCP服务器和客户端运行结果"><a href="#TCP服务器和客户端运行结果" class="headerlink" title="TCP服务器和客户端运行结果"></a>TCP服务器和客户端运行结果</h3><p>  在运行程序时，必须 <strong>首先运行服务器</strong> 程序，然后再运行客户端程序。如果先运行客户端程序，将会报未连接到服务器的错误。<br>  按正确的顺序启动程序后，在客户端输入信息，将会接收到加上时间戳处理后的信息，如果直接输入回车，将会关闭客户端，而服务器将会等待下一个连接请求</p><ul><li><p>服务器运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">waiting for connection...</span><br><span class="line">...connected from: (&apos;127.0.0.1&apos;, 53220)</span><br><span class="line">waiting for connection...</span><br></pre></td></tr></table></figure></li><li><p>客户端运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; hello</span><br><span class="line">[Fri Feb 23 14:22:58 2018] hello</span><br><span class="line">&gt; hi</span><br><span class="line">[Fri Feb 23 14:23:02 2018] hi</span><br><span class="line">&gt; hello world</span><br><span class="line">[Fri Feb 23 14:23:09 2018] hello world</span><br><span class="line">&gt;</span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></li></ul><h2 id="创建UDP服务器-客户端"><a href="#创建UDP服务器-客户端" class="headerlink" title="创建UDP服务器/客户端"></a>创建UDP服务器/客户端</h2><h3 id="UDP服务器"><a href="#UDP服务器" class="headerlink" title="UDP服务器"></a>UDP服务器</h3><ul><li><p>下面是UDP服务器的伪码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ss = socket()                           <span class="comment">#创建服务器套接字</span></span><br><span class="line">ss.bind()                               <span class="comment">#绑定服务器套接字</span></span><br><span class="line">inf_loop:                               <span class="comment">#服务器无线循环</span></span><br><span class="line">    cs = ss.recvfrom()/ss.sendto()      <span class="comment">#关闭(接收/发送)</span></span><br><span class="line">ss.close()                              <span class="comment">#关闭服务器套接字</span></span><br></pre></td></tr></table></figure></li><li><p>UDP时间戳服务器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding:UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入socket模块和time.ctime()的全部属性</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 与TCP相同，由于是无连接，所以没有调用监听传入连接</span></span><br><span class="line">HOST = <span class="string">''</span></span><br><span class="line">PORT = <span class="number">12345</span></span><br><span class="line">BUFSIZE = <span class="number">1024</span></span><br><span class="line">ADDR = (HOST, PORT)</span><br><span class="line"></span><br><span class="line">udpSerSock = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line">udpSerSock.bind(ADDR)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="comment"># 进入循环等待消息，一条消息到达时，处理并返回它，然后等待下一条消息</span></span><br><span class="line">    print(<span class="string">'waiting for message...'</span>)</span><br><span class="line">    data, addr = udpSerSock.recvfrom(BUFSIZE)</span><br><span class="line">    udpSerSock.sendto(bytes(<span class="string">'[%s] %s'</span> % (</span><br><span class="line">        ctime(), data.decode(<span class="string">'utf-8'</span>)), <span class="string">'utf-8'</span>), addr)</span><br><span class="line">    print(<span class="string">'...received from and returned to:'</span>, addr)</span><br></pre></td></tr></table></figure></li></ul><h3 id="UDP客户端"><a href="#UDP客户端" class="headerlink" title="UDP客户端"></a>UDP客户端</h3><ul><li><p>下面是客户端的伪码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cs = socket()                         <span class="comment">#创建客户端套接字</span></span><br><span class="line">comm_loop:                            <span class="comment">#通信循环</span></span><br><span class="line">    cs.sendto()/cs.recvfrom()         <span class="comment">#对话(发送/接收)</span></span><br><span class="line">cs.close()                            <span class="comment">#关闭客户端套接字</span></span><br></pre></td></tr></table></figure></li><li><p>UDP时间戳客户端</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/python3</span></span><br><span class="line"> <span class="comment"># -*- coding:UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"> HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line"> PORT = <span class="number">12345</span></span><br><span class="line"> BUFSIZE = <span class="number">1024</span></span><br><span class="line"> ADDR = (HOST, PORT)</span><br><span class="line"></span><br><span class="line"> udpClienSock = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">     data = bytes(input(<span class="string">'&gt;'</span>), <span class="string">'utf-8'</span>)</span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">     udpClienSock.sendto(data, ADDR)</span><br><span class="line">     data, ADDR = udpClienSock.recvfrom(BUFSIZE)</span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">     print(data.decode(<span class="string">'utf-8'</span>))</span><br><span class="line"> udpClienSock.close()</span><br></pre></td></tr></table></figure></li></ul><h3 id="UDP服务器和客户端运行结果"><a href="#UDP服务器和客户端运行结果" class="headerlink" title="UDP服务器和客户端运行结果"></a>UDP服务器和客户端运行结果</h3><p>  因为UDP面向无连接的服务，所以程序的启动顺序没有要求。当服务器处理完一个数据报之后在等待下一个继续处理</p><ul><li><p>服务器运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">waiting for message...</span><br><span class="line">...received from and returned to: (&apos;127.0.0.1&apos;, 51434)</span><br><span class="line">waiting for message...</span><br><span class="line">...received from and returned to: (&apos;127.0.0.1&apos;, 51434)</span><br><span class="line">waiting for message...</span><br></pre></td></tr></table></figure></li><li><p>客户端运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;hello</span><br><span class="line">[Fri Feb 23 15:23:57 2018] hello</span><br><span class="line">&gt;hi</span><br><span class="line">[Fri Feb 23 15:24:03 2018] hi</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><em>AF_UNIX</em> 是基于文件的套接字，代表 <em>地址家族(address family):UNIX</em>，<em>AF_INET</em> 是基于网络的套接字，代表 <em>地址家族：因特网</em>， <em>AF_INET6</em> 用于底6版因特网协议(IPv6)寻址。 <em>SOCK_STREAM</em> 表示面向连接的TCP套接字， <em>SOCK_DGRAM</em> 代表无连接的UDP套接字。</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Python的一些模块来创建网络应用程序&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://coldjune.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://coldjune.com/tags/Python/"/>
    
      <category term="网络编程" scheme="http://coldjune.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python正则表达式(三)</title>
    <link href="http://coldjune.com/2018/02/12/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E4%B8%89/"/>
    <id>http://coldjune.com/2018/02/12/Python正则表达式-三/</id>
    <published>2018-02-12T01:55:17.000Z</published>
    <updated>2018-02-22T07:38:59.798Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的两篇博文中，已经对正则表达式基本及核心的知识点进行了罗列和总结。而对于正则表达式的使用却缺乏实践。本文将基于《Python核心编程(第三版)》的练习题进行一些练习。<br><a id="more"></a></p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ol><li><blockquote><p>识别后续的字符串：“bat”、“bit”、“but”、“hat”、“hit”或者“hut”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">mode = re.compile(<span class="string">r'bat|bit|but|hat|hit|hut'</span>)</span><br><span class="line"><span class="comment">#mode  = re.compile(r'[bh][iau]t')</span></span><br><span class="line">strs = [<span class="string">'bat'</span>, <span class="string">'bit'</span>, <span class="string">'but'</span>, <span class="string">'hat'</span>, <span class="string">'hit'</span>, <span class="string">'hut'</span>]</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">    <span class="keyword">if</span> mode.match(s) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:mode.match(s).group()</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="string">'bat'</span></span><br><span class="line"><span class="string">'bit'</span></span><br><span class="line"><span class="string">'but'</span></span><br><span class="line"><span class="string">'hat'</span></span><br><span class="line"><span class="string">'hit'</span></span><br><span class="line"><span class="string">'hut'</span></span><br></pre></td></tr></table></figure></blockquote></li><li><blockquote><p>匹配由单个空格分隔的任意单词对，也就是姓和名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">mode  = re.compile(<span class="string">r'^[A-Za-z]+ [A-Za-z]+$'</span>)</span><br><span class="line">strs = [<span class="string">'david Bob'</span>, <span class="string">'D.Jone Steven'</span>, <span class="string">'Lucy D May'</span>]</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">    <span class="keyword">if</span> mode.match(s) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:mode.match(s).group()</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="string">'david Bob'</span></span><br></pre></td></tr></table></figure></blockquote></li><li><blockquote><p>匹配由单个逗号和单个空白符分隔的任何单词和单个字母，如姓氏的首字母。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">mode = re.compile(<span class="string">r'[A-Za-z]+,\s[A-Za-z]+'</span>)</span><br><span class="line">strs = [<span class="string">'david, Bob'</span>, <span class="string">'D.Jone, Steven'</span>, <span class="string">'Lucy, D, May'</span>]</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">    <span class="keyword">if</span> mode.match(s) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:mode.match(s).group()</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="string">'david, Bob'</span></span><br><span class="line"><span class="string">'Lucy, D'</span></span><br></pre></td></tr></table></figure></blockquote></li><li><blockquote><p>匹配所有有效Python 标识符<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>的集合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">mode = re.compile(<span class="string">r'[^0-9][\w_]+'</span>)<span class="comment">#用in排除关键字</span></span><br><span class="line">strs = [<span class="string">'1var'</span>, <span class="string">'v_ar'</span>, <span class="string">'_var'</span>, <span class="string">'var'</span>, <span class="string">'var_9'</span>, <span class="string">'var_'</span>]</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">    <span class="keyword">if</span> mode.match(s) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:mode.match(s).group()</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="string">'v_ar'</span></span><br><span class="line"><span class="string">'_var'</span></span><br><span class="line"><span class="string">'var'</span></span><br><span class="line"><span class="string">'var_9'</span></span><br><span class="line"><span class="string">'var_'</span></span><br></pre></td></tr></table></figure></blockquote></li><li><blockquote><p>根据读者当地的格式，匹配街道地址（使你的正则表达式足够通用，来匹配任意数<br>量的街道单词，包括类型名称）。例如，美国街道地址使用如下格式：1180 Bordeaux<br>Drive。使你的正则表达式足够灵活，以支持多单词的街道名称，如3120 De la Cruz<br>Boulevard。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">mode = re.compile(<span class="string">r'^\d&#123;4&#125;( [A-Z][a-z]+)+$'</span>)</span><br><span class="line">strs = [<span class="string">'1221 Bordeaux Drive'</span>, <span class="string">'54565 Bordeaux Drive'</span>, <span class="string">'Bordeaux Drive'</span>, <span class="string">'1221 Bordeaux Drive Drive'</span>]</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">    <span class="keyword">if</span> mode.match(s) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:mode.match(s).group()</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="string">'1221 Bordeaux Drive'</span></span><br><span class="line"><span class="string">'1221 Bordeaux Drive Drive'</span></span><br></pre></td></tr></table></figure></blockquote></li><li><blockquote><p>匹配以“www”起始且以“.com”结尾的简单Web 域名；例如，www://www. yahoo.com/。<br>选做题：你的正则表达式也可以支持其他高级域名，如.edu、.net 等（例如，<br><a href="http://www.foothill.edu）。" target="_blank" rel="noopener">http://www.foothill.edu）。</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">mode = re.compile(<span class="string">r'^(http[s]?://)?www\.(\w+\.)+(com|net|edu)$'</span>)</span><br><span class="line">strs=[<span class="string">'https://www.baidu.com'</span>, <span class="string">'http://www.bilibili.com'</span>, <span class="string">'www.baidu.com'</span>, <span class="string">'baidu.com'</span>, <span class="string">'www.cqupt.edu'</span>]</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">    <span class="keyword">if</span> mode.match(s) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:mode.match(s).group()</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="string">'https://www.baidu.com'</span></span><br><span class="line"><span class="string">'http://www.bilibili.com'</span></span><br><span class="line"><span class="string">'www.baidu.com'</span></span><br><span class="line"><span class="string">'www.cqupt.edu'</span></span><br></pre></td></tr></table></figure></blockquote></li><li><blockquote><p>匹配所有能够表示Python 整数的字符串集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">mode = re.compile(<span class="string">r'^\d+[lL]?$'</span>)</span><br><span class="line">strs = [<span class="string">'123'</span>, <span class="string">'123l'</span>, <span class="string">'12312L'</span>]</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">    <span class="keyword">if</span> mode.match(s) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:mode.match(s).group()</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="string">'123'</span></span><br><span class="line"><span class="string">'123l'</span></span><br><span class="line"><span class="string">'12312L'</span></span><br></pre></td></tr></table></figure></blockquote></li><li><blockquote><p>匹配所有能够表示Python 长整数的字符串集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">mode = re.compile(<span class="string">r'^\d+[lL]$'</span>)</span><br><span class="line">strs = [<span class="string">'123'</span>, <span class="string">'123l'</span>, <span class="string">'12312L'</span>]</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">    <span class="keyword">if</span> mode.match(s) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:mode.match(s).group()</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="string">'123l'</span></span><br><span class="line"><span class="string">'12312L'</span></span><br></pre></td></tr></table></figure></blockquote></li><li><blockquote><p>匹配所有能够表示Python 浮点数的字符串集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">mode = re.compile(<span class="string">r'(0|[1-9]\d*)(\.\d+)?$'</span>)</span><br><span class="line">strs = [<span class="string">'00.10'</span>, <span class="string">'0.123'</span>, <span class="string">'12.23'</span>, <span class="string">'12'</span>, <span class="string">'12.36l'</span>]</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">    <span class="keyword">if</span> mode.match(s) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:mode.match(s).group()   </span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="string">'0.123'</span></span><br><span class="line"><span class="string">'12.23'</span></span><br><span class="line"><span class="string">'12'</span></span><br></pre></td></tr></table></figure></blockquote></li><li><blockquote><p>匹配所有能够表示Python 复数的字符串集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">mode = re.compile(<span class="string">r'^((0|[1-9]\d*)(\.\d+)?\+)?((0|[1-9]\d*)(\.\d+)?j)?$'</span>)</span><br><span class="line">strs = [<span class="string">'12.3+1.2j'</span>, <span class="string">'1+2j'</span>, <span class="string">'4j'</span>]</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">    <span class="keyword">if</span> mode.match(s) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:mode.match(s).group()   </span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="string">'12.3+1.2j'</span></span><br><span class="line"><span class="string">'1+2j'</span></span><br><span class="line"><span class="string">'4j'</span></span><br></pre></td></tr></table></figure></blockquote></li><li><blockquote><p>匹配所有能够表示有效电子邮件地址的集合（从一个宽松的正则表达式开始，然<br>后尝试使它尽可能严谨，不过要保持正确的功能）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">mode = re.compile(<span class="string">r'^\w+@(\w+\.)+(com|com\.cn|net)$'</span>)</span><br><span class="line">strs = [<span class="string">'12345@qq.com'</span>, <span class="string">'sina@163.com'</span>, <span class="string">'qq@sina.com.cn'</span>, <span class="string">'net@21cn.com'</span>, <span class="string">'new123@163.sina.com'</span>]</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">    <span class="keyword">if</span> mode.match(s) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:mode.match(s).group()   </span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="string">'12345@qq.com'</span></span><br><span class="line"><span class="string">'sina@163.com'</span></span><br><span class="line"><span class="string">'qq@sina.com.cn'</span></span><br><span class="line"><span class="string">'net@21cn.com'</span></span><br><span class="line"><span class="string">'new123@163.sina.com'</span></span><br></pre></td></tr></table></figure></blockquote></li><li><blockquote><p>type()。内置函数type()返回一个类型对象，如下所示，该对象将表示为一个Pythonic<br>类型的字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">mode = re.compile(<span class="string">r'&lt;type \'(.*)\'&gt;'</span>)</span><br><span class="line">strs = [<span class="string">'&lt;type \'int\'&gt;'</span>, <span class="string">'&lt;type \'float\'&gt;'</span>, <span class="string">'&lt;type \'builtin_function_or_method\'&gt;'</span>]</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">    <span class="keyword">if</span> mode.match(s) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:mode.match(s).group(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="string">'int'</span></span><br><span class="line"><span class="string">'float'</span></span><br><span class="line"><span class="string">'builtin_function_or_method'</span></span><br></pre></td></tr></table></figure></blockquote></li><li><blockquote><p>处理日期。1.2 节提供了来匹配单个或者两个数字字符串的正则表达式模式，来表示1～<br>9 的月份(0?[1-9])。创建一个正则表达式来表示标准日历中剩余三个月的数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">mode = re.compile(<span class="string">r'1[0-2]'</span>)</span><br><span class="line">strs = [<span class="string">'10'</span>, <span class="string">'11'</span>, <span class="string">'12'</span>]</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">     <span class="keyword">if</span> mode.match(s) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:mode.match(s).group()</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="string">'10'</span></span><br><span class="line"><span class="string">'11'</span></span><br><span class="line"><span class="string">'12'</span></span><br></pre></td></tr></table></figure></blockquote></li><li><blockquote><p>创建一个允许使用连字符的正则表达式，但是仅能用于正确的位置。例如，15 位的信用卡号<br>码使用4-6-5 的模式，表明4 个数字-连字符-6 个数字-连字符-5 个数字；16 位的信用卡号码使用4-4-4-4 的模式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">mode = re.compile(<span class="string">r'\d&#123;4&#125;-((\d&#123;6&#125;-\d&#123;5&#125;)|(\d&#123;4&#125;-\d&#123;4&#125;-\d&#123;4&#125;))'</span>)</span><br><span class="line">strs = [<span class="string">'1234-567890-12345'</span>, <span class="string">'1234-5678-8012-3456'</span>]</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">    <span class="keyword">if</span> mode.match(s) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:mode.match(s).group()</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="string">'1234-567890-12345'</span></span><br><span class="line"><span class="string">'1234-5678-8012-3456'</span></span><br></pre></td></tr></table></figure></blockquote></li></ol><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">标识符有字母、数字、下划线组成，但不能由数字开头</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前的两篇博文中，已经对正则表达式基本及核心的知识点进行了罗列和总结。而对于正则表达式的使用却缺乏实践。本文将基于《Python核心编程(第三版)》的练习题进行一些练习。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://coldjune.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://coldjune.com/tags/Python/"/>
    
      <category term="正则表达式" scheme="http://coldjune.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python正则表达式(二)</title>
    <link href="http://coldjune.com/2018/02/10/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E4%BA%8C/"/>
    <id>http://coldjune.com/2018/02/10/Python正则表达式-二/</id>
    <published>2018-02-10T13:28:04.000Z</published>
    <updated>2018-02-11T08:18:55.912Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式的匹配规则基本已经在上一篇博文中全部罗列出来了，下面便是结合到具体语言进行学习和练习了。<br>由于个人兴趣和想要专研的方向，在这里将会使用Python <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 语言进行描述。<br><a id="more"></a></p><h2 id="正则表达式和Python语言"><a href="#正则表达式和Python语言" class="headerlink" title="正则表达式和Python语言"></a>正则表达式和Python语言</h2><h3 id="re模块：核心函数和方法"><a href="#re模块：核心函数和方法" class="headerlink" title="re模块：核心函数和方法"></a>re模块：核心函数和方法</h3><table><thead><tr><th style="text-align:center">函数方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">仅仅是re函数模块</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">compile(pattern, flags=0)</td><td style="text-align:center">使用任何可选的标记来编译正则表达式的模式，然后返回一个正则表达式对象</td></tr><tr><td style="text-align:center">re模块函数和正则表达式对象的方法</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">match(pattern, string, flags=0)</td><td style="text-align:center">尝试使用带有可选的标记的正则表达式的模式来匹配字符串，如果匹配成功，就返回匹配对象；如果失败，就返回None</td></tr><tr><td style="text-align:center">search(pattern, string, flags=0)</td><td style="text-align:center">使用可选标记搜索字符串中第一次出现的正则表达式模式。如果匹配成功，则返回匹配对象；如果匹配失败，怎返回None</td></tr><tr><td style="text-align:center">findall(pattern, string [,flags])</td><td style="text-align:center">查找字符串中所有(非重复)出现的正则表达式模式，并返回一个匹配列表</td></tr><tr><td style="text-align:center">finditer(pattern, string[,flags])</td><td style="text-align:center">与findall()函数相同，但返回的不是一个列表，而是一个迭代器。对于每一次匹配，迭代器都返回一个匹配对象</td></tr><tr><td style="text-align:center">split(pattern, string, max=0)</td><td style="text-align:center">根据正则表达式的模式分隔符，split函数将字符串分割为列表，然后返回成功的列表，分割最多操作max次(默认分割所有匹配成功的位置)</td></tr><tr><td style="text-align:center">sub(pattern, repl, string, count=0)</td><td style="text-align:center">使用repl替换所有正则表达式的模式在字符串中出现的位置，除非定义count，否则就讲替换所有出现的位置（另见subn()函数，该函数返回替换操作的数目）</td></tr><tr><td style="text-align:center">purge()</td><td style="text-align:center">清除隐式编译的正则表达式模式</td></tr><tr><td style="text-align:center">常见的匹配对象方法</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">group(num=0)</td><td style="text-align:center">返回整个匹配对象，或者编号为num的特定子组</td></tr><tr><td style="text-align:center">groups(default=None)</td><td style="text-align:center">返回一个包含所有匹配子组的元组(如果没有成功匹配，则返回一个空元组)</td></tr><tr><td style="text-align:center">groupdict(default=None)</td><td style="text-align:center">返回一个包含所有匹配的命名子组的字典，所有的子组名称作为字典的键(如果没有成功匹配，则返回一个空字典)</td></tr><tr><td style="text-align:center">常用的模块属性（用于大多数正则表达式函数的标记）</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">re.I,re.IGNORECASE</td><td style="text-align:center">不去分大小写的匹配</td></tr><tr><td style="text-align:center">re.L,re.LOCALE</td><td style="text-align:center">根据所使用的本地语言环境通过\w、\w、\b、\B、\s、\S实现匹配</td></tr><tr><td style="text-align:center">re.M,re.MULTILINE</td><td style="text-align:center">^和$分别匹配目标字符串中行的起始和结尾，而不是严格匹配整个字符串本身的起始和结尾</td></tr><tr><td style="text-align:center">re.S,re.DOTALL</td><td style="text-align:center">“.”(点号)通常匹配除了\n(换行符)之外的所有单个字符：该标记表示”.”(点号)能匹配全部字符</td></tr><tr><td style="text-align:center">re.X,re.VERBOSE</td><td style="text-align:center">通过反斜线转移，否则所有空格加上#(以及在该行中后续文字)都被忽略，除非在一个字符类中或者允许注释并且提高可读性</td></tr></tbody></table><h3 id="部分方法总结"><a href="#部分方法总结" class="headerlink" title="部分方法总结"></a>部分方法总结</h3><ul><li><p><em>compile(pattern, flags=0)<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></em></p><blockquote><p>使用预编译使用推荐的方式，但不是必须的，可以通过设置标志位(上表已罗列出使用频繁的标记，详情可以<a href="https://docs.python.org/3/library/re.html?highlight=re#module-re" target="_blank" rel="noopener">查阅文档</a>),标志位通过 （|）合并</p></blockquote></li><li><p><em>group(num=0)</em> 和 <em>groups(default=None)</em></p><blockquote><p>匹配对象<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>的两个主要方法。 <em>group()</em> 要么返回整个匹配对象，要么按要求返回特定子组。 <em>groups()</em> 仅返回一个包含唯一或全部子组的元组。如果没有子组的要求，<em>group()</em> 返回整个匹配，<em>groups()</em> 返回一个空元组。</p></blockquote></li><li><p><em>match(pattern, string, flags=0)</em></p><blockquote><p><em>match()</em> 方法试图从字符串的<strong>起始部分</strong>对模式进行匹配。如果匹配成功，返回一个匹配对象；如果失败就返回None</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#匹配成功</span></span><br><span class="line"> m = re.match(<span class="string">'foo'</span>, <span class="string">'foo'</span>) <span class="comment">#模式匹配字符串</span></span><br><span class="line"> <span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:         <span class="comment">#如果匹配成功，就输出匹配内容</span></span><br><span class="line">     m.group()</span><br><span class="line"></span><br><span class="line"><span class="string">'foo'</span>                       <span class="comment">#输出结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#匹配失败</span></span><br><span class="line">m  = re.match(<span class="string">'foo'</span>, <span class="string">'Bfoo'</span>) <span class="comment">#模式匹配字符串</span></span><br><span class="line"><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:           <span class="comment">#如果匹配成功，就输出匹配内容</span></span><br><span class="line">    m.group()</span><br><span class="line"></span><br><span class="line">                            <span class="comment">#因为起始字符为'B',所以匹配不成功，无任何输出</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p><em>search(pattern, string, flags=0)</em></p><blockquote><p><em>search()</em> 的工作方式和 <em>match()</em> 相同，不同之处在于 <em>search()</em> 会用它的字符串参数在<strong>任意位置</strong>对给定正则表达式模式搜索<strong>第一次</strong>出现的匹配情况。如果搜索到成功的匹配，就返回一个匹配对象；否则，就返回None。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将上面使用match()方法匹配的串改用search()匹配</span></span><br><span class="line">m = re.search(<span class="string">'foo'</span>, <span class="string">'Bfoo'</span>) <span class="comment">#模式匹配字符串</span></span><br><span class="line"><span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:            <span class="comment">#如果匹配成功，就输出匹配内容</span></span><br><span class="line">    m.group()</span><br><span class="line"></span><br><span class="line"><span class="string">'foo'</span>                        <span class="comment">#可以看到就算起始位置未能匹配，也能匹配成功</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p><em>findall(pattern, string[,flags])</em> 和 <em>finditer(pattern, string[,flags])</em></p><blockquote><p><em>findall()</em> 总是返回一个列表，如果没有找到匹配对象，返回一个空列表<br>  <em>finditer()</em> 是一个与 <em>findall()</em> 类似但更节省内存的变体，<em>finditer()</em> 在匹配对象中迭代<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#findall()匹配</span></span><br><span class="line">re.findall(<span class="string">'car'</span>, <span class="string">'carry the barcardi to the car'</span>) <span class="comment">#模式匹配字符串</span></span><br><span class="line"></span><br><span class="line">[<span class="string">'car'</span>, <span class="string">'car'</span>, <span class="string">'car'</span>]                              <span class="comment">#返回结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#finditer()匹配</span></span><br><span class="line">iter = re.finditer(<span class="string">'car'</span>, <span class="string">'carry the barcardi to the car'</span>) <span class="comment">#模式匹配字符串</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> iter:                                            <span class="comment">#遍历迭代器</span></span><br><span class="line">    print(i.group())</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line">car</span><br><span class="line">car</span><br><span class="line">car</span><br></pre></td></tr></table></figure></blockquote></li><li><p><em>sub(pattern, repl, string, count=0)</em> 和 <em>subn(pattern, repl, string, count=0)</em></p><blockquote><p><em>sub()</em> 和 <em>subn()</em> 用于实现搜索和替换功能。两者都是将某字符串中所有匹配正则表达式的部分进行某种形式的替换。和 <em>sub()</em> 不同的是，<em>subn()</em> 返回一个表示替换的总数，替换后的字符串和表示替换总数的数字一起作为一个拥有两个元素的元组返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sub()</span></span><br><span class="line">re.sub(<span class="string">'car'</span>, <span class="string">'cat'</span>, <span class="string">'My car is not only a car.'</span>) <span class="comment">#模式匹配字符串</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'My cat is not only a cat.'</span>                         <span class="comment">#输出结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#subn()</span></span><br><span class="line">re.subn(<span class="string">'car'</span>, <span class="string">'cat'</span>, <span class="string">'My car is not only a car.'</span>) <span class="comment">#模式匹配字符串</span></span><br><span class="line"></span><br><span class="line">(<span class="string">'My cat is not only a cat.'</span>, <span class="number">2</span>)                   <span class="comment">#输出结果</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p><em>split(pattern, string, max=0)</em></p><blockquote><p>正则表达式对象的 <em>split()</em> 方法和字符串的工作方式类似，但它是基于正则表达式的模式分割字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">re.split(<span class="string">':'</span>, <span class="string">'str1:str2:str3'</span>)               <span class="comment">#模式匹配字符串</span></span><br><span class="line"></span><br><span class="line">[<span class="string">'str1'</span>, <span class="string">'str2'</span>, <span class="string">'str3'</span>]                      <span class="comment">#输出结果，与'str1:str2:str3'.split(':')相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#split()复杂用法</span></span><br><span class="line"><span class="comment">#使用split()基于逗号分割字符串，如果空格紧跟在5个数字或者两个大写字母之后，就用split()分割该空格</span></span><br><span class="line"><span class="comment">#使用(?=)正向前视断言，不适用输入字符串 而是使用后面的空格作为分割字符串</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">DATA = (</span><br><span class="line">  <span class="string">'Mountain View, CA 94040'</span>,</span><br><span class="line">  <span class="string">'Sunnyvale, CA'</span>,</span><br><span class="line">  <span class="string">'Los Altos, 94023'</span>,</span><br><span class="line">  <span class="string">'Cupertino 95014'</span>,</span><br><span class="line">  <span class="string">'Palo Alto CA'</span>,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">for</span> datum <span class="keyword">in</span> DATA:</span><br><span class="line">    print(re.split(<span class="string">', |(?= (?:\d&#123;5&#125;|[A-Z]&#123;2&#125;)) '</span>, datum))</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line">[<span class="string">'Mountain View'</span>, <span class="string">'CA'</span>, <span class="string">'94040'</span>]</span><br><span class="line">[<span class="string">'Sunnyvale'</span>, <span class="string">'CA'</span>]</span><br><span class="line">[<span class="string">'Los Altos'</span>, <span class="string">'94023'</span>]</span><br><span class="line">[<span class="string">'Cupertino'</span>, <span class="string">'95014'</span>]</span><br><span class="line">[<span class="string">'Palo Alto'</span>, <span class="string">'CA'</span>]</span><br></pre></td></tr></table></figure></blockquote></li></ul><h3 id="符号的使用"><a href="#符号的使用" class="headerlink" title="符号的使用"></a>符号的使用</h3><h4 id="与-和"><a href="#与-和" class="headerlink" title="| 与 . 和 []"></a><code>|</code> 与 <code>.</code> 和 <code>[]</code></h4><blockquote><p>包括择一匹配符号<code>|</code>、点号<code>.</code>，点号不匹配非字符或换行付\n（即空字符）<br>    字符集<code>[]</code>中的字符只取其一</p></blockquote><h4 id="重复、特殊字符5以及分组"><a href="#重复、特殊字符5以及分组" class="headerlink" title="重复、特殊字符5以及分组"></a>重复、特殊字符<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>以及分组</h4><blockquote><p><code>?</code>操作符表示前面的模式出现零次或一次<br><code>+</code>操作符表示前面的模式出现至少一次<br><code>*</code>操作符表示前面的模式出现任意次(包括0次)<br>分组从左起第一个括号开始算第一个分组<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">m  = re.match(<span class="string">'(\w(\w\w))-(\d\d\d)'</span>,<span class="string">'abc-123'</span>)</span><br><span class="line">m.group()                           <span class="comment">#完整匹配</span></span><br><span class="line"><span class="string">'abc-123'</span>                           <span class="comment">#输出结果</span></span><br><span class="line"></span><br><span class="line">m.group(<span class="number">1</span>)                          <span class="comment">#第一组</span></span><br><span class="line"><span class="string">'abc'</span>                               <span class="comment">#输出结果    </span></span><br><span class="line"></span><br><span class="line">m.group(<span class="number">2</span>)                          <span class="comment">#第二组</span></span><br><span class="line"><span class="string">'bc'</span>                                <span class="comment">#输出结果</span></span><br><span class="line"></span><br><span class="line">m.group(<span class="number">3</span>)                          <span class="comment">#第三组</span></span><br><span class="line"><span class="string">'123'</span>                               <span class="comment">#输出结果</span></span><br><span class="line"></span><br><span class="line">m.groups()                          <span class="comment">#全部子组</span></span><br><span class="line">(<span class="string">'abc'</span>, <span class="string">'bc'</span>, <span class="string">'123'</span>)                <span class="comment">#输出结果</span></span><br></pre></td></tr></table></figure></p></blockquote><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">这里Python指代的是Python3.6.4</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">预编译可以提升执行效率，而 <code>re.compile()</code> 方法提供了这个功能。模块函数会对已编译的对象进行缓存，所以无论使用 <code>match()</code> 和 <code>search()</code> 在执行时编译的正则表达式,还是使用 <code>compile()</code> 编译的表达式,在再次使用时都会查询缓存。但使用 <code>compile()</code> 同样可以节省查询缓存的时间</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">除了正则表达式对象之外，还有另外一个对象类型：<strong>匹配对象</strong>。这些是成功调用 <code>match()</code> 和 <code>search()</code> 返回的对象。</span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;">如果遇到无法调用 <code>next()</code>方法，可以使用 <code>__next__()</code>方法代替。</span><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">5.</span><span style="display: inline-block; vertical-align: top;">特殊字符的详情可以参考<a href="http://coldjune.com/2018/02/09/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E4%B8%80/">上一篇博文</a></span><a href="#fnref:5" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正则表达式的匹配规则基本已经在上一篇博文中全部罗列出来了，下面便是结合到具体语言进行学习和练习了。&lt;br&gt;由于个人兴趣和想要专研的方向，在这里将会使用Python &lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; 语言进行描述。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://coldjune.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://coldjune.com/tags/Python/"/>
    
      <category term="正则表达式" scheme="http://coldjune.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python正则表达式(一)</title>
    <link href="http://coldjune.com/2018/02/09/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E4%B8%80/"/>
    <id>http://coldjune.com/2018/02/09/Python正则表达式-一/</id>
    <published>2018-02-09T07:08:05.000Z</published>
    <updated>2018-02-11T01:04:21.113Z</updated>
    
    <content type="html"><![CDATA[<p>在Python的学习过程中，正则表达式始终是一道绕不过去的坎.无论提取服务器日志文件还是爬取网页，正则表达式始终扮演着至关重要的角色。下面便对自己学习过程中的一些正则表达式基础做一个总结。<br><a id="more"></a></p><h2 id="特殊符号和字符"><a href="#特殊符号和字符" class="headerlink" title="特殊符号和字符"></a>特殊符号和字符</h2><table><thead><tr><th style="text-align:center">表示法</th><th style="text-align:center">描述</th><th style="text-align:center">正则表达式示例</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">符号</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">literal</td><td style="text-align:center">匹配文本字符串的字面值literal</td><td style="text-align:center">foo</td><td style="text-align:center">只是匹配foo，相当于取等</td></tr><tr><td style="text-align:center">re1&#124; re2</td><td style="text-align:center">匹配正则表达式re1或re2</td><td style="text-align:center">foo&#124; bar</td><td style="text-align:center">匹配foo或者bar，二选一</td></tr><tr><td style="text-align:center">.</td><td style="text-align:center">匹配任何字符(除了\n之外)</td><td style="text-align:center">a.a</td><td style="text-align:center">匹配axa、aaa、aca等，两个a中间可以是除了\n的任意字符</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">匹配字符串起始部分</td><td style="text-align:center">^Foo</td><td style="text-align:center">匹配Foo，不匹配aFoo</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">匹配字符串终止部分</td><td style="text-align:center">Bar$</td><td style="text-align:center">只匹配Bar,不匹配aBar等</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">匹配0次或者多次前面出现的正则表达式</td><td style="text-align:center">[A-Za-z0-9]*</td><td style="text-align:center">匹配任意多个字母或数字</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">匹配1次或者多次前面出现的正则表达式</td><td style="text-align:center">[A-Za-z0-9]+</td><td style="text-align:center">匹配一到多个个字母或数字</td></tr><tr><td style="text-align:center">?</td><td style="text-align:center">匹配0次或者1次前面出现的正则表达式</td><td style="text-align:center">[A-Za-z0-9]</td><td style="text-align:center">要么有一个字母或数字要么没有</td></tr><tr><td style="text-align:center">{N}</td><td style="text-align:center">匹配N次前面出现的正则表达式</td><td style="text-align:center">[0-9]{3}</td><td style="text-align:center">匹配三个数字</td></tr><tr><td style="text-align:center">{M,N}</td><td style="text-align:center">匹配M~N次前面出现的正则表达式</td><td style="text-align:center">[0-9]{5,9}</td><td style="text-align:center">匹配5到9个数字(包括5个和9个)</td></tr><tr><td style="text-align:center">[…]</td><td style="text-align:center">匹配来自字符集的任意单一字符</td><td style="text-align:center">[aeiou]</td><td style="text-align:center">匹配一个元音字母</td></tr><tr><td style="text-align:center">[..x~y..]</td><td style="text-align:center">匹配x~y范围内的任意单一字符</td><td style="text-align:center">[A-Za-z]</td><td style="text-align:center">匹配任意一个英文字母</td></tr><tr><td style="text-align:center">[^…]</td><td style="text-align:center">不匹配此字符集中出现的任何一个字符，包括某一范围的字符(如果在此字符集中出现)</td><td style="text-align:center">[\^aeiou][\^A-Za-z0-9]</td><td style="text-align:center">匹配一个非元音字母和一个非字母数字字符</td></tr><tr><td style="text-align:center">(*&#124;+&#124;?&#124;{})?</td><td style="text-align:center">用于匹配上面频繁出现/重复出现符号的非贪婪版本(*、+、?、{})</td><td style="text-align:center">.*?[a-z]</td><td style="text-align:center">(非贪婪是指尽可能少的匹配)</td></tr><tr><td style="text-align:center">(…)</td><td style="text-align:center">匹配封闭的正则表达式,然后另存为子组</td><td style="text-align:center">f(oo&#124; u)bar</td><td style="text-align:center">匹配foobar,fubar</td></tr><tr><td style="text-align:center">特殊字符</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">\d</td><td style="text-align:center">匹配任何十进制数字，与[0-9]一致(\D和\d相反，不匹配任何非数值型的数字)</td><td style="text-align:center">data\d+.txt</td><td style="text-align:center">匹配data1.txt、data12.txt</td></tr><tr><td style="text-align:center">\w</td><td style="text-align:center">匹配任何字母数字字符，与[A-Za-z0-9]相同(\W与之相反)</td><td style="text-align:center">[A-Za-z_]\w+</td><td style="text-align:center">匹配任意字母或_加一个或多个字母数字字符(asda,_asda)</td></tr><tr><td style="text-align:center">\s</td><td style="text-align:center">匹配任何空格字符，与[\n\t\r\v\f]相同(\S与之相反)</td><td style="text-align:center">of\sthe</td><td style="text-align:center">匹配of the (\n:换行符&#124;\t:水平制表符&#124;\r:回车&#124;\v:垂直制表符&#124;\f:换页符)</td></tr><tr><td style="text-align:center">\b</td><td style="text-align:center">匹配任何单词边界(\B与之相反)</td><td style="text-align:center">\bThe\b</td><td style="text-align:center">匹配of The a，不匹配ofThe a</td></tr><tr><td style="text-align:center">\N</td><td style="text-align:center">匹配已保存的子组N(与上面(…)配合使用)</td><td style="text-align:center">price:\16</td><td style="text-align:center">匹配price:和前面第16个子组的值</td></tr><tr><td style="text-align:center">\c</td><td style="text-align:center">逐字匹配任何特殊字符(即仅按字面意义匹配，不包含特殊含义，\为对特殊字符的转义表示)</td><td style="text-align:center">*</td><td style="text-align:center">匹配*</td></tr><tr><td style="text-align:center">\A(\Z)</td><td style="text-align:center">匹配字符串的起始(结束)(另见上面的^和$)</td><td style="text-align:center">\ADear</td><td style="text-align:center">匹配以Dear开头的</td></tr><tr><td style="text-align:center">扩展表示法</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">（?iLmsux）</td><td style="text-align:center">在正则表达式中嵌入一个或多个特殊”标记”参数(或者通过函数/方法)</td><td style="text-align:center">（?x）,(?im)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">(?:…)</td><td style="text-align:center">表示一个匹配不用保存的分组</td><td style="text-align:center">(?:\w+.)*</td><td style="text-align:center">匹配任意多个一个或多个字母数字字符与.的组合但不保存改分组</td></tr><tr><td style="text-align:center">(?P<name>…)</name></td><td style="text-align:center">像一个仅由name标识而不是数字ID标识的正则分组匹配</td><td style="text-align:center">(?P<data>)</data></td><td style="text-align:center">给匹配的分组命名为data</td></tr><tr><td style="text-align:center">(?P=name)</td><td style="text-align:center">在同一个字符串中匹配由(?P<name>)分组之前的文本</name></td><td style="text-align:center">(?P=data)</td><td style="text-align:center">匹配名字为data的串</td></tr><tr><td style="text-align:center">(?#…)</td><td style="text-align:center">表示注释，所有内容都被忽略</td><td style="text-align:center">(?#comment)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">(?=…)</td><td style="text-align:center">匹配条件是如果…出现在之后的位置，而不使用输入字符串；称作正向前视断言</td><td style="text-align:center">(?=.com)</td><td style="text-align:center">如果一个字符串后面跟着“.com”才做匹配操作，并不适用任何目标字符串</td></tr><tr><td style="text-align:center">(?!…)</td><td style="text-align:center">匹配条件是如果…不出现在之后的位置，而不使用输入字符串；称作负向前视断言</td><td style="text-align:center">(?!.net)</td><td style="text-align:center">如果一个字符串后面不是跟着“.net”，才做匹配操作</td></tr><tr><td style="text-align:center">(?&lt;=…)</td><td style="text-align:center">匹配条件是如果…出现在之前的位置，而不使用输入字符串；称作正向后视断言</td><td style="text-align:center">(?&lt;=800-)</td><td style="text-align:center">如果字符串之前为“800-”才做匹配，并不使用任何输入字符串</td></tr><tr><td style="text-align:center">(?&lt;!…)</td><td style="text-align:center">匹配条件是如果…不出现在之前的位置，而不使用输入字符串；称作负向后视断言</td><td style="text-align:center">(?&lt;!192\.168\.)</td><td style="text-align:center">如果一个字符串之前不是“192.168.”才做匹配，并不适用任何输入字符串</td></tr><tr><td style="text-align:center">(?(id/name)Y&#124;N</td><td style="text-align:center">如果分组所提供的id或name(名称)存在，就返回正则表达式的条件匹配Y，如果不存在，就返回N;N是可选项</td><td style="text-align:center">(?(1)y&#124;x)</td><td style="text-align:center">如果一个匹配组1(\1)存在就y匹配；否则，就与x匹配</td></tr></tbody></table><p>以上为正则表达式的一些基本的符号定义与用法，熟练掌握这些符号是写出高效表达式的基础。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Python的学习过程中，正则表达式始终是一道绕不过去的坎.无论提取服务器日志文件还是爬取网页，正则表达式始终扮演着至关重要的角色。下面便对自己学习过程中的一些正则表达式基础做一个总结。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://coldjune.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://coldjune.com/tags/Python/"/>
    
      <category term="正则表达式" scheme="http://coldjune.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
</feed>
