<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python多线程(一)]]></title>
    <url>%2F2018%2F02%2F24%2FPython%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[多线程编程对于以下编程任务是非常理想的： 本质上是一步的 需要多个并发活动 每个活动的处理顺序可能是不确定的(随机、不可预测的) 使用多线程或者类似Queue的共享数据结构可以将一个串行程序规划成几个执行特定任务的线程 UserRequestThread: 负责读取客户端输入。程序将创建多个线程，每个客户端一个，客户端的请求将会被放入队列中 RequestProcessor: 该线程负责从队列中获取请求并进行处理，为第三个线程提供输出 ReplyThread: 负责向用户输出，将结果传回给用户，或者把数据写到本地文件系统或者数据库中 线程和进程 进程 计算机程序是储存在磁盘上的可执行二进制(或其他类型)的文件。进程 （有时称为 重量级进程）则是一个执行中的程序。 每一个进程都拥有自己的地址空间、内存、数据栈以及其他用于跟踪执行的辅助数据。操作系统管理其上的所有进程的执行，并为它们合理地分配时间。进程可以通过 派生(fork或spawn)新的进程来执行任务,而进程之间的通信只能通过 进程间通信(IPC) 的方式共享信息 线程 线程（有时称为 轻量级进程）共享相同的上下文。相当于在主进程中并行运行的一些“迷你进程”。当其他线程运行是，它可以被抢占（中断） 和临时挂起（睡眠），这种做法叫 让步(yielding)。早单核CPU系统中，线程的实际规划是：每个线程运行一小会儿，然后让步给其他线程（再次排队 等待更多的CPU时间）。在整个进程的执行当中，每个线程执行它自己特定的任务，在必要时和其他线程进行结果通信。 线程与Python全局解释锁 对Python虚拟机的访问是由 全局解释锁(GIL) 控制的。这个锁用来保证同时只能有一个线程运行。在多线程环境中，Python虚拟机将按照下面的方式执行。 设置GIL 切换进一个线程去运行 执行下面操作之一 a. 指定数量的字节码指令 b. 线程主动让出控制权(可以调用time.sleep(0)来完成) 把线程设置回睡眠状态(切换出线程) 解锁GIL 重复上述步骤当调用外部代码(即，任意C/C++扩展的内置函数)时，GIL会保持锁定，直至函数执行结束。 退出线程 当一个线程完成函数的执行时，就会退出。还可以通过调用thread.exit()或者sys.exit()退出进程，或者抛出SystemExit异常，是线程退出。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python网络编程(二)]]></title>
    <url>%2F2018%2F02%2F24%2FPython%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[上篇对Python中的socket模块的简单应用做了描述和记录，下面便是对SocketServer模块和Twisted框架做一个简要的记录 socketserver模块socketserver是标准库的一个高级模块，它的目标是简化很多样板代码，它们是创建网络客户端和服务器所必需的代码。 socketserver模块类 类 描述 BaseServer 包含核心服务器功能和mix-in类的钩子；仅用于推导，这样不会创建这个类的实例；可以用TCPServer或UDPServer创建类的实例 TCPServer/UDPServer 基础的网络同步TCP/UDP服务器 UnixStreamServer/UnixDatagramServer 基于文件的基础同步TCP/UDP服务器 ForkingMixIn/ThreadingMixIn 核心派出或线程功能；只用作mix-in类与一个服务器类配合实现一些异步性；不能直接实例化这个类 ForkingTCPServer/ForkingUDPServer ForkingMaxIn和TCPServer/UDPServer的组合 ThreadingTCPServer/ThreadingUDPServer ThreadingMixIn和TCPServer/UDPServer的组合 BaseRequestHandler 包含处理服务请求的核心功能；仅用于推导，无法创建这个类的实例；可以使用StreamRequestHandler或DatagramRequestHandler创建类的实例 StreamRequestHandler/DatagramRequestHandler 实现TCP/UDP服务器的服务处理器 socketserver TCP服务器/客户端在原始服务器循环中，我们阻塞等待请求，当接收到请求时就对其提供服务，然后继续等待。在此处的服务器循环中，并非在服务器中创建代码，而是定义一个处理程序，当服务器接收到一个传入的请求时，服务器就可以调用 TCP服务器 1234567891011121314151617181920212223242526272829#!usr/bin/python3# -*- coding:UTF-8 -*-# 导入socketserver相关的类和time.ctime()的全部属性from socketserver import (TCPServer as TCP, StreamRequestHandler as SRH)from time import ctimeHOST = ''PORT = 12345ADDR = (HOST, PORT)class MyRequestHandler(SRH): # MyRequestHandler继承自StreamRequestHandler def handle(self): # 重写handle方法，当接收到一个客户端消息是，会调用handle()方法 print('...connected from:', self.client_address) # StreamRequestHandler将输入和输出套接字看做类似文件的对象 # 所以使用write()将字符串返回客户端，用readline()来获取客户端信息 self.wfile.write(bytes('[%s] %s' % ( ctime(), self.rfile.readline().decode('utf-8')), 'utf-8'))# 利用给定的主机信息和请求处理类创建了TCP服务器# 然后无限循环地等待并服务于客户端请求tcpServ = TCP(ADDR, MyRequestHandler)print('waiting for connection...')tcpServ.serve_forever() TCP客户端 12345678910111213141516171819202122232425#!usr/bin/python3# -*- coding:UTF-8 -*-from socket import *HOST = '127.0.0.1'PORT = 12345BUFSIZE = 1024ADDR = (HOST, PORT)while True: tcpSocket = socket(AF_INET, SOCK_STREAM) tcpSocket.connect(ADDR) data = input('&gt; ') if not data: break # 因为处理程序类对待套接字通信像文件一样，所以必须发送行终止符。 # 而服务器只是保留并重用这里发送的终止符 tcpSocket.send(bytes('%s\r\n' % data, 'utf-8')) data = tcpSocket.recv(BUFSIZE) if not data: break # 得到服务器返回的消息时，用strip()函数对其进行处理并使用print()自动提供的换行符 print(data.decode('utf-8').strip()) tcpSocket.close() socketserver TCP服务器和客户端运行结果 在客户端启动的时候连接了一次服务器，而每一次发送一个请求连接一次，所以发送了三个请求连接了四次服务器 TCP服务器运行结果 12345waiting for connection......connected from: (&apos;127.0.0.1&apos;, 51835)...connected from: (&apos;127.0.0.1&apos;, 51877)...connected from: (&apos;127.0.0.1&apos;, 51893)...connected from: (&apos;127.0.0.1&apos;, 51901) TCP客户端运行结果 1234567&gt; hello[Sat Feb 24 10:29:28 2018] hello&gt; hello[Sat Feb 24 10:29:44 2018] hello&gt; hi[Sat Feb 24 10:29:50 2018] hi&gt; Twisted框架的简单使用 Twisted是一个完整的事件驱动的网络框架，利用它既能使用也能开发完整的异步网络应用程序和协议。它不是Python标准库的一部分，所以需要单独下载和安装它1。 1pip3 install Twisted-17.9.0-cp36-cp36m-win_amd64.whl 安装成功显示 1234567891011Processing e:\迅雷下载\twisted-17.9.0-cp36-cp36m-win_amd64.whlRequirement already satisfied: Automat&gt;=0.3.0 in e:\python\python36\lib\site-packages (from Twisted==17.9.0)Requirement already satisfied: zope.interface&gt;=4.0.2 in e:\python\python36\lib\site-packages (from Twisted==17.9.0)Requirement already satisfied: incremental&gt;=16.10.1 in e:\python\python36\lib\site-packages (from Twisted==17.9.0)Requirement already satisfied: hyperlink&gt;=17.1.1 in e:\python\python36\lib\site-packages (from Twisted==17.9.0)Requirement already satisfied: constantly&gt;=15.1 in e:\python\python36\lib\site-packages (from Twisted==17.9.0)Requirement already satisfied: attrs in e:\python\python36\lib\site-packages (from Automat&gt;=0.3.0-&gt;Twisted==17.9.0)Requirement already satisfied: six in e:\python\python36\lib\site-packages (from Automat&gt;=0.3.0-&gt;Twisted==17.9.0)Requirement already satisfied: setuptools in e:\python\python36\lib\site-packages (from zope.interface&gt;=4.0.2-&gt;Twisted==17.9.0)Installing collected packages: TwistedSuccessfully installed Twisted-17.9.0 Twisted Reactor TCP 服务器/客户端TCP服务器 123456789101112131415161718192021222324252627282930313233#!usr/bin/python3# -*- coding:UTF-8 -*-# 常用模块导入，特别是twisted.internet的protocol和reactorfrom twisted.internet import protocol, reactorfrom time import ctime# 设置端口号PORT = 12345class TWServProtocol(protocol.Protocol): # 继承Protocol类 def connectionMade(self): # 重写connectionMade()方法 # 当一个客户端连接到服务器是会执行这个方法 client = self.client = self.transport.getPeer().host print('...connected from:', client) def dataReceived(self, data): # 重写dataReceived()方法 # 当服务器接收到客户端通过网络发送的一些数据的时候会调用此方法 self.transport.write(bytes('[%s] %s' % ( ctime(), data.decode('utf-8')), 'utf-8'))# 创建一个协议工厂，每次得到一个接入连接是，制造协议的一个实例# 在reactor中安装一个TCP监听器，以此检查服务请求# 当接收到一个请求时，就是创建一个就是创建一个TWServProtocol实例来处理客户端事务factory = protocol.Factory()factory.protocol = TWServProtocolprint('waiting for connection...')reactor.listenTCP(PORT, factory)reactor.run() TCP客户端 12345678910111213141516171819202122232425262728293031323334353637383940#!usr/bin/python# -*- coding:UTF-8 -*-from twisted.internet import protocol, reactorHOST = '127.0.0.1'PORT = 12345class TWClientProtocol(protocol.Protocol): def sendData(self): # 需要发送数据时调用 # 会在一个循环中继续，直到不输入任何内容来关闭连接 data = input('&gt; ') if data: print('...send %s...' % data) self.transport.write(bytes(data, 'utf-8')) else: self.transport.loseConnection() def connectionMade(self): # self.sendData() def dataReceived(self, data): print(data.decode('utf-8')) self.sendData()class TWClientFactory(protocol.ClientFactory): # 创建了一个客户端工厂 protocol = TWClientProtocol clientConnectionLost = clientConnectionFailed = \ lambda self, connector, reason: reactor.stop()# 创建了一个到服务器的连接并运行reactor，实例化了客户端工厂# 因为这里不是服务器，需要等待客户端与我们通信# 并且这个工厂为每一次连接都创建一个新的协议对象。# 客户端创建单个连接到服务器的协议对象，而服务器的工厂则创建一个来与客户端通信reactor.connectTCP(HOST, PORT, TWClientFactory())reactor.run() TCP服务器和客户端运行结果 服务器结果 12waiting for connection......connected from: 127.0.0.1 客户端结果 1234567&gt; hello...send hello...[Sat Feb 24 11:19:49 2018] hello&gt; hi...send hi...[Sat Feb 24 11:20:02 2018] hi&gt; 1.需要安装python对应的版本和位数 ↩]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python网络编程(一)]]></title>
    <url>%2F2018%2F02%2F22%2FPython%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[使用Python的一些模块来创建网络应用程序 socket()函数模块要创建套接字，必须使用socket.socket()函数socket(socket_family, socket_type, protocol = 0),其中socket_family是 AF_UNIX 或 AF_INET,socket_type是 SOCK_STREAM 或 SOCK_DGRAM。1protocol通常省略，默认为0。 创建TCP/IP套接字 1tcpSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 创建UDP/IP套接字 1udpSock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) 套接字对象内接方法 名称 描述 服务器套接字方法 s.bind() 将地址(主机名、端口号对)绑定到套接字上 s.listen() 设置并启动TCP监听器 s.accept() 被动接受TCP客户端连接，一直等待知道连接到达(阻塞) 客户端套接字方法 s.connect() 主动发起TCP服务器连接 s.connect_ex() connect()的扩展版本，此时会以错误码的形式返回问题，而不是抛出一个异常 普通的套接字方法 s.recv() 接受TCP消息 s.recv_into() 接受TCP消息到指定的缓冲区 s.send() 发送TCP消息 s.sendall() 完整地发送TCP消息 s.recvfrom() 接受UDP消息 s.recvfrom_into() 接受UDP消息到指定的缓冲区 s.sendto() 发送UDP消息 s.getpeername() 连接到套接字(TCP)的远程地址 s.getsockname() 当前套接字的地址 s.getsockopt() 返回给定套接字选项的值 s.setsockopt() 设置给定套接字选项的值 s.shutdown() 关闭连接 s.close() 关闭套接字 s.detach() 在未关闭文件描述符的情况下关闭套接字，返回文件描述符 s.ioctl() 控制套接字的模式(仅支持Windows) 面向阻塞的套接字方法 s.setblocking() 设置套接字的阻塞或非阻塞模式 s.settimeout() 设置阻塞套接字操作的超时时间 s.gettimeout() 获取阻塞套接字操作的超时时间 面向文件的套接字方法 s.fileno() 套接字的文件描述符 s.makefile() 创建与套接字关联的文件对象 数据属性 s.family 套接字家族 s.type 套接字类型 s.proto 套接字协议 socket模块属性 属性名称 描述 数据属性 AF_UNIX、AF_INET、AF_INET6、AF_NETLINK、AF_TIPC Python中支持的套接字地址家族 SO_STREAM、SO_DGRAM 套接字类型(TCP=流，UDP=数据报) has_ipv6 指示是否支持IPv6的布尔标记 异常 error 套接字相关错误 herror 主机和地址相关错误 gaierror 地址相关错误 timeout 超时时间 函数 socket() 以给定的地址家族、套接字类型和协议类型(可选) 创建一个套接字对象 socketpair() 以给定的地址家族、套接字类型和协议类型(可选) 创建一个套接字对象 create_connection() 常规函数，它接收一个地址(主机号，端口号)对，返回套接字对象 fromfd() 以一个打开的文件描述符创建一个套接字对象 ssl() 通过套接字启动一个安全套接字层连接；不执行证书验证 getaddrinfo() 获取一个五元组序列形式的地址信息 getnameinfo() 给定一个套接字地址，返回(主机名，端口号)二元组 getfqdn() 返回完整的域名 gethostname() 返回当前主机名 gethostbyname() 将一个主机名映射到它的IP地址 gethostbyname_ex() gethostbyname()的扩展版本，它返回主机名、别名主机集合和IP地址列表 gethostbyaddr() 讲一个IP地址映射到DNS信息；返回与gethostbyname_ex()相同的三元组 getprotobyname() 将一个协议名(如‘TCP’)映射到一个数字 getservbyname()/getservbyport() 将一个服务名映射到一个端口号，或者反过来；对于任何一个函数来说，协议名都是可选的 ntohl()/ntohs() 将来自网络的整数装换为主机字节序 htonl()/htons() 将来自主机的整数转换为网络字节序 inet_aton()/inet_ntoa() 将IP地址八进制字符串转换成32位的包格式，或者反过来(仅用于IPv4地址) inet_pton()/inet_ntop() 将IP地址字符串转换成打包的二进制格式，或者反过来(同时适用于IPv4和IPv6) getdefaulttimeout()/setdefaulttimeout() 以秒(浮点数)为单位返回默认套接字超时时间；以秒(浮点数)为单位设置默认套接字超时时间 详情参阅socket模块文档 创建TCP服务器/客户端TCP服务器 下面是TCP服务器端的通用伪码，这是设计服务器的一种方式，可根据需求修改来操作服务器 123456789ss = socket() #创建服务器套接字ss.bind() #套接字与地址绑定ss.listen() #监听连接inf_loop: #服务器无线循环 cs = ss.accept() #接受客户端连接 comm_loop: #通信循环 cs.recv()/cs.send() #对话(接收/发送) cs.close() #关闭客户端套接字ss.close() #关闭服务器套接字 TCP时间戳服务器 12345678910111213141516171819202122232425262728293031323334353637383940#!usr/bin/python3# -*- coding:UTF-8 -*-# 导入socket模块和time.ctime()的所有属性from socket import *from time import ctime# HOST变量是空白，这是对bind()方法的标识，标识它可以使用任何可用的地址# 选择一个随机的端口号# 缓冲区大小为1KBHOST = ''PORT = 12345BUFSIZE = 1024ADDR = (HOST, PORT)# 分配了TCP服务套接字# 将套接字绑定到服务器地址# 开启TCP的监听调用# listen()方法的参数是在连接被转接或拒绝之前，传入连接请求的最大数tcpSerSock = socket(AF_INET, SOCK_STREAM)tcpSerSock.bind(ADDR)tcpSerSock.listen(5)while True: # 服务器循环，等待客户端的连接的连接 print('waiting for connection...') tcpCliSock, addr = tcpSerSock.accept() print('...connected from:', addr) while True: # 当一个连接请求出现时，进入对话循环，接收消息 data = tcpCliSock.recv(BUFSIZE) if not data: # 当消息为空时，退出对话循环 # 关闭客户端连接，等待下一个连接请求 break tcpCliSock.send(bytes('[%s] %s' % ( ctime(), data.decode('utf-8')), 'utf-8')) tcpCliSock.close() TCP客户端 下面是TCP客户端的通用伪码 12345cs = socket() #创建客户端套接字cs.connect() #尝试连接服务器comm_loop: #通信循环 cs.send()/cs.recv #对话(发送/接收)cs.close() #关闭客户端套接字 TCP时间戳客户端 1234567891011121314151617181920212223242526272829303132333435#!usr/bin/python3# -*- coding: UTF-8 -*-# 导入socket模块所有属性from socket import *# 服务器的主机名# 服务器的端口号,应与服务器设置的完全相同# 缓冲区大小为1KBHOST = '127.0.0.1'PORT = 12345BUFSIZE = 1024ADDR = (HOST, PORT)# 分配了TCP客户端套接字# 主动调用并连接到服务器tcpCliSock = socket(AF_INET, SOCK_STREAM)tcpCliSock.connect(ADDR)while True: # 无限循环，输入消息 data = bytes(input('&gt; '), 'utf-8') if not data: # 消息为空则退出循环 break # 发送输入的信息 # 接收服务器返回的信息，最后打印 tcpCliSock.send(data) data = tcpCliSock.recv(BUFSIZE) if not data: # 消息为空则退出循环 break print(data.decode('utf-8'))# 关闭客户端tcpCliSock.close() TCP服务器和客户端运行结果 在运行程序时，必须 首先运行服务器 程序，然后再运行客户端程序。如果先运行客户端程序，将会报未连接到服务器的错误。 按正确的顺序启动程序后，在客户端输入信息，将会接收到加上时间戳处理后的信息，如果直接输入回车，将会关闭客户端，而服务器将会等待下一个连接请求 服务器运行结果 123waiting for connection......connected from: (&apos;127.0.0.1&apos;, 53220)waiting for connection... 客户端运行结果 12345678&gt; hello[Fri Feb 23 14:22:58 2018] hello&gt; hi[Fri Feb 23 14:23:02 2018] hi&gt; hello world[Fri Feb 23 14:23:09 2018] hello world&gt;Process finished with exit code 0 创建UDP服务器/客户端UDP服务器 下面是UDP服务器的伪码 12345ss = socket() #创建服务器套接字ss.bind() #绑定服务器套接字inf_loop: #服务器无线循环 cs = ss.recvfrom()/ss.sendto() #关闭(接收/发送)ss.close() #关闭服务器套接字 UDP时间戳服务器 1234567891011121314151617181920212223#!usr/bin/python3# -*- coding:UTF-8 -*-# 导入socket模块和time.ctime()的全部属性from socket import *from time import ctime# 与TCP相同，由于是无连接，所以没有调用监听传入连接HOST = ''PORT = 12345BUFSIZE = 1024ADDR = (HOST, PORT)udpSerSock = socket(AF_INET, SOCK_DGRAM)udpSerSock.bind(ADDR)while True: # 进入循环等待消息，一条消息到达时，处理并返回它，然后等待下一条消息 print('waiting for message...') data, addr = udpSerSock.recvfrom(BUFSIZE) udpSerSock.sendto(bytes('[%s] %s' % ( ctime(), data.decode('utf-8')), 'utf-8'), addr) print('...received from and returned to:', addr) UDP客户端 下面是客户端的伪码 1234cs = socket() #创建客户端套接字comm_loop: #通信循环 cs.sendto()/cs.recvfrom() #对话(发送/接收)cs.close() #关闭客户端套接字 UDP时间戳客户端 12345678910111213141516171819202122#!usr/bin/python3 # -*- coding:UTF-8 -*- from socket import * HOST = '127.0.0.1' PORT = 12345 BUFSIZE = 1024 ADDR = (HOST, PORT) udpClienSock = socket(AF_INET, SOCK_DGRAM) while True: data = bytes(input('&gt;'), 'utf-8') if not data: break udpClienSock.sendto(data, ADDR) data, ADDR = udpClienSock.recvfrom(BUFSIZE) if not data: break print(data.decode('utf-8')) udpClienSock.close() UDP服务器和客户端运行结果 因为UDP面向无连接的服务，所以程序的启动顺序没有要求。当服务器处理完一个数据报之后在等待下一个继续处理 服务器运行结果 12345waiting for message......received from and returned to: (&apos;127.0.0.1&apos;, 51434)waiting for message......received from and returned to: (&apos;127.0.0.1&apos;, 51434)waiting for message... 客户端运行结果 1234567&gt;hello[Fri Feb 23 15:23:57 2018] hello&gt;hi[Fri Feb 23 15:24:03 2018] hi&gt;Process finished with exit code 0 1.AF_UNIX 是基于文件的套接字，代表 地址家族(address family):UNIX，AF_INET 是基于网络的套接字，代表 地址家族：因特网， AF_INET6 用于底6版因特网协议(IPv6)寻址。 SOCK_STREAM 表示面向连接的TCP套接字， SOCK_DGRAM 代表无连接的UDP套接字。 ↩]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python正则表达式(三)]]></title>
    <url>%2F2018%2F02%2F12%2FPython%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[在之前的两篇博文中，已经对正则表达式基本及核心的知识点进行了罗列和总结。而对于正则表达式的使用却缺乏实践。本文将基于《Python核心编程(第三版)》的练习题进行一些练习。 正则表达式 识别后续的字符串：“bat”、“bit”、“but”、“hat”、“hit”或者“hut”。 1234567891011121314import remode = re.compile(r'bat|bit|but|hat|hit|hut')#mode = re.compile(r'[bh][iau]t')strs = ['bat', 'bit', 'but', 'hat', 'hit', 'hut']for s in strs: if mode.match(s) is not None:mode.match(s).group()#输出结果'bat''bit''but''hat''hit''hut' 匹配由单个空格分隔的任意单词对，也就是姓和名。 12345678import remode = re.compile(r'^[A-Za-z]+ [A-Za-z]+$')strs = ['david Bob', 'D.Jone Steven', 'Lucy D May']for s in strs: if mode.match(s) is not None:mode.match(s).group()#输出结果'david Bob' 匹配由单个逗号和单个空白符分隔的任何单词和单个字母，如姓氏的首字母。 123456789import remode = re.compile(r'[A-Za-z]+,\s[A-Za-z]+')strs = ['david, Bob', 'D.Jone, Steven', 'Lucy, D, May']for s in strs: if mode.match(s) is not None:mode.match(s).group()#输出结果'david, Bob''Lucy, D' 匹配所有有效Python 标识符1的集合。 123456789101112import remode = re.compile(r'[^0-9][\w_]+')#用in排除关键字strs = ['1var', 'v_ar', '_var', 'var', 'var_9', 'var_']for s in strs: if mode.match(s) is not None:mode.match(s).group()#输出结果'v_ar''_var''var''var_9''var_' 根据读者当地的格式，匹配街道地址（使你的正则表达式足够通用，来匹配任意数量的街道单词，包括类型名称）。例如，美国街道地址使用如下格式：1180 BordeauxDrive。使你的正则表达式足够灵活，以支持多单词的街道名称，如3120 De la CruzBoulevard。 123456789import remode = re.compile(r'^\d&#123;4&#125;( [A-Z][a-z]+)+$')strs = ['1221 Bordeaux Drive', '54565 Bordeaux Drive', 'Bordeaux Drive', '1221 Bordeaux Drive Drive']for s in strs: if mode.match(s) is not None:mode.match(s).group()#输出结果'1221 Bordeaux Drive''1221 Bordeaux Drive Drive' 匹配以“www”起始且以“.com”结尾的简单Web 域名；例如，www://www. yahoo.com/。选做题：你的正则表达式也可以支持其他高级域名，如.edu、.net 等（例如，http://www.foothill.edu）。 1234567891011import remode = re.compile(r'^(http[s]?://)?www\.(\w+\.)+(com|net|edu)$')strs=['https://www.baidu.com', 'http://www.bilibili.com', 'www.baidu.com', 'baidu.com', 'www.cqupt.edu']for s in strs: if mode.match(s) is not None:mode.match(s).group()#输出结果'https://www.baidu.com''http://www.bilibili.com''www.baidu.com''www.cqupt.edu' 匹配所有能够表示Python 整数的字符串集。 12345678910import remode = re.compile(r'^\d+[lL]?$')strs = ['123', '123l', '12312L']for s in strs: if mode.match(s) is not None:mode.match(s).group()#输出结果'123''123l''12312L' 匹配所有能够表示Python 长整数的字符串集。 123456789import remode = re.compile(r'^\d+[lL]$')strs = ['123', '123l', '12312L']for s in strs: if mode.match(s) is not None:mode.match(s).group()#输出结果'123l''12312L' 匹配所有能够表示Python 浮点数的字符串集。 12345678910import remode = re.compile(r'(0|[1-9]\d*)(\.\d+)?$')strs = ['00.10', '0.123', '12.23', '12', '12.36l']for s in strs: if mode.match(s) is not None:mode.match(s).group() #输出结果'0.123''12.23''12' 匹配所有能够表示Python 复数的字符串集。 12345678910import remode = re.compile(r'^((0|[1-9]\d*)(\.\d+)?\+)?((0|[1-9]\d*)(\.\d+)?j)?$')strs = ['12.3+1.2j', '1+2j', '4j']for s in strs: if mode.match(s) is not None:mode.match(s).group() #输出结果'12.3+1.2j''1+2j''4j' 匹配所有能够表示有效电子邮件地址的集合（从一个宽松的正则表达式开始，然后尝试使它尽可能严谨，不过要保持正确的功能）。 123456789101112import remode = re.compile(r'^\w+@(\w+\.)+(com|com\.cn|net)$')strs = ['12345@qq.com', 'sina@163.com', 'qq@sina.com.cn', 'net@21cn.com', 'new123@163.sina.com']for s in strs: if mode.match(s) is not None:mode.match(s).group() #输出结果'12345@qq.com''sina@163.com''qq@sina.com.cn''net@21cn.com''new123@163.sina.com' type()。内置函数type()返回一个类型对象，如下所示，该对象将表示为一个Pythonic类型的字符串。 12345678910import remode = re.compile(r'&lt;type \'(.*)\'&gt;')strs = ['&lt;type \'int\'&gt;', '&lt;type \'float\'&gt;', '&lt;type \'builtin_function_or_method\'&gt;']for s in strs: if mode.match(s) is not None:mode.match(s).group(1)#输出结果'int''float''builtin_function_or_method' 处理日期。1.2 节提供了来匹配单个或者两个数字字符串的正则表达式模式，来表示1～9 的月份(0?[1-9])。创建一个正则表达式来表示标准日历中剩余三个月的数字。 12345678910import remode = re.compile(r'1[0-2]')strs = ['10', '11', '12']for s in strs: if mode.match(s) is not None:mode.match(s).group()#输出结果'10''11''12' 创建一个允许使用连字符的正则表达式，但是仅能用于正确的位置。例如，15 位的信用卡号码使用4-6-5 的模式，表明4 个数字-连字符-6 个数字-连字符-5 个数字；16 位的信用卡号码使用4-4-4-4 的模式。 123456789import remode = re.compile(r'\d&#123;4&#125;-((\d&#123;6&#125;-\d&#123;5&#125;)|(\d&#123;4&#125;-\d&#123;4&#125;-\d&#123;4&#125;))')strs = ['1234-567890-12345', '1234-5678-8012-3456']for s in strs: if mode.match(s) is not None:mode.match(s).group()#输出结果'1234-567890-12345''1234-5678-8012-3456' 1.标识符有字母、数字、下划线组成，但不能由数字开头 ↩]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python正则表达式(二)]]></title>
    <url>%2F2018%2F02%2F10%2FPython%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[正则表达式的匹配规则基本已经在上一篇博文中全部罗列出来了，下面便是结合到具体语言进行学习和练习了。由于个人兴趣和想要专研的方向，在这里将会使用Python 1 语言进行描述。 正则表达式和Python语言re模块：核心函数和方法 函数方法 描述 仅仅是re函数模块 compile(pattern, flags=0) 使用任何可选的标记来编译正则表达式的模式，然后返回一个正则表达式对象 re模块函数和正则表达式对象的方法 match(pattern, string, flags=0) 尝试使用带有可选的标记的正则表达式的模式来匹配字符串，如果匹配成功，就返回匹配对象；如果失败，就返回None search(pattern, string, flags=0) 使用可选标记搜索字符串中第一次出现的正则表达式模式。如果匹配成功，则返回匹配对象；如果匹配失败，怎返回None findall(pattern, string [,flags]) 查找字符串中所有(非重复)出现的正则表达式模式，并返回一个匹配列表 finditer(pattern, string[,flags]) 与findall()函数相同，但返回的不是一个列表，而是一个迭代器。对于每一次匹配，迭代器都返回一个匹配对象 split(pattern, string, max=0) 根据正则表达式的模式分隔符，split函数将字符串分割为列表，然后返回成功的列表，分割最多操作max次(默认分割所有匹配成功的位置) sub(pattern, repl, string, count=0) 使用repl替换所有正则表达式的模式在字符串中出现的位置，除非定义count，否则就讲替换所有出现的位置（另见subn()函数，该函数返回替换操作的数目） purge() 清除隐式编译的正则表达式模式 常见的匹配对象方法 group(num=0) 返回整个匹配对象，或者编号为num的特定子组 groups(default=None) 返回一个包含所有匹配子组的元组(如果没有成功匹配，则返回一个空元组) groupdict(default=None) 返回一个包含所有匹配的命名子组的字典，所有的子组名称作为字典的键(如果没有成功匹配，则返回一个空字典) 常用的模块属性（用于大多数正则表达式函数的标记） re.I,re.IGNORECASE 不去分大小写的匹配 re.L,re.LOCALE 根据所使用的本地语言环境通过\w、\w、\b、\B、\s、\S实现匹配 re.M,re.MULTILINE ^和$分别匹配目标字符串中行的起始和结尾，而不是严格匹配整个字符串本身的起始和结尾 re.S,re.DOTALL “.”(点号)通常匹配除了\n(换行符)之外的所有单个字符：该标记表示”.”(点号)能匹配全部字符 re.X,re.VERBOSE 通过反斜线转移，否则所有空格加上#(以及在该行中后续文字)都被忽略，除非在一个字符类中或者允许注释并且提高可读性 部分方法总结 compile(pattern, flags=0)2 使用预编译使用推荐的方式，但不是必须的，可以通过设置标志位(上表已罗列出使用频繁的标记，详情可以查阅文档),标志位通过 （|）合并 group(num=0) 和 groups(default=None) 匹配对象3的两个主要方法。 group() 要么返回整个匹配对象，要么按要求返回特定子组。 groups() 仅返回一个包含唯一或全部子组的元组。如果没有子组的要求，group() 返回整个匹配，groups() 返回一个空元组。 match(pattern, string, flags=0) match() 方法试图从字符串的起始部分对模式进行匹配。如果匹配成功，返回一个匹配对象；如果失败就返回None 12345678910111213 #匹配成功 m = re.match('foo', 'foo') #模式匹配字符串 if m is not None: #如果匹配成功，就输出匹配内容 m.group()'foo' #输出结果#匹配失败m = re.match('foo', 'Bfoo') #模式匹配字符串if m is not None: #如果匹配成功，就输出匹配内容 m.group() #因为起始字符为'B',所以匹配不成功，无任何输出 search(pattern, string, flags=0) search() 的工作方式和 match() 相同，不同之处在于 search() 会用它的字符串参数在任意位置对给定正则表达式模式搜索第一次出现的匹配情况。如果搜索到成功的匹配，就返回一个匹配对象；否则，就返回None。 123456#将上面使用match()方法匹配的串改用search()匹配m = re.search('foo', 'Bfoo') #模式匹配字符串if m is not None: #如果匹配成功，就输出匹配内容 m.group()'foo' #可以看到就算起始位置未能匹配，也能匹配成功 findall(pattern, string[,flags]) 和 finditer(pattern, string[,flags]) findall() 总是返回一个列表，如果没有找到匹配对象，返回一个空列表 finditer() 是一个与 findall() 类似但更节省内存的变体，finditer() 在匹配对象中迭代4 1234567891011121314#findall()匹配re.findall('car', 'carry the barcardi to the car') #模式匹配字符串['car', 'car', 'car'] #返回结果#finditer()匹配iter = re.finditer('car', 'carry the barcardi to the car') #模式匹配字符串for i in iter: #遍历迭代器 print(i.group())#输出结果carcarcar sub(pattern, repl, string, count=0) 和 subn(pattern, repl, string, count=0) sub() 和 subn() 用于实现搜索和替换功能。两者都是将某字符串中所有匹配正则表达式的部分进行某种形式的替换。和 sub() 不同的是，subn() 返回一个表示替换的总数，替换后的字符串和表示替换总数的数字一起作为一个拥有两个元素的元组返回 12345678910#sub()re.sub('car', 'cat', 'My car is not only a car.') #模式匹配字符串'My cat is not only a cat.' #输出结果#subn()re.subn('car', 'cat', 'My car is not only a car.') #模式匹配字符串('My cat is not only a cat.', 2) #输出结果 split(pattern, string, max=0) 正则表达式对象的 split() 方法和字符串的工作方式类似，但它是基于正则表达式的模式分割字符串。 123456789101112131415161718192021222324re.split(':', 'str1:str2:str3') #模式匹配字符串['str1', 'str2', 'str3'] #输出结果，与'str1:str2:str3'.split(':')相同#split()复杂用法#使用split()基于逗号分割字符串，如果空格紧跟在5个数字或者两个大写字母之后，就用split()分割该空格#使用(?=)正向前视断言，不适用输入字符串 而是使用后面的空格作为分割字符串import reDATA = ( 'Mountain View, CA 94040', 'Sunnyvale, CA', 'Los Altos, 94023', 'Cupertino 95014', 'Palo Alto CA',)for datum in DATA: print(re.split(', |(?= (?:\d&#123;5&#125;|[A-Z]&#123;2&#125;)) ', datum))#输出结果['Mountain View', 'CA', '94040']['Sunnyvale', 'CA']['Los Altos', '94023']['Cupertino', '95014']['Palo Alto', 'CA'] 符号的使用| 与 . 和 [] 包括择一匹配符号|、点号.，点号不匹配非字符或换行付\n（即空字符） 字符集[]中的字符只取其一 重复、特殊字符5以及分组 ?操作符表示前面的模式出现零次或一次+操作符表示前面的模式出现至少一次*操作符表示前面的模式出现任意次(包括0次)分组从左起第一个括号开始算第一个分组 123456789101112131415m = re.match('(\w(\w\w))-(\d\d\d)','abc-123')m.group() #完整匹配'abc-123' #输出结果m.group(1) #第一组'abc' #输出结果 m.group(2) #第二组'bc' #输出结果m.group(3) #第三组'123' #输出结果m.groups() #全部子组('abc', 'bc', '123') #输出结果 1.这里Python指代的是Python3.6.4 ↩2.预编译可以提升执行效率，而 re.compile() 方法提供了这个功能。模块函数会对已编译的对象进行缓存，所以无论使用 match() 和 search() 在执行时编译的正则表达式,还是使用 compile() 编译的表达式,在再次使用时都会查询缓存。但使用 compile() 同样可以节省查询缓存的时间 ↩3.除了正则表达式对象之外，还有另外一个对象类型：匹配对象。这些是成功调用 match() 和 search() 返回的对象。 ↩4.如果遇到无法调用 next()方法，可以使用 __next__()方法代替。 ↩5.特殊字符的详情可以参考上一篇博文 ↩]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python正则表达式(一)]]></title>
    <url>%2F2018%2F02%2F09%2FPython%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[在Python的学习过程中，正则表达式始终是一道绕不过去的坎.无论提取服务器日志文件还是爬取网页，正则表达式始终扮演着至关重要的角色。下面便对自己学习过程中的一些正则表达式基础做一个总结。 特殊符号和字符 表示法 描述 正则表达式示例 备注 符号 literal 匹配文本字符串的字面值literal foo 只是匹配foo，相当于取等 re1&#124; re2 匹配正则表达式re1或re2 foo&#124; bar 匹配foo或者bar，二选一 . 匹配任何字符(除了\n之外) a.a 匹配axa、aaa、aca等，两个a中间可以是除了\n的任意字符 ^ 匹配字符串起始部分 ^Foo 匹配Foo，不匹配aFoo $ 匹配字符串终止部分 Bar$ 只匹配Bar,不匹配aBar等 * 匹配0次或者多次前面出现的正则表达式 [A-Za-z0-9]* 匹配任意多个字母或数字 + 匹配1次或者多次前面出现的正则表达式 [A-Za-z0-9]+ 匹配一到多个个字母或数字 ? 匹配0次或者1次前面出现的正则表达式 [A-Za-z0-9] 要么有一个字母或数字要么没有 {N} 匹配N次前面出现的正则表达式 [0-9]{3} 匹配三个数字 {M,N} 匹配M~N次前面出现的正则表达式 [0-9]{5,9} 匹配5到9个数字(包括5个和9个) […] 匹配来自字符集的任意单一字符 [aeiou] 匹配一个元音字母 [..x~y..] 匹配x~y范围内的任意单一字符 [A-Za-z] 匹配任意一个英文字母 [^…] 不匹配此字符集中出现的任何一个字符，包括某一范围的字符(如果在此字符集中出现) [\^aeiou][\^A-Za-z0-9] 匹配一个非元音字母和一个非字母数字字符 (*&#124;+&#124;?&#124;{})? 用于匹配上面频繁出现/重复出现符号的非贪婪版本(*、+、?、{}) .*?[a-z] (非贪婪是指尽可能少的匹配) (…) 匹配封闭的正则表达式,然后另存为子组 f(oo&#124; u)bar 匹配foobar,fubar 特殊字符 \d 匹配任何十进制数字，与[0-9]一致(\D和\d相反，不匹配任何非数值型的数字) data\d+.txt 匹配data1.txt、data12.txt \w 匹配任何字母数字字符，与[A-Za-z0-9]相同(\W与之相反) [A-Za-z_]\w+ 匹配任意字母或_加一个或多个字母数字字符(asda,_asda) \s 匹配任何空格字符，与[\n\t\r\v\f]相同(\S与之相反) of\sthe 匹配of the (\n:换行符&#124;\t:水平制表符&#124;\r:回车&#124;\v:垂直制表符&#124;\f:换页符) \b 匹配任何单词边界(\B与之相反) \bThe\b 匹配of The a，不匹配ofThe a \N 匹配已保存的子组N(与上面(…)配合使用) price:\16 匹配price:和前面第16个子组的值 \c 逐字匹配任何特殊字符(即仅按字面意义匹配，不包含特殊含义，\为对特殊字符的转义表示) * 匹配* \A(\Z) 匹配字符串的起始(结束)(另见上面的^和$) \ADear 匹配以Dear开头的 扩展表示法 （?iLmsux） 在正则表达式中嵌入一个或多个特殊”标记”参数(或者通过函数/方法) （?x）,(?im) (?:…) 表示一个匹配不用保存的分组 (?:\w+.)* 匹配任意多个一个或多个字母数字字符与.的组合但不保存改分组 (?P…) 像一个仅由name标识而不是数字ID标识的正则分组匹配 (?P) 给匹配的分组命名为data (?P=name) 在同一个字符串中匹配由(?P)分组之前的文本 (?P=data) 匹配名字为data的串 (?#…) 表示注释，所有内容都被忽略 (?#comment) (?=…) 匹配条件是如果…出现在之后的位置，而不使用输入字符串；称作正向前视断言 (?=.com) 如果一个字符串后面跟着“.com”才做匹配操作，并不适用任何目标字符串 (?!…) 匹配条件是如果…不出现在之后的位置，而不使用输入字符串；称作负向前视断言 (?!.net) 如果一个字符串后面不是跟着“.net”，才做匹配操作 (?&lt;=…) 匹配条件是如果…出现在之前的位置，而不使用输入字符串；称作正向后视断言 (?&lt;=800-) 如果字符串之前为“800-”才做匹配，并不使用任何输入字符串 (?&lt;!…) 匹配条件是如果…不出现在之前的位置，而不使用输入字符串；称作负向后视断言 (?&lt;!192\.168\.) 如果一个字符串之前不是“192.168.”才做匹配，并不适用任何输入字符串 (?(id/name)Y&#124;N 如果分组所提供的id或name(名称)存在，就返回正则表达式的条件匹配Y，如果不存在，就返回N;N是可选项 (?(1)y&#124;x) 如果一个匹配组1(\1)存在就y匹配；否则，就与x匹配 以上为正则表达式的一些基本的符号定义与用法，熟练掌握这些符号是写出高效表达式的基础。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
</search>
