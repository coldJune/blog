<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[全双工聊天室]]></title>
    <url>%2F2018%2F03%2F04%2F%E5%85%A8%E5%8F%8C%E5%B7%A5%E8%81%8A%E5%A4%A9%E5%AE%A4%2F</url>
    <content type="text"><![CDATA[在前面的学习中，学习了正则表达式、多线程、网络编程、数据库等相关知识点。这里结合多线程、网络编程、GUI等相关内容实现了一个全双工的聊天室。 设计思路 GUI部分框架的搭建，并编写通用部分代码，完成显示部分的基类 客户端和服务器对GUI基类进行扩展，用于显示各自特有的内容 编程线程的通用类，使所有线程的实现都通过该类，便于统一管理 完成客户端和服务器端的代码并进行整合调试 实现代码GUI的基类 chat_base.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#!/usr/bin/python3# -*- coding:UTF-8 -*-import tkinter as tkclass ChatWindowBase(object): # 窗口的基类，创建通用的窗口布局 def __init__(self): # 初始化方法 # 创建tkinter.TK()顶层窗口 # 所有主要控件都是构建在顶层窗口对象之上 # 通过tkinter.TK()创建 self.top = tk.Tk() # 在顶层窗口上添加Label控件 self.label = tk.Label(self.top, text='聊天室') # 通过Packer来管理和显示控件 # 调用pack()方法显示布局 self.label.pack() # 通过Frame控件创建子容器，用于存放其他控件 # 该对象将作为单个子对象代替父对象 self.chatfm = tk.Frame(self.top) # Scrollbar可以让显示的数据在超过Listbox的大小时能够移动列表 self.chatsb = tk.Scrollbar(self.chatfm) # 将Scrollbar放置在子容器的右侧，并且是针对y轴 self.chatsb.pack(side='right', fill='y') # 在子容器中创建高为15宽为50的Listbox # 将Listbox和Scrollbar关联起来 # 显示列表 # 显示子容器 # 控件的显示应该内部控件先显示，再显示外部控件 self.chats = tk.Listbox(self.chatfm, height=15, width=50, yscrollcommand=self.chatsb.set) self.chatsb.config(command=self.chats.yview()) self.chats.pack(side='left', fill='both') self.chatfm.pack() # 创建发送消息的子容器 self.sendfm = tk.Frame(self.top, width=50) # 创建输入框 # 绑定回车键，并且绑定send方法 # 绑定一个方法是指在触发一个事件时会去调用的方法 self.chatn = tk.Entry(self.sendfm, width=40) self.chatn.bind('&lt;Return&gt;', self.send) self.chatn.pack(side='left') # 添加按钮控件、绑定方法 self.sendchat = tk.Button(self.sendfm, text='发送', command=self.send) self.sendchat.pack(side='right', fill='both') self.sendfm.pack() def send(self, ev=None): # 创建发送消息的方法 # 空实现是为了继承时扩展 pass def receive(self): # 创建接受消息的方法 # 空实现是为了继承时扩展 pass 线程的通用类 chat_thread.py 123456789101112131415161718#!/usr/bin/python3# -*- coding:UTF-8 -*-import threadingclass ChatThread(threading.Thread): # 继承自threading.Thread，用于创建聊天室的通用线程 def __init__(self, func, args): # func: 方法 # args：方法所需要的参数 threading.Thread.__init__(self) self.func = func self.args = args def run(self): # 实现run方法，将参数传给相应的方法 self.func(*self.args) 服务端 chat_s.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#!/usr/bin/python3# -*- coding:UTF-8 -*-from chat_base import ChatWindowBasefrom chat_thread import ChatThreadfrom socket import *from time import ctimeimport tkinterHOST = ''PORT = 12345ADDR = (HOST, PORT)BUFSIZ = 1024class ChatS(ChatWindowBase): # 服务器的实现类，继承自ChatWindowBase def __init__(self): # 调用父类的__init__()方法 super(ChatS, self).__init__() self.label.configure(text='服务器') # 设置属性 # 用于保存客户端链接对象 # 用于保存客户端链接地址 self.send_sock = None self.addr = '' # 在服务器窗口创建时调用 self.receive() def send(self, ev=None): # 获取输入框信息 message = self.chatn.get() # 启动线程 ChatThread(self.send_s, (message,)).start() # 将输入框信息按照格式显示在Listbox self.chats.insert('end', '[%s]:to %s\n' % (ctime(), self.addr)) self.chats.insert('end', '%s' % message) # 删除输入框内容 self.chatn.delete(first=0, last=len(message)+1) def receive(self): # 创建socket链接 # 绑定地址 # 设置监听 # 阻塞直到有链接调用，然后保存链接的客户端对象和地址 sock = socket(AF_INET, SOCK_STREAM) sock.bind(ADDR) sock.listen(5) cli_sock, addr = sock.accept() self.addr = addr self.send_sock = cli_sock print('addr', addr) # 有链接接入时在Listbox中显示消息 self.chats.insert('end', '%s 上线' % str(addr)) # 更新顶层窗口 self.top.update() # 启动接受消息的线程 ChatThread(self.receive_s, (cli_sock, addr)).start() def send_s(self, message): # 向客户端发送消息 self.send_sock.send(bytes(message, 'utf-8')) def receive_s(self, cli_sock, addr): # 接受消息 # cli_sock: 客户端sock # addr: 客户端地址 while True: # 进入无限循环接受消息，并在Listbox显示消息 receiveData = cli_sock.recv(BUFSIZ) print('接受到消息', receiveData.decode('utf-8')) self.chats.insert('end', '[%s]:from %s' % (ctime(), addr)) self.chats.insert('end', '%s' % receiveData.decode('utf-8')) self.top.update()def main(): # 创建服务器窗口 s = ChatS() # 调用mainloop()运行整个GUI tkinter.mainloop()if __name__ == '__main__': main() 客户端 chat_c.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#!/usr/bin/python3# -*- coding:UTF-8 -*-from chat_base import ChatWindowBasefrom chat_thread import ChatThreadfrom socket import *from time import ctimeimport tkinterHOST = '127.0.0.1'PORT = 12345ADDR = (HOST, PORT)BUFSIZ = 1024class ChatC(ChatWindowBase): # 客户端的实现类，继承子ChatWindowBase方法 def __init__(self): # 初始化方法 # 在子类中必须调用父类的__init__()方法 super(ChatC, self).__init__() # 设置label的标题 self.label.configure(text='客户端') # 设置属性，用于保存sock对象用于发送和接受消息 self.sock = None # 在创建窗口时链接服务器， # 客户端需要比服务器后创建 # 否则链接会创建失败 self.receive() def send(self, ev=None): # 继承自父类，为控件调用的方法 # 获取输入框的值 message = self.chatn.get() # 创建发送消息的线程 # 将方法和方法需要的参数用作线程初始化，并启动线程 ChatThread(self.send_c, (message,)).start() # 在Listbox中按格式显示消息 self.chats.insert('end', '[%s]:to %s' % (ctime(), ADDR)) self.chats.insert('end', '%s' % message) # 删除输入框中的消息 self.chatn.delete(first=0, last=len(message)+1) # 通过更新顶层窗口显示消息 self.top.update() def receive(self): # 继承自父类 # 创建socket链接 self.sock = socket(AF_INET, SOCK_STREAM) self.sock.connect(ADDR) # 启动线程 # 将方法和方法需要的参数用作线程初始化，并启动线程 ChatThread(self.receive_c, (self.sock,)).start() def send_c(self, message): # 调用sock的send方法，向服务器发送消息 self.sock.send(bytes(message, 'utf-8')) def receive_c(self, sock): # 接受服务器数据的方法 while True: # 进入循环，等待服务器发送的消息 data = sock.recv(BUFSIZ) # 将消息按照格式显示到Listbox中 self.chats.insert('end', '[%s]:from %s' % (ctime(), ADDR)) self.chats.insert('end', '%s' % data.decode('utf-8')) # 更新控件 self.top.update()def main(): # 实例化客户端窗口 c = ChatC() # 调用mainloop方法运行整个GUI tkinter.mainloop()if __name__ == '__main__': main() 源代码]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>多线程</tag>
        <tag>网络编程</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python数据库编程(二)]]></title>
    <url>%2F2018%2F02%2F28%2FPython%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[上一篇中主要对直接操作数据库做了一个比较详细的总结，这里将会对使用ORM框架进行简要的描述。 ORMORM系统的作者将纯SQL语句进行了抽象化处理，将其实现为Python中的对象，这样只操作这些对象就能完成与生成SQL语句相同的任务。 python与ORMSQLAlchemy和SQLObject是两种不同的Python ORM。这两种ORM并不在Python标准库中，所以需要安装。 安装SQLAlchemypip3 install sqlalchemy 安装SQLObjectpip3 install -U SQLObject 在这里将会通过两种ORM移植上一篇的数据库适配器示例应用 SQLAlchemy SQLAlchemy相比于SQLObject的接口更加接近于SQL语句。SQLAlchemy中对象的抽象化十分完成，还可以以更好的灵活性提交原生的SQL语句 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#!/usr/bin/python3# -*- coding:UTF-8 -*-# 首先导入标准库中的模块(os.path、random)# 然后是第三方或外部模块(sqlalchemy)# 最后是应用的本地模块(ushuffleDB)from os.path import dirnamefrom random import randrange as randfrom sqlalchemy import Column, Integer, \ String, create_engine, exc, ormfrom sqlalchemy.ext.declarative \ import declarative_basefrom ushuffleDB import DBNAME, NAMELEN, \ randName, FIELDS, tformat, cformat, setup# 数据库类型+数据库驱动名称://用户名:密码@地址:端口号/数据库名称DSNs = &#123; 'mysql': 'mysql+pymysql://root:root@localhost:3306/%s' % DBNAME, 'sqlite': 'sqlite:///:memory:',&#125;# 使用SQLAlchemy的声明层# 使用导入的sqlalchemy.ext.declarative.declarative_base# 创建一个Base类Base = declarative_base()class Users(Base): # 数据子类 # __tablename__定义了映射的数据库表名 __tablename__ = 'users' # 列的属性，可以查阅文档来获取所有支持的数据类型 login = Column(String(NAMELEN)) userid = Column(Integer, primary_key=True) projid = Column(Integer) def __str__(self): # 用于返回易于阅读的数据行的字符串格式 return ''.join(map(tformat, (self.login, self.userid, self.projid)))class SQLAlchemyTest(object): def __init__(self, dsn): # 类的初始化执行了所有可能的操作以便得到一个可用的数据库，然后保存其连接 # 通过设置echo参数查看ORM生成的SQL语句 # create_engine('sqlite:///:memory:', echo=True) try: eng = create_engine(dsn) except ImportError: raise RuntimeError() try: eng.connect() except exc.OperationalError: # 此处连接失败是因为数据库不存在造成的 # 使用dirname()来截取掉数据库名，并保留DSN中的剩余部分 # 使数据库的连接可以正常运行 # 这是一个典型的操作任务而不是面向应用的任务，所以使用原生SQL eng = create_engine(dirname(dsn)) eng.execute('CREATE DATABASE %s' % DBNAME).close() eng = create_engine(dsn) # 创建一个会话对象，用于管理单独的事务对象 # 当涉及一个或多个数据库操作时，可以保证所有要写入的数据都必须提交 # 然后将这个会话对象保存，并将用户的表和引擎作为实例属性一同保存下来 # 引擎和表的元数据进行了额外的绑定，使这张表的所有操作都会绑定到这个指定的引擎中 Session = orm.sessionmaker(bind=eng) self.ses = Session() self.users = Users.__table__ self.eng = self.users.metadata.bind = eng def insert(self): # session.add_all()使用迭代的方式产生一系列的插入操作 self.ses.add_all( Users(login=who, userid=userid, projid=rand(1, 5)) for who, userid in randName() ) # 决定是提交还是回滚 self.ses.commit() def update(self): fr = rand(1, 5) to = rand(1, 5) i = -1 # 会话查询的功能，使用query.filter_by()方法进行查找 users = self.ses.query(Users).filter_by(projid=fr).all() for i, user in enumerate(users): user.projid = to self.ses.commit() return fr, to, i+1 def delete(self): rm = rand(1, 5) i = -1 users = self.ses.query(Users).filter_by(projid=rm).all() for i, user in enumerate(users): self.ses.delete(user) self.ses.commit() return rm, i+1 def dbDump(self): # 在屏幕上显示正确的输出 print('\n%s' % ''.join(map(cformat, FIELDS))) users = self.ses.query(Users).all() for user in users: print(user) self.ses.commit() def __getattr__(self, attr): # __getattr__()可以避开创建drop()和create()方法 # __getattr__()只有在属性查找失败时才会被调用 # 当调用orm.drop()并发现没有这个方法时，就会调用getattr(orm, 'drop') # 此时调用__getattr__()，并且将属性名委托给self.users。结束期会发现 # slef.users存在一个drop属性，然后传递这个方法调用到self.users.drop()中 return getattr(self.users, attr) def finish(self): # 关闭连接 self.ses.connection().close()def main(): # 入口函数 print('\n***Connnect to %r database' % DBNAME) db = setup() if db not in DSNs: print('ERROR: %r not supported, exit' % db) return try: orm = SQLAlchemyTest(DSNs[db]) except RuntimeError: print('ERROR: %r not supported, exit' % db) return print('\n*** Create users table(drop old one if appl.') orm.drop(checkfirst=True) orm.create() print('\n***Insert namse into table') orm.insert() orm.dbDump() print('\n***Move users to a random group') fr, to, num = orm.update() print('\t(%d users moved) from (%d) to (%d))' % (num, fr, to)) orm.dbDump() print('\n***Randomly delete group') rm, num = orm.delete() print('\t(group #%d; %d users removed)' % (rm, num)) orm.dbDump() print('\n***Drop users table') orm.drop() print('***Close cxns') orm.finish()if __name__ == '__main__': main() mysql输出结果 123456789101112131415161718192021222324252627282930313233343536***Connnect to &apos;test&apos; databaseChoose a database system: (M)ySQL (S)QLiteEnter choice:M*** Create users table(drop old one if appl.***Insert namse into tableLOGIN USERID PROJID Bob 1234 1 Dave 4523 1 Angela 4567 3 ***Move users to a random group (2 users moved) from (1) to (4))LOGIN USERID PROJID Bob 1234 4 Dave 4523 4 Angela 4567 3 ***Randomly delete group (group #2; 0 users removed)LOGIN USERID PROJID Bob 1234 4 Dave 4523 4 Angela 4567 3 ***Drop users table***Close cxns SQLite输出结果 1234567891011121314151617181920212223242526272829303132333435***Connnect to &apos;test&apos; databaseChoose a database system: (M)ySQL (S)QLiteEnter choice:S*** Create users table(drop old one if appl.***Insert namse into tableLOGIN USERID PROJID Bob 1234 2 Dave 4523 1 Angela 4567 2 ***Move users to a random group (2 users moved) from (2) to (2))LOGIN USERID PROJID Bob 1234 2 Dave 4523 1 Angela 4567 2 ***Randomly delete group (group #1; 1 users removed)LOGIN USERID PROJID Bob 1234 2 Angela 4567 2 ***Drop users table***Close cxns SQLObjectSQLObject需要mysqldb支持，但是由于mysqldb不再支持python3，所以根据提示安装替代方案Mysqlclient，选择对应的版本进行下载后执行相应的命令：pip3 install mysqlclient-1.3.12-cp36-cp36m-win_amd64.whl 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#!/usr/bin/python3# -*- coding:UTF-8 -*-# 使用SQLObject代替SQLAlchemy# 其余和使用SQLAlchemy的相同from os.path import dirnamefrom random import randrange as randfrom sqlobject import *from ushuffleDB import DBNAME, NAMELEN, \ randName, FIELDS, tformat, cformat, setupDSNs = &#123; 'mysql': 'mysql://root:root@127.0.0.1:3306/%s' % DBNAME, 'sqlite': 'sqlite:///:memory:',&#125;class Users(SQLObject): # 扩展了SQLObject.SQLObject类 # 定义列 login = StringCol(length=NAMELEN) userid = IntCol() projid = IntCol() def __str__(self): # 提供用于显示输出的方法 return ''.join(map(tformat, ( self.login, self.userid, self.projid)))class SQLObjectTest(object): def __init__(self, dsn): # 确保得到一个可用的数据库，然后返回连接 try: cxn = connectionForURI(dsn) except ImportError: raise RuntimeError() try: # 尝试对已存在的表建立连接 # 规避RMBMS适配器不可用，服务器不在线及数据库不存在等异常 cxn.releaseConnection(cxn.getConnection()) except dberrors.OperationalError: # 出现异常则创建表 cxn = connectionForURI(dirname(dsn)) cxn.query('CREATE DATABASE %s' % DBNAME) cxn = connectionForURI(dsn) # 成功后在self.cxn中保存连接对象 self.cxn = sqlhub.processConnection = cxn def insert(self): # 插入 for who, userid in randName(): Users(login=who, userid=userid, projid=rand(1, 5)) def update(self): # 更新 fr = rand(1, 5) to = rand(1, 5) i = -1 users = Users.selectBy(projid=fr) for i, user in enumerate(users): user.projid = to return fr, to, i+1 def delete(self): # 删除 rm = rand(1, 5) users = Users.selectBy(projid=rm) i = -1 for i, user in enumerate(users): user.destroySelf() return rm, i+1 def dbDump(self): print('\n%s' % ''.join(map(cformat, FIELDS))) for user in Users.select(): print(user) def finish(self): # 关闭连接 self.cxn.close()def main(): print('***Connect to %r database' % DBNAME) db = setup() if db not in DSNs: print('\nError: %r not support' % db) return try: orm = SQLObjectTest(DSNs[db]) except RuntimeError: print('\nError: %r not support' % db) return print('\n***Create users table(drop old one if appl.)') Users.dropTable(True) Users.createTable() print('\n*** Insert names into table') orm.insert() orm.dbDump() print('\n*** Move users to a random group') fr, to, num = orm.update() print('\t(%d users moved) from (%d) to (%d)' % (num, fr, to)) orm.dbDump() print('\n*** Randomly delete group') rm, num = orm.delete() print('\t(group #%d;%d users removed)' % (rm, num)) orm.dbDump() print('\n*** Drop users table') # 使用dropTable()方法 Users.dropTable() print('\n***Close cxns') orm.finish()if __name__ == '__main__': main() MySQL输出结果 123456789101112131415161718192021222324252627282930313233Choose a database system:(M)ySQL(S)QLiteEnter choice:M***Create users table(drop old one if appl.)*** Insert names into tableLOGIN USERID PROJID Bob 1234 4 Dave 4523 3 Angela 4567 1 *** Move users to a random group(0 users moved) from (2) to (4)LOGIN USERID PROJID Bob 1234 4 Dave 4523 3 Angela 4567 1 *** Randomly delete group(group #3;1 users removed)LOGIN USERID PROJID Bob 1234 4 Angela 4567 1 *** Drop users table***Close cxns SQLite输出结果 123456789101112131415161718192021222324252627282930313233Choose a database system:(M)ySQL(S)QLiteEnter choice:S***Create users table(drop old one if appl.)*** Insert names into tableLOGIN USERID PROJID Bob 1234 2 Angela 4567 4 Dave 4523 3 *** Move users to a random group(1 users moved) from (3) to (1)LOGIN USERID PROJID Bob 1234 2 Angela 4567 4 Dave 4523 1 *** Randomly delete group(group #2;1 users removed)LOGIN USERID PROJID Angela 4567 4 Dave 4523 1 *** Drop users table***Close cxns 非关系型数据库Web和社交服务会产生大量的数据，并且数据的产生速率可能要比关系型数据库能够处理得更快。非关系数据库有对象数据库、键-值对存储、文档存储（或数据存储）、图形数据库、表格数据库、列/可扩展记录/宽列数据库、多值数据库等很多种类。 MongoDBMongoDB是非常流行的文档存储非关系数据库。 文档存储(MongoDB、CouchDB/Amazon SimpleDB)与其他非关系数据库的区别在于它介于简单的键-值对存储(Redis、Voldemort)与列存储(HBase、Google Bigtable)之间。比基于列的存储更简单、约束更少。比普通的键-值对存储更加灵活。一般情况下其数据会另存为JSON对象、并且允许诸如字符串、数值、列表甚至嵌套等数据类型 MongoDB(以及NoSQL)要讨论的事文档、集合而不是关系数据库中的行和列。MongoDB将数据存储于特殊的JSON串(文档)中，由于它是一个二进制编码的序列化，通常也称其为BSON格式。它和JSON或者Python字典都很相似。 PyMongo:MongoDB和PythonPyMongo是Python MongoDB驱动程序中最正式的一个。使用之前需要安装MongoDB数据库和PyMongo：pip3 install pymongo在windows下需要运行mongo.exe启动MongoDB，进入cmd到MongoDB的bin目录下，执行如下命令.mongod --dbpath E:\MongoDB\data 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#!/usr/bin/python3# -*- coding:UTF-8 -*-# 主要导入的是MongoClient对象和及其包异常errorsfrom random import randrange as randfrom pymongo import MongoClient, errorsfrom ushuffleDB import DBNAME, randName, FIELDS, tformat, cformat# 设置了集合(“表”)名COLLECTION = 'users'class MongoTest(object): def __init__(self): # 创建一个连接，如果服务器不可达，则抛出异常 try: cxn = MongoClient() except errors.AutoReconnect: raise RuntimeError # 创建并复用数据库及“users”集合 # 关系数据库中的表会对列的格式进行定义， # 然后使遵循这个列定义的每条记录成为一行 # 非关系数据库中集合没有任何模式的需求， # 每条记录都有其特定的文档 # 每条记录都定义了自己的模式，所以保存的任何记录都会写入集合中 self.db = cxn[DBNAME] self.users = self.db[COLLECTION] def insert(self): # 向MongoDB的集合中添加值 # 使用dict()工厂函数为每条记录创建一个文档 # 然后将所有文档通过生成器表达式的方式传递给集合的insert()方法 self.users.insert( dict(login=who, userid=uid, projid=rand(1, 5) )for who, uid in randName() ) def update(self): # 集合的update()方法可以给开发者相比于典型的数据库系统更多的选项 fr = rand(1, 5) to = rand(1, 5) i = -1 # 在更新前，首先查询系统中的项目ID(projid)与要更新的项目组相匹配的所有用户 # 使用find()方法，并将查询条件传进去(类似SQL的SELECT语句) for i, user in enumerate(self.users.find(&#123;'projid': fr&#125;)): # 使用$set指令可以显式地修改已存在的值 # 每条MongoDB指令都代表一个修改操作，使得修改操作更加高效、有用和便捷 # 除了$set还有一些操作可以用于递增字段值、删除字段(键-值对)、对数组添加/删除值 # update()方法可以用来修改多个文档(将multi标志设为True) self.users.update(user, &#123; '$set': &#123;'projid': to&#125; &#125;) return fr, to, i+1 def delete(self): # 当得到所有匹配查询的用户后，一次性对其执行remove()操作进行删除 # 然后返回结果 rm = rand(1, 5) i = -1 for i, user in enumerate(self.users.find(&#123;'projid': rm&#125;)): self.users.remove(user) return rm, i+1 def dbDump(self): # 没有天剑会返回集合中所有用户并对数据进行字符串格式化向用户显示 print('%s' % ''.join(map(cformat, FIELDS))) for user in self.users.find(): print(''.join(map(tformat, ( user[k] for k in FIELDS))))def main(): print('***Connect to %r database' % DBNAME) try: mongo = MongoTest() except RuntimeError: print('\nERROR: MongoDB server unreadable, exit') return print('\n***Insert names into table') mongo.insert() mongo.dbDump() print('\n***Move users to a random group') fr, to, num = mongo.update() print('\t(%d users moved) from (%d) to (%d)' % (num, fr, to)) mongo.dbDump() print('\n*** Randomly delete group') rm, num = mongo.delete() print('\tgroup #%d; %d users removed' % (rm, num)) mongo.dbDump() print('\n***Drop users table') mongo.db.drop_collection(COLLECTION)if __name__ == '__main__': main() 执行结果 12345678910111213141516171819202122***Connect to &apos;test&apos; database***Insert names into tableLOGIN USERID PROJID Dave 4523 4 Bob 1234 4 Angela 4567 2 ***Move users to a random group (0 users moved) from (1) to (2)LOGIN USERID PROJID Dave 4523 4 Bob 1234 4 Angela 4567 2 *** Randomly delete group group #2; 1 users removedLOGIN USERID PROJID Dave 4523 4 Bob 1234 4 ***Drop users table]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据库编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python数据库编程(一)]]></title>
    <url>%2F2018%2F02%2F28%2FPython%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Python和大多数语言一样，访问数据库包括直接通过数据库接口访问和使用ORM访问两种方式。其中ORM访问的方式不需要显式地给出SQL命令。在Python中数据库是通过适配器的方式进行访问的。适配器是一个Python模块，使用它可以与关系型数据库的客户端库接口相连。 Python的DB-API DB-API是阐明一系列所需对象和数据库访问机制的标准，它可以为不同的数据库适配器和底层数据库系统提供一致性访问 模块属性DB-API模块属性 属性 描述 apilevel 需要适配器兼容的DB-API版本 threadsafety 本模块的线程安全级别 paramstyle 本模块的SQL语句参数风格 connect() Connect()函数 (多种异常) 数据属性 apilevel 该字符串指明了模块需要兼容的DB-API最高版本，默认值为1.0 threadsafety 0: 不支持线程安全。线程间不能共享模块1: 最小化线程安全支持：线程间可以共享模块，但是不能共享连接2: 适度的线程安全支持：线程间可以共享模块和连接，但是不能共享游标3: 完整的线程安全支持：线程间可以共享模块、连接和游标 如果有资源需要共享，那么就需要诸如自旋锁、信号量等同步原语达到原子锁定的目的 参数风格 paramstyle 参数风格 描述 示例 numeric 数值位置风格 WHERE name=:1 named 命名风格 WHERE name=:name pyformat Python字典printf()格式转换 WHERE name=%(name)s qmark 问号风格 WHERE name=? format ANSIC的printf()格式转换 WHERE name=%s 函数属性 connect()函数通过Connection对象访问数据库。兼容模块必须实现connect()函数。该函数创建并放回一个Connection对象 connect()函数使用例子：connect(dsn=&#39;myhost:MYDB&#39;, user=&#39;root&#39;, password=&#39;root&#39;) connect()函数属性 参数 描述 user 用户名 password 面 host 主机名 database 数据库名 dsn 数据源名 使用ODBC或JDBC的API需要使用DSN；直接使用数据库，更倾向于使用独立的登录参数。 异常 异常 描述 Warning 警告异常基类 Error 错误异常基类 InterfaceError 数据库接口(非数据库)错误 DatabaseError 数据库错误 DataError 处理数据时出现错误 OperationError 数据库操作执行期间出现的错误 IntegrityError 数据库关系完整性错误 InternalError 数据库内部错误 ProgrammingError SQL命令执行失败 NotSupportedError 出现不支持的操作 Connection对象 只有通过数据连接才能把命令传递到服务器，并得到返回的结果。当一个连接(或一个连接池)建立后，可以创建一个游标，向数据库发送请求，然后从数据库接收回应 Connection对象方法 方法名 描述 close() 关闭数据库连接 commit() 提交当前事务 rollback() 取消当前事务 cursor() 使用该连接创建(并返回)一个游标或类游标的对象 errorhandler(cxn,cur,errcls,errval) 作为给定连接的游标的处理程序 当使用close()时，这个连接将不能再使用，否则会进入到异常处理中 如果数据库不支持事务处理或启用了自动提交功能，commit()方法都无法使用 rollback()只能在支持事务处理的数据库中使用。发生异常时，rollback()会将数据库的状态恢复到事务处理开始时。 如果RDBMS(关系数据库管理系统)不支持游标，cursor()会返回一个尽可能模仿真实游标的对象 Cursor对象 游标可以让用户提交数据库命令，并获得查询的结果行。 对象属性 描述 arraysize 使用fetchmany()方法时，一次取出的结果行数，默认为1 connection 创建此游标的连接(可选) description 返回游标活动状态(7项元组):(name,type_code,display_size,internal_size,precision,scale,null-ok)，只有name和type_code是必需的 lastrowid 上次修改行的行ID(可选，如果不支持行ID，则返回None) rowcount 上次execute*()方法处理或影响的行数 callproc(func[,args]) 调用存储过程 close() 关闭游标 execute(op[,args]) 执行数据库查询或命令 executemany(op,args) 类似execute()和map()的结合，为给定的所有参数准备并执行数据库查询或命令 fetchone() 获取查询结果的下一行 fetchmany([size=cursor,arraysize]) 获取查询结果的下面size行 fetchall() 获取查询结果的所有(剩余)行 iter() 为游标创建迭代器对象(可选，参考nexi()) messages 游标执行后从数据库中获得的消息列表(元组集合，可选) next() 被迭代器用于获取查询结果的下一行(可选，类似fetchone(),参考iter()) nextset() 移动到下一个结果集合(如果支持) rownumber 当前结果集中游标的索引(以行为单位，从0开始，可选) setinputsizes(sizes) 设置允许的最大输入大小(必须有，但是实现是可选的) setoutputsize(size[,col]) 设置大列获取的最大缓冲区大小(必须有，但是实现是可选的) 游标对象最重要的属性是execute()和fetch()方法，所有针对数据库的服务请求都通过它们执行。当不需要是关闭游标 类型对象和构造函数 创建构造函数，从而构建可以简单地转换成适当数据库对象的特殊对象 类型对象 描述 Date(yr,mo,dy) 日期值对象 Time(hr,min,sec) 时间值对象 Timestamp(yr,mo,dy,hr,min,sec) 时间戳值对象 DateFromTicks(ticks) 日期对象，给出从新纪元时间（1970 年1 月1 日00:00:00 UTC）以来的秒数 TimeFromTicks(ticks) 时间对象，给出从新纪元时间（1970 年1 月1 日00:00:00 UTC）以来的秒数 TimestampFromTicks(ticks) 时间戳对象，给出从新纪元时间（1970 年1 月1 日00:00:00 UTC）以来的秒数 Binary(string) 对应二进制(长)字符串对象 STRING 表示基于字符串列的对象，比如VARCHAR BINARY 表示(长)二进制列的对象，比如RAW、BLOB NUMBER 表示数值列的对象 DATETIME 表示日期/时间列的对象 ROWID 表示“行ID”列的对象 SQL的NULL值对应于Python的NULL对象None 数据库适配器示例应用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201#!/usr/bin/python3# -*- coding:UTF-8 -*-# 导入必需的模块import osfrom random import randrange as rand# 创建了全局变量# 用于显示列的大小，以及支持的数据库种类COLSIZ = 10FIELDS = ('login', 'userid', 'projid')RDBMSs = &#123; 's': 'sqlite', 'm': 'mysql',&#125;DBNAME = 'test'DBUSER = 'root'# 数据库异常变量，根据用户选择运行的数据库系统的不同来制定数据库异常模块DB_EXC = NoneNAMELEN = 16# 格式化字符串以显示标题# 全大写格式化函数，接收每个列名并使用str.upper()方法把它转换为头部的全大写形式# 两个函数都将其输出左对齐，并限制为10个字符的宽度ljust(COLSIZ)tformat = lambda s: str(s).title().ljust(COLSIZ)cformat = lambda s: s.upper().ljust(COLSIZ)def setup(): return RDBMSs[input(''' Choose a database system: (M)ySQL (S)QLite Enter choice: ''').strip().lower()[0]]def connect(db): # 数据库一致性访问的核心 # 在每部分的开始出尝试加载对应的数据库模块，如果没有找到合适的模块 # 就返回None，表示无法支持数据库系统 global DB_EXC dbDir = '%s_%s' % (db, DBNAME) if db == 'sqlite': try: # 尝试加载sqlite3模块 import sqlite3 except ImportError: return None DB_EXC = sqlite3 # 当对SQLite调用connect()时，会使用已存在的目录 # 如果没有，则创建一个新目录 if not os.path.isdir(dbDir): os.mkdir(dbDir) cxn = sqlite3.connect(os.path.join(dbDir, DBNAME)) elif db == 'mysql': try: # 由于MySQLdb不支持python3.6，所以导入pymysql import pymysql import pymysql.err as DB_EXC try: cxn = pymysql.connect(host="localhost", user="root", password="root", port=3306, db=DBNAME) except DB_EXC.InternalError: try: cxn = pymysql.connect(host="localhost", user="root", password="root", port=3306) cxn.query('CREATE DATABASE %s' % DBNAME) cxn.commit() cxn.close() cxn = pymysql.connect(host="localhost", user="root", password="root", port=3306, db=DBNAME) except DB_EXC.InternalError: return None except ImportError: return None else: return None return cxndef create(cur): # 创建一个新表users try: cur.execute(''' CREATE TABLE users( login VARCHAR(%d), userid INTEGER, projid INTEGER ) ''' % NAMELEN) except DB_EXC.InternalError as e: # 如果发生错误，几乎总是这个表已经存在了 # 删除该表，重新创建 drop(cur) create(cur)# 删除数据库表的函数drop = lambda cur: cur.execute('DROP TABLE users')# 由用户名和用户ID组成的常量NAMES = ( ('bob', 1234), ('angela', 4567), ('dave', 4523))def randName(): # 生成器 pick = set(NAMES) while pick: yield pick.pop()def insert(cur, db): # 插入函数 # SQLite风格是qmark参数风格，而MySQL使用的是format参数风格 # 对于每个用户名-用户ID对，都会被分配到一个项目卒中。 # 项目ID从四个不同的组中随机选出的 if db == 'sqlite': cur.executemany("INSERT INTO users VALUES(?,?,?)", [(who, uid, rand(1, 5)) for who, uid in randName()]) elif db == 'mysql': cur.executemany("INSERT INTO users VALUES(%s, %s, %s)", [(who, uid, rand(1, 5)) for who, uid in randName()])# 返回最后一次操作后影响的行数，如果游标对象不支持该属性，则返回-1getRC = lambda cur: cur.rowcount if hasattr(cur, 'rowcount') else -1# update()和delete()函数会随机选择项目组中的成员# 更新操作会将其从当前组移动到另一个随机选择的组中# 删除操作会将该组的成员全部删除def update(cur): fr = rand(1, 5) to = rand(1, 5) cur.execute('UPDATE users SET projid=%d WHERE projid=%d' % (to, fr)) return fr, to, getRC(cur)def delete(cur): rm = rand(1, 5) cur.execute('DELETE FROM users WHERE projid=%d' % rm) return rm, getRC(cur)def dbDump(cur): # 来去所有行，将其按照打印格式进行格式化，然后显示 cur.execute('SELECT * FROM users') # 格式化标题 print('%s' % ''.join(map(cformat, FIELDS))) for data in cur.fetchall(): # 将数据(login,userid,projid)通过map()传递给tformat()， # 是数据转化为字符串，将其格式化为标题风格 # 字符串按照COLSIZ的列宽度进行左对齐 print(''.join(map(tformat, data)))def main(): # 主函数 db = setup() print('*** Connect to %r database' % db) cxn = connect(db) if not cxn: print('ERROR: %r not supported or unreadable, exit' % db) return cur = cxn.cursor() print('***Creating users table') create(cur=cur) print('***Inserting names into table') insert(cur, db) dbDump(cur) print('\n***Randomly moving folks') fr, to, num = update(cur) print('(%d users moved) from (%d) to (%d)' % (num, fr, to)) dbDump(cur) print('***Randomly choosing group') rm, num = delete(cur) print('\t(group #%d; %d users removed)' % (rm, num)) dbDump(cur) print('\n***Droping users table') drop(cur) print('\n*** Close cxns') cur.close() cxn.commit() cxn.close()if __name__ == '__main__': main() MySQL数据库访问结果 123456789101112131415161718192021222324252627Choose a database system: (M)ySQL (S)QLiteEnter choice:M*** Connect to &apos;mysql&apos; database***Creating users table***Inserting names into tableLOGIN USERID PROJID Dave 4523 2 Bob 1234 3 Angela 4567 3 ***Randomly moving folks(2 users moved) from (3) to (1)LOGIN USERID PROJID Dave 4523 2 Bob 1234 1 Angela 4567 1 ***Randomly choosing group (group #1; 2 users removed)LOGIN USERID PROJID Dave 4523 2 ***Droping users table*** Close cxns SQLite数据库访问结果 12345678910111213141516171819202122232425262728Choose a database system:(M)ySQL(S)QLiteEnter choice:S*** Connect to &apos;sqlite&apos; database***Creating users table***Inserting names into tableLOGIN USERID PROJID Dave 4523 1 Bob 1234 2 Angela 4567 3 ***Randomly moving folks(1 users moved) from (1) to (1)LOGIN USERID PROJID Dave 4523 1 Bob 1234 2 Angela 4567 3 ***Randomly choosing group(group #3; 1 users removed)LOGIN USERID PROJID Dave 4523 1 Bob 1234 2 ***Droping users table*** Close cxns]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据库编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python多线程(二)]]></title>
    <url>%2F2018%2F02%2F26%2FPython%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[在上篇主要对线程的概念做了一个简要的介绍，同时介绍了_thread模块和threading模块的使用方法，通过几个简短的程序实现了线程的调用。这篇将会记录一些多线程简单的应用以及相关生产者和消费者的问题。 多线程实践Python虚拟机是单线程（GIL）的原因，只有线程在执行I/O密集型的应用时才会更好地发挥Python的并发性。下面的例子是通过多线程下载图书排名信息的调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#!/usr/bin/python3# -*- coding:UTF-8 -*-from atexit import registerimport reimport threadingimport timeimport urllib.request# 匹配排名的正则表达式# 亚马逊的网站REGEX = re.compile(b'#([\d,]+) in Books')AMZN = 'https://www.amazon.com/dp/'# ISBN编号和书名ISBNs = &#123; '0132269937': 'Core Python Programming', '0132356139': 'Python Web Development with Django', '0137143419': 'Python Fundamentals'&#125;# 请求头# 因为亚马逊会检测爬虫,所以需要加上请求头伪装成浏览器访问headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 ' '(KHTML, like Gecko) Chrome/48.0.2564.116 Safari/537.36 TheWorld 7'&#125;def get_ranking(isbn): # 爬取网页,获取数据 # 使用str.format()格式化数据 url = '&#123;0&#125;&#123;1&#125;'.format(AMZN, isbn) # 爬取网页并解析 req = urllib.request.Request(url, headers=headers) page = urllib.request.urlopen(req) data = page.read() page.close() return str(REGEX.findall(data)[0], 'utf-8')def _show_ranking(isbn): # 显示结果 print('- %r ranked %s' % (ISBNs[isbn], get_ranking(isbn)))def _main(): print('At', time.ctime(), 'on Amazon...') for isbn in ISBNs: (threading.Thread(target=_show_ranking, args=(isbn,))).start() #_show_ranking(isbn)@registerdef _atexit(): # 注册一个退出函数，在脚本退出先请求调用这个函数 print('all DONE at:', time.ctime())if __name__ == '__main__': _main() 输出结果 12345At Tue Feb 27 10:40:51 2018 on Amazon...- &apos;Python Fundamentals&apos; ranked 4,358,513- &apos;Python Web Development with Django&apos; ranked 1,354,091- &apos;Core Python Programming&apos; ranked 458,510all DONE at: Tue Feb 27 10:42:39 2018 锁示例锁有两种状态:锁定 和 未锁定。同时它也支持两个函数：获得锁 和 释放锁。当多线程争夺锁时，允许第一个获得锁的线程进入临界区，并执行。之后到达的线程被阻塞，直到第一个线程执行结束，退出临界区，并释放锁。其他等待的线程随机获得锁并进入临界区。 锁和更多的随机性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#!/usr/bin/python3# -*- coding:UTF-8 -*-from __future__ import with_statementfrom atexit import registerfrom random import randrangefrom threading import Thread, Lock, current_threadfrom time import sleep, ctimeclass CleanOutputSet(set): # 集合的子类，将默认输出改变为将其所有元素 # 按照逗号分隔的字符串 def __str__(self): return ', '.join(x for x in self)# 锁# 随机数量的线程(3~6)，每个线程暂停或睡眠2~4秒lock = Lock()loops = (randrange(2, 5) for x in range(randrange(3, 7)))remaining = CleanOutputSet()def loop(sec): # 获取当前执行的线程名，然后获取锁并保存线程名 myname = current_thread().name lock.acquire() remaining.add(myname) print('[%s] Started %s' % (ctime(), myname)) # 释放锁并睡眠随机秒 lock.release() sleep(sec) # 重新获取锁，输出后再释放锁 lock.acquire() remaining.remove(myname) print('[%s] Completed %s (%d sec)' % (ctime(), myname, sec)) print(' (remaining: %s)' % (remaining or 'NONE')) lock.release()def loop_with(sec): myname = current_thread().name with lock: remaining.add(myname) print('[%s] Started %s' % (ctime(), myname)) sleep(sec) with lock: remaining.remove(myname) print('[%s] Completed %s (%d sec)' % (ctime(), myname, sec)) print(' (remaining: %s)' % (remaining or 'NONE'))def _main(): for pause in loops: # Thread(target=loop, args=(pause,)).start() Thread(target=loop_with, args=(pause,)).start()@registerdef _atexit(): print('all DONE at:', ctime())if __name__ == '__main__': _main() 输出结果 loop方法12345678910111213141516171819[Tue Feb 27 11:26:13 2018] Started Thread-1[Tue Feb 27 11:26:13 2018] Started Thread-2[Tue Feb 27 11:26:13 2018] Started Thread-3[Tue Feb 27 11:26:13 2018] Started Thread-4[Tue Feb 27 11:26:13 2018] Started Thread-5[Tue Feb 27 11:26:13 2018] Started Thread-6[Tue Feb 27 11:26:15 2018] Completed Thread-2 (2 sec) (remaining: Thread-3, Thread-4, Thread-1, Thread-5, Thread-6)[Tue Feb 27 11:26:15 2018] Completed Thread-6 (2 sec) (remaining: Thread-3, Thread-4, Thread-1, Thread-5)[Tue Feb 27 11:26:16 2018] Completed Thread-3 (3 sec) (remaining: Thread-4, Thread-1, Thread-5)[Tue Feb 27 11:26:16 2018] Completed Thread-4 (3 sec) (remaining: Thread-1, Thread-5)[Tue Feb 27 11:26:16 2018] Completed Thread-5 (3 sec) (remaining: Thread-1)[Tue Feb 27 11:26:17 2018] Completed Thread-1 (4 sec) (remaining: NONE)all DONE at: Tue Feb 27 11:26:17 2018 loop_with方法12345678910111213141516171819[Tue Feb 27 11:43:15 2018] Started Thread-1[Tue Feb 27 11:43:15 2018] Started Thread-2[Tue Feb 27 11:43:15 2018] Started Thread-3[Tue Feb 27 11:43:15 2018] Started Thread-4[Tue Feb 27 11:43:15 2018] Started Thread-5[Tue Feb 27 11:43:15 2018] Started Thread-6[Tue Feb 27 11:43:17 2018] Completed Thread-3 (2 sec) (remaining: Thread-1, Thread-5, Thread-4, Thread-6, Thread-2)[Tue Feb 27 11:43:17 2018] Completed Thread-6 (2 sec) (remaining: Thread-1, Thread-5, Thread-4, Thread-2)[Tue Feb 27 11:43:17 2018] Completed Thread-5 (2 sec) (remaining: Thread-1, Thread-4, Thread-2)[Tue Feb 27 11:43:18 2018] Completed Thread-1 (3 sec) (remaining: Thread-4, Thread-2)[Tue Feb 27 11:43:18 2018] Completed Thread-4 (3 sec) (remaining: Thread-2)[Tue Feb 27 11:43:18 2018] Completed Thread-2 (3 sec) (remaining: NONE)all DONE at: Tue Feb 27 11:43:18 2018 信号量示例对于拥有有限资源的应用来说，可以使用信号量的方式来代替锁。信号量 是一个计数器，当资源消耗时递减，当资源释放时递增。信号量比锁更加灵活，因为可以有多个线程，每个线程拥有有限资源的一个实例。消耗资源使计数器递减的操作成为P()，当一个线程对一个资源完成操作时，该资源返回资源池的操作称为V()。 糖果机和信号量 这个特制的机器只有5个可用的槽来保持库存。如果所有槽都满了，糖果不能再加入这个机器中；如果每个槽都空了，想要购买的消费者无法买到糖果。使用信号量来跟踪这些有限的资源 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#!/usr/bin/python3# -*- coding:UTF-8 -*-# 导入相应的模块和信号量类# BoundedSemaphore的额外功能是这个计数器的值永远不会超过它的初始值# 它可以防范其中信号量释放次数多余获得次数的异常用例from atexit import registerfrom random import randrangefrom threading import BoundedSemaphore, Lock, Threadfrom time import sleep, ctime# 全局变量# 锁# 库存商品最大值的常量# 糖果托盘lock = Lock()MAX = 5candytray = BoundedSemaphore(MAX)def refill(): # 当虚构的糖果机所有者向库存中添加糖果时执行 # 代码会输出用户的行动，并在某人添加的糖果超过最大库存是给予警告 lock.acquire() print('Refilling candy...') try: candytray.release() except ValueError: print('full, skipping') else: print('OK') lock.release()def buy(): # 允许消费者获取一个单位的库存 lock.acquire() print('Buying candy....') # 检测是否所有资源都已经消费完了 # 通过传入非阻塞的标志False，让调用不再阻塞，而在应当阻塞的时候返回一个False # 指明没有更多资源 if candytray.acquire(False): print('OK') else: print('Empty, skipping') lock.release()def producer(loops): for i in range(loops): refill() sleep(randrange(3))def consumer(loops): for i in range(loops): buy() sleep(randrange(3))def _main(): print('starting at:', ctime()) nloops = randrange(2, 6) print('THE CANDY MACHINE (full with %d bars)' % MAX) Thread(target=consumer, args=(randrange(nloops, nloops+MAX+2),)).start() Thread(target=producer, args=(nloops,)).start()@registerdef _atexit(): print('all DONE at:', ctime())if __name__ == '__main__': _main() 输出结果 12345678910111213141516171819202122232425262728293031starting at: Tue Feb 27 14:48:31 2018THE CANDY MACHINE (full with 5 bars)Buying candy....OKRefilling candy...OKRefilling candy...full, skippingBuying candy....OKRefilling candy...OKBuying candy....OKRefilling candy...OKRefilling candy...full, skippingBuying candy....OKBuying candy....OKBuying candy....OKBuying candy....OKBuying candy....OKBuying candy....Empty, skippingall DONE at: Tue Feb 27 14:48:42 2018 生产者-消费者问题和queue模块生产商品的时间是不确定的，消费生产者生产的商品的时间也是不确定的。在这个场景下将其放在类似队列的数据结构中。queue模块来提供线程间通信的机制，从而让线程之间可以互相分享数据。具体而言就是创建一个队列，让生产者在其中放入新的商品，而消费者消费这些商品 queue模块常用属性 属性 描述 Queue(maxsize=0) 创建一个先入先出队列。如果给定最大值，则在队列没有空间时阻塞，否则(没有指定最大值),为无限队列 LifoQueue(maxsize=0) 创建一个后入先出队列。如果给定最大值，则在队列没有空间时阻塞，否则(没有指定最大值),为无限队列 PriorityQueue(maxsize) 创建一个优先级队列。如果给定最大值，则在队列没有空间时阻塞，否则(没有指定最大值),为无限队列 queue异常 Empty 当对空队列调用get*()方法时抛出异常 Full 当对已满的队列调用put*()方法时抛出异常 queue对象方法 qsize() 返回队列大小(由于返回时队列大小可能被其他线程修改，所以改值为近似值) empty() 如果队列为空，则返回True；否则，返回False full() 如果队列已满，则返回True；否则，返回False put(item,block=True,timeout=None) 将item放入队列。如果block为True(默认)且timeout为None，则在有可用空间之前阻塞；如果timeout为正值，则最多阻塞timeout秒；如果block为False，则抛出Empty异常 put_nowait() 和put(item,False)相同 get(block=True,timeout=None) 从队列中取得元素，如果给定了block(非0)，则一直阻塞到有可用的元素为止 get_nowait() 和get(False)相同 task_done() 用于标识队列中的某个元素已执行完成，该方法会被下面的join()使用 join() 在队列中所有元素执行完毕并调用上面的task_done()信号之前，保持阻塞 生产者消费者问题使用了Queue对象，以及随机生产(消费)的商品的数量。生产者和消费者独立且并发地执行线程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#!/usr/bin/python3# -*- coding:UTF-8 -*-# 使用queue.Queue对象和之前的myThread.MyThread线程类from random import randintfrom time import sleepfrom queue import Queuefrom myThread import MyThreaddef writeQ(queue): # 将一个对象放入队列中 print('producing object for Q...') queue.put('xxx', 1) print('size now', queue.qsize())def readQ(queue): # 消费队列中的一个对象 val = queue.get(1) print('consumed object from Q... size now', queue.qsize())def writer(queue, loops): # 作为单个线程运行 # 向队列中放入一个对象，等待片刻，然后重复上述步骤 # 直至达到脚本执行时随机生成的次数没值 for i in range(loops): writeQ(queue) # 睡眠的随机秒数比reader短是为了阻碍reader从空队列中获取对象 sleep(randint(1, 3))def reader(queue, loops): # 作为单个线程运行 # 消耗队列中一个对象，等待片刻，然后重复上述步骤 # 直至达到脚本执行时随机生成的次数没值 for i in range(loops): readQ(queue) sleep(randint(2, 5))# 设置派生和执行的线程总数funcs = [writer, reader]nfuncs = range(len(funcs))def main(): nloops = randint(2, 5) q = Queue(32) threads = [] for i in nfuncs: t = MyThread(funcs[i], (q, nloops), funcs[i].__name__) threads.append(t) for i in nfuncs: threads[i].start() for i in nfuncs: threads[i].join() print('all DONE')if __name__ == '__main__': main() 输出结果 1234567891011121314starting at: Tue Feb 27 15:17:16 2018producing object for Q...size now 1starting at: Tue Feb 27 15:17:16 2018consumed object from Q... size now 0producing object for Q...size now 1producing object for Q...size now 2done at: Tue Feb 27 15:17:20 2018consumed object from Q... size now 1consumed object from Q... size now 0done at: Tue Feb 27 15:17:26 2018all DONE 线程的替代方案subprocess模块multiprocessing模块concurrent.futures模块]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python多线程(一)]]></title>
    <url>%2F2018%2F02%2F24%2FPython%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[多线程编程对于以下编程任务是非常理想的： 本质上是异步的 需要多个并发活动 每个活动的处理顺序可能是不确定的(随机、不可预测的) 使用多线程或者类似Queue的共享数据结构可以将一个串行程序规划成几个执行特定任务的线程 UserRequestThread: 负责读取客户端输入。程序将创建多个线程，每个客户端一个，客户端的请求将会被放入队列中 RequestProcessor: 该线程负责从队列中获取请求并进行处理，为第三个线程提供输出 ReplyThread: 负责向用户输出，将结果传回给用户，或者把数据写到本地文件系统或者数据库中 线程和进程 进程 计算机程序是储存在磁盘上的可执行二进制(或其他类型)的文件。进程 （有时称为 重量级进程）则是一个执行中的程序。每一个进程都拥有自己的地址空间、内存、数据栈以及其他用于跟踪执行的辅助数据。操作系统管理其上的所有进程的执行，并为它们合理地分配时间。进程可以通过 派生(fork或spawn)新的进程来执行任务,而进程之间的通信只能通过 进程间通信(IPC) 的方式共享信息 线程 线程（有时称为 轻量级进程）共享相同的上下文。相当于在主进程中并行运行的一些“迷你进程”。当其他线程运行是，它可以被抢占（中断）和临时挂起（睡眠），这种做法叫 让步(yielding)。早单核CPU系统中，线程的实际规划是：每个线程运行一小会儿，然后让步给其他线程（再次排队等待更多的CPU时间）。在整个进程的执行当中，每个线程执行它自己特定的任务，在必要时和其他线程进行结果通信。 线程与Python全局解释锁 对Python虚拟机的访问是由全局解释锁(GIL) 控制的。这个锁用来保证同时只能有一个线程运行。在多线程环境中，Python虚拟机将按照下面的方式执行。 设置GIL 切换进一个线程去运行 执行下面操作之一 a. 指定数量的字节码指令 b. 线程主动让出控制权(可以调用time.sleep(0)来完成) 把线程设置回睡眠状态(切换出线程) 解锁GIL 重复上述步骤 当调用外部代码(即，任意C/C++扩展的内置函数)时，GIL会保持锁定，直至函数执行结束。 退出线程 当一个线程完成函数的执行时，就会退出。还可以通过调用thread.exit()或者sys.exit()退出进程，或者抛出SystemExit异常，是线程退出。 _thread模块 _thread模块提供了派生线程、基本的同步数据结构(锁对象(lock object),也叫 原语锁、简单锁、互斥锁、互斥 和 二进制信号量) _thread模和锁对象 函数/方法 描述 _thread模块的函数 start_new_thread(function, args, kwargs = None) 派生一个新的线程，使用给定的args和可选的kwargs来执行function allocate_lock() 分配LockType锁对象 exit() 给线程退出命令 LockType锁对象的方法 acquire(wait = None) 尝试获取锁对象 locked() 如果获取了锁对象则返回True，否则，返回False release() 释放锁 使用线程一般方式 程序 123456789101112131415161718192021222324252627282930313233#!usr/bin/python3# -*- coding:UTF-8 -*-import _threadfrom time import ctime, sleepdef loop_0(): print('start loop_0 at:', ctime()) sleep(4) print('loop_0 done at:', ctime())def loop_1(): print('start loop_1 at:', ctime()) sleep(2) print('loop_1 done at:', ctime())def main(): print('starting at:', ctime()) # start_new_thread 方法即使要执行的 # 函数不需要参数，也需要传递一个空元组 _thread.start_new_thread(loop_0, ()) _thread.start_new_thread(loop_1, ()) # 阻止主线程的执行，保证其最后执行， # 后续去掉这种方式，引入锁的方式 sleep(6) print('all done at', ctime())if __name__ == '__main__': main() 执行结果 在主线程中同时开启了两个线程，loop_1()由于只睡眠了2s，所以先执行完，其实执行完loo_0()，线程执行的总时间是最慢的那个线程(loop_0() )的运行时间 123456starting at: Mon Feb 26 08:52:10 2018start loop_0 at: Mon Feb 26 08:52:10 2018start loop_1 at: Mon Feb 26 08:52:10 2018loop_1 done at: Mon Feb 26 08:52:12 2018loop_0 done at: Mon Feb 26 08:52:14 2018all done at Mon Feb 26 08:52:16 2018 使用锁对象 程序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#!usr/bin/python3# -*- coding:UTF-8 -*-import _threadfrom time import ctime, sleeploops = [4, 2]def loop(nloop, sec, lock): # nloop: 第几个线程 # sec: 时间 # lock: 分配的锁 print('start loop', nloop, 'at:', ctime()) sleep(sec) print('loop', nloop, 'done at:', ctime()) # 当时间到了的时候释放锁 lock.release()def main(): print('starting at:', ctime()) locks = [] nloops = range(len(loops)) for i in nloops: # 生成锁对象 # 通过allocate_lock()函数得到锁对象 # 通过acquire()取到每个锁 # 添加进locks列表 lock = _thread.allocate_lock() lock.acquire() locks.append(lock) for i in nloops: # 派生线程 # 传递循环号，时间、锁对象 _thread.start_new_thread(loop, (i, loops[i], locks[i])) for i in nloops: # 等待所有线程的锁都释放完了才执行主线程 while locks[i].locked(): pass print('all DONE at:', ctime())if __name__ == '__main__': main() 执行结果 未再设置时间等待所有线程执行结束，而是在线程全部结束后马上运行主线程代码 123456starting at: Mon Feb 26 09:37:39 2018start loop 1 at: Mon Feb 26 09:37:39 2018start loop 0 at: Mon Feb 26 09:37:39 2018loop 1 done at: Mon Feb 26 09:37:41 2018loop 0 done at: Mon Feb 26 09:37:43 2018all DONE at: Mon Feb 26 09:37:43 2018 threading模块threading模块提供了更高级别、功能更全面的线程管理,还包括许多非常好用的同步机制 threading模块的对象 对象 描述 Thread 表示一个执行线程的对象 Lock 锁原语对象(和thread模块中的锁一样) RLock 可重入锁对象，使单一线程可以（再次）获得已持有的锁（锁递归） Condition 条件变量对象，使得一个线程等待另一个线程满足特定的“条件”，比如改变状态或某个数据值 Event 条件变量的通用版本，任何数量的线程等待某个事件的发生，在改事件发生后所有线程将被激活 Semaphone 为线程间共享的有限资源提供一个“计数器”，如果没有可用资源时会被阻塞 BoundSemaphone 与Semaphone相似，不过它不允许超过初始值 Timer 与Thread相似，不过它要在运行前等待一段时间 Barrier 创建一个“障碍”,必须达到指定数量的线程后才可以继续 Thread类 Thread对象的属性和方法 属性 描述 name 线程名 ident 线程的标识符 daemon 布尔标志，表示这个线程是否是守护线程 Thread对象方法 init(group=None, target=None, name=None, args=(), kwargs={}, verbose=None, daemon=就返回None) 实例化一个线程对象，需要一个可调用的target，以及参数args或kargs。还可以传递name或group参数。daemon的值将会设定thread.daemon属性/标志 start() 开始执行该线程 run() 定义线程功能的方法(通常在子类中被应用开发者重写) join(timeout=None) 直至启动的线程终止之前一直挂起；除非给出了timeout(秒)，否则会一直阻塞 使用Thread类，可以有很多方法创建线程。其中比较相似的三种方法是： 创建Thread的实例，传给它一个函数 创建Thread的实例，传给它一个可调用的类实例 派生Thread的子类，并创建子类的实例 创建Thread的实例，传给它一个函数join() 方法可以让主线程等待所有线程执行完毕，或者在提供了超时时间的情况下达到超时时间。join()方法只有在需要等待线程完成的时候才是有用的。 代码 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/python# -*- coding:UTF-8 -*-import threadingfrom time import ctime, sleeploops = [4, 2]def loop(nloop, sec): print('start loop', nloop, 'at:', ctime()) sleep(sec) print('loop', nloop, 'done at:', ctime())def main(): print('starting at:', ctime()) threads = [] nloops = range(len(loops)) for i in nloops: t = threading.Thread(target=loop, args=(i, loops[i])) threads.append(t) for i in nloops: # 启动线程 threads[i].start() for i in nloops: # 等待所有线程结束 threads[i].join() print('all DONE at:', ctime())if __name__ == '__main__': main() 结果 123456starting at: Mon Feb 26 14:29:36 2018start loop 0 at: Mon Feb 26 14:29:36 2018start loop 1 at: Mon Feb 26 14:29:36 2018loop 1 done at: Mon Feb 26 14:29:38 2018loop 0 done at: Mon Feb 26 14:29:40 2018all DONE at: Mon Feb 26 14:29:40 2018 创建Thread的实例，传给它一个可调用的类实例将传递进去一个可调用类(实例)而不仅仅是一个函数 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/usr/bin/python3# -*- coding:UTF-8 -*-import threadingfrom time import ctime, sleeploops = [4, 2]class ThreadFunc(object): def __init__(self, func, args, name=''): self.name = name self.func = func self.args = args def __call__(self): # Thread类的代码将调用ThreadFunc对象，此时会调用这个方法 # 因为init方法已经设定相关值，所以不需要再将其传递给Thread()的构造函数 self.func(*self.args)def loop(nloop, sec): print('start loop', nloop, 'at:', ctime()) sleep(sec) print('loop ', nloop, 'done at:', ctime())def main(): print('starting at:', ctime()) threads = [] nloops = range(len(loops)) for i in nloops: # 创建所有线程 t = threading.Thread(target=ThreadFunc(loop, (i, loops[i]))) threads.append(t) for i in nloops: threads[i].start() for i in nloops: # 等待所有线程 threads[i].join() print('all DONE at:', ctime())if __name__ == '__main__': main() 结果 123456starting at: Mon Feb 26 14:47:28 2018start loop 0 at: Mon Feb 26 14:47:28 2018start loop 1 at: Mon Feb 26 14:47:28 2018loop 1 done at: Mon Feb 26 14:47:30 2018loop 0 done at: Mon Feb 26 14:47:32 2018all DONE at: Mon Feb 26 14:47:32 2018 派生Thread的子类，并创建子类的实例(推荐)将Thread子类化，而不是直接对其实例化。这将在定制线程对象的时候拥有更多的灵活性，也能简化线程创建的调用过程 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#!/usr/bin/python3# -*- coding:UTF-8 -*-import threadingfrom time import ctime, sleeploops = [4, 2]class MyThread(threading.Thread): def __init__(self, func, args, name=''): # 必须先调用基类的构造函数 threading.Thread.__init__(self) self.name = name self.func = func self.args = args def run(self): # 必须重写run()方法 self.func(*self.args)def loop(nloop, sec): print('start loop', nloop, 'at:', ctime()) sleep(sec) print('loop ', nloop, 'done at:', ctime())def main(): print('starting at:', ctime()) threads = [] nloops = range(len(loops)) for i in nloops: # 创建所有线程 t = MyThread(loop, (i, loops[i]), loop.__name__) threads.append(t) for i in nloops: threads[i].start() for i in nloops: # 等待所有线程 threads[i].join() print('all DONE at:', ctime())if __name__ == '__main__': main() 结果 123456starting at: Mon Feb 26 15:08:33 2018start loop 0 at: Mon Feb 26 15:08:33 2018start loop 1 at: Mon Feb 26 15:08:33 2018loop 1 done at: Mon Feb 26 15:08:35 2018loop 0 done at: Mon Feb 26 15:08:37 2018all DONE at: Mon Feb 26 15:08:37 2018 单线程和多线程执行的对比先后使用单线程和多线程执行三个独立的递归函数，代码中加入sleep()是为了减慢执行速度，能够更好的看到效果。 myThread.py 1234567891011121314151617181920212223#!/usr/bin/python3# -*- coding:UTF-8 -*-import threadingfrom time import ctime, sleepclass MyThread(threading.Thread): def __init__(self, func, args, name=''): threading.Thread.__init__(self) self.name = name self.func = func self.args = args def get_result(self): # 返回每一次的执行结果 return self.res def run(self): print('starting at:', ctime()) self.res = self.func(*self.args) print('done at:', ctime()) compare.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/usr/bin/python3# -*- coding:UTF-8 -*-from myThread import MyThreadfrom time import ctime, sleepdef fib(x): # 斐波拉契 sleep(0.005) if x &lt; 2: return 1 return fib(x-2)+fib(x-1)def fac(x): # 阶乘 sleep(0.1) if x &lt; 2: return 1 return x*fac(x-1)def sum(x): # 累加 sleep(0.1) if x &lt; 2: return 1 return x + sum(x-1)funcs = [fib, fac, sum]n = 12def main(): nfuncs = range(len(funcs)) print('***SINGLE THREAD***') for i in nfuncs: # 单线程顺序执行 print('starting', funcs[i].__name__, 'at:', ctime()) print(funcs[i](n)) print(funcs[i].__name__, 'finished at:', ctime(), '\n') print('\n ***MULTIPLE THREADS***') threads = [] for i in nfuncs: # 多线程执行 t = MyThread(funcs[i], (n,),funcs[i].__name__) threads.append(t) for i in nfuncs: threads[i].start() for i in nfuncs: threads[i].join() print(threads[i].get_result()) print('all DONE')if __name__ == '__main__': main() 结果 12345678910111213141516171819202122232425***SINGLE THREAD***starting fib at: Mon Feb 26 15:36:22 2018233fib finished at: Mon Feb 26 15:36:24 2018starting fac at: Mon Feb 26 15:36:24 2018479001600fac finished at: Mon Feb 26 15:36:25 2018starting sum at: Mon Feb 26 15:36:25 201878sum finished at: Mon Feb 26 15:36:26 2018 ***MULTIPLE THREADS***starting at: Mon Feb 26 15:36:26 2018starting at: Mon Feb 26 15:36:26 2018starting at: Mon Feb 26 15:36:26 2018done at: Mon Feb 26 15:36:28 2018done at: Mon Feb 26 15:36:28 2018done at: Mon Feb 26 15:36:29 201823347900160078all DONE]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python网络编程(二)]]></title>
    <url>%2F2018%2F02%2F24%2FPython%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[上篇对Python中的socket模块的简单应用做了描述和记录，下面便是对SocketServer模块和Twisted框架做一个简要的记录 socketserver模块socketserver是标准库的一个高级模块，它的目标是简化很多样板代码，它们是创建网络客户端和服务器所必需的代码。 socketserver模块类 类 描述 BaseServer 包含核心服务器功能和mix-in类的钩子；仅用于推导，这样不会创建这个类的实例；可以用TCPServer或UDPServer创建类的实例 TCPServer/UDPServer 基础的网络同步TCP/UDP服务器 UnixStreamServer/UnixDatagramServer 基于文件的基础同步TCP/UDP服务器 ForkingMixIn/ThreadingMixIn 核心派出或线程功能；只用作mix-in类与一个服务器类配合实现一些异步性；不能直接实例化这个类 ForkingTCPServer/ForkingUDPServer ForkingMaxIn和TCPServer/UDPServer的组合 ThreadingTCPServer/ThreadingUDPServer ThreadingMixIn和TCPServer/UDPServer的组合 BaseRequestHandler 包含处理服务请求的核心功能；仅用于推导，无法创建这个类的实例；可以使用StreamRequestHandler或DatagramRequestHandler创建类的实例 StreamRequestHandler/DatagramRequestHandler 实现TCP/UDP服务器的服务处理器 socketserver TCP服务器/客户端在原始服务器循环中，我们阻塞等待请求，当接收到请求时就对其提供服务，然后继续等待。在此处的服务器循环中，并非在服务器中创建代码，而是定义一个处理程序，当服务器接收到一个传入的请求时，服务器就可以调用 TCP服务器 1234567891011121314151617181920212223242526272829#!usr/bin/python3# -*- coding:UTF-8 -*-# 导入socketserver相关的类和time.ctime()的全部属性from socketserver import (TCPServer as TCP, StreamRequestHandler as SRH)from time import ctimeHOST = ''PORT = 12345ADDR = (HOST, PORT)class MyRequestHandler(SRH): # MyRequestHandler继承自StreamRequestHandler def handle(self): # 重写handle方法，当接收到一个客户端消息是，会调用handle()方法 print('...connected from:', self.client_address) # StreamRequestHandler将输入和输出套接字看做类似文件的对象 # 所以使用write()将字符串返回客户端，用readline()来获取客户端信息 self.wfile.write(bytes('[%s] %s' % ( ctime(), self.rfile.readline().decode('utf-8')), 'utf-8'))# 利用给定的主机信息和请求处理类创建了TCP服务器# 然后无限循环地等待并服务于客户端请求tcpServ = TCP(ADDR, MyRequestHandler)print('waiting for connection...')tcpServ.serve_forever() TCP客户端 12345678910111213141516171819202122232425#!usr/bin/python3# -*- coding:UTF-8 -*-from socket import *HOST = '127.0.0.1'PORT = 12345BUFSIZE = 1024ADDR = (HOST, PORT)while True: tcpSocket = socket(AF_INET, SOCK_STREAM) tcpSocket.connect(ADDR) data = input('&gt; ') if not data: break # 因为处理程序类对待套接字通信像文件一样，所以必须发送行终止符。 # 而服务器只是保留并重用这里发送的终止符 tcpSocket.send(bytes('%s\r\n' % data, 'utf-8')) data = tcpSocket.recv(BUFSIZE) if not data: break # 得到服务器返回的消息时，用strip()函数对其进行处理并使用print()自动提供的换行符 print(data.decode('utf-8').strip()) tcpSocket.close() socketserver TCP服务器和客户端运行结果 在客户端启动的时候连接了一次服务器，而每一次发送一个请求连接一次，所以发送了三个请求连接了四次服务器 TCP服务器运行结果 12345waiting for connection......connected from: (&apos;127.0.0.1&apos;, 51835)...connected from: (&apos;127.0.0.1&apos;, 51877)...connected from: (&apos;127.0.0.1&apos;, 51893)...connected from: (&apos;127.0.0.1&apos;, 51901) TCP客户端运行结果 1234567&gt; hello[Sat Feb 24 10:29:28 2018] hello&gt; hello[Sat Feb 24 10:29:44 2018] hello&gt; hi[Sat Feb 24 10:29:50 2018] hi&gt; Twisted框架的简单使用 Twisted是一个完整的事件驱动的网络框架，利用它既能使用也能开发完整的异步网络应用程序和协议。它不是Python标准库的一部分，所以需要单独下载和安装它1。 1pip3 install Twisted-17.9.0-cp36-cp36m-win_amd64.whl 安装成功显示 1234567891011Processing e:\迅雷下载\twisted-17.9.0-cp36-cp36m-win_amd64.whlRequirement already satisfied: Automat&gt;=0.3.0 in e:\python\python36\lib\site-packages (from Twisted==17.9.0)Requirement already satisfied: zope.interface&gt;=4.0.2 in e:\python\python36\lib\site-packages (from Twisted==17.9.0)Requirement already satisfied: incremental&gt;=16.10.1 in e:\python\python36\lib\site-packages (from Twisted==17.9.0)Requirement already satisfied: hyperlink&gt;=17.1.1 in e:\python\python36\lib\site-packages (from Twisted==17.9.0)Requirement already satisfied: constantly&gt;=15.1 in e:\python\python36\lib\site-packages (from Twisted==17.9.0)Requirement already satisfied: attrs in e:\python\python36\lib\site-packages (from Automat&gt;=0.3.0-&gt;Twisted==17.9.0)Requirement already satisfied: six in e:\python\python36\lib\site-packages (from Automat&gt;=0.3.0-&gt;Twisted==17.9.0)Requirement already satisfied: setuptools in e:\python\python36\lib\site-packages (from zope.interface&gt;=4.0.2-&gt;Twisted==17.9.0)Installing collected packages: TwistedSuccessfully installed Twisted-17.9.0 Twisted Reactor TCP 服务器/客户端TCP服务器 123456789101112131415161718192021222324252627282930313233#!usr/bin/python3# -*- coding:UTF-8 -*-# 常用模块导入，特别是twisted.internet的protocol和reactorfrom twisted.internet import protocol, reactorfrom time import ctime# 设置端口号PORT = 12345class TWServProtocol(protocol.Protocol): # 继承Protocol类 def connectionMade(self): # 重写connectionMade()方法 # 当一个客户端连接到服务器是会执行这个方法 client = self.client = self.transport.getPeer().host print('...connected from:', client) def dataReceived(self, data): # 重写dataReceived()方法 # 当服务器接收到客户端通过网络发送的一些数据的时候会调用此方法 self.transport.write(bytes('[%s] %s' % ( ctime(), data.decode('utf-8')), 'utf-8'))# 创建一个协议工厂，每次得到一个接入连接是，制造协议的一个实例# 在reactor中安装一个TCP监听器，以此检查服务请求# 当接收到一个请求时，就是创建一个就是创建一个TWServProtocol实例来处理客户端事务factory = protocol.Factory()factory.protocol = TWServProtocolprint('waiting for connection...')reactor.listenTCP(PORT, factory)reactor.run() TCP客户端 12345678910111213141516171819202122232425262728293031323334353637383940#!usr/bin/python# -*- coding:UTF-8 -*-from twisted.internet import protocol, reactorHOST = '127.0.0.1'PORT = 12345class TWClientProtocol(protocol.Protocol): def sendData(self): # 需要发送数据时调用 # 会在一个循环中继续，直到不输入任何内容来关闭连接 data = input('&gt; ') if data: print('...send %s...' % data) self.transport.write(bytes(data, 'utf-8')) else: self.transport.loseConnection() def connectionMade(self): # self.sendData() def dataReceived(self, data): print(data.decode('utf-8')) self.sendData()class TWClientFactory(protocol.ClientFactory): # 创建了一个客户端工厂 protocol = TWClientProtocol clientConnectionLost = clientConnectionFailed = \ lambda self, connector, reason: reactor.stop()# 创建了一个到服务器的连接并运行reactor，实例化了客户端工厂# 因为这里不是服务器，需要等待客户端与我们通信# 并且这个工厂为每一次连接都创建一个新的协议对象。# 客户端创建单个连接到服务器的协议对象，而服务器的工厂则创建一个来与客户端通信reactor.connectTCP(HOST, PORT, TWClientFactory())reactor.run() TCP服务器和客户端运行结果 服务器结果 12waiting for connection......connected from: 127.0.0.1 客户端结果 1234567&gt; hello...send hello...[Sat Feb 24 11:19:49 2018] hello&gt; hi...send hi...[Sat Feb 24 11:20:02 2018] hi&gt; 1.需要安装python对应的版本和位数 ↩]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python网络编程(一)]]></title>
    <url>%2F2018%2F02%2F22%2FPython%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[使用Python的一些模块来创建网络应用程序 socket()函数模块要创建套接字，必须使用socket.socket()函数socket(socket_family, socket_type, protocol = 0),其中socket_family是 AF_UNIX或 AF_INET,socket_type是 SOCK_STREAM 或 SOCK_DGRAM。1protocol通常省略，默认为0。 创建TCP/IP套接字 1tcpSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 创建UDP/IP套接字 1udpSock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) 套接字对象内接方法 名称 描述 服务器套接字方法 s.bind() 将地址(主机名、端口号对)绑定到套接字上 s.listen() 设置并启动TCP监听器 s.accept() 被动接受TCP客户端连接，一直等待知道连接到达(阻塞) 客户端套接字方法 s.connect() 主动发起TCP服务器连接 s.connect_ex() connect()的扩展版本，此时会以错误码的形式返回问题，而不是抛出一个异常 普通的套接字方法 s.recv() 接受TCP消息 s.recv_into() 接受TCP消息到指定的缓冲区 s.send() 发送TCP消息 s.sendall() 完整地发送TCP消息 s.recvfrom() 接受UDP消息 s.recvfrom_into() 接受UDP消息到指定的缓冲区 s.sendto() 发送UDP消息 s.getpeername() 连接到套接字(TCP)的远程地址 s.getsockname() 当前套接字的地址 s.getsockopt() 返回给定套接字选项的值 s.setsockopt() 设置给定套接字选项的值 s.shutdown() 关闭连接 s.close() 关闭套接字 s.detach() 在未关闭文件描述符的情况下关闭套接字，返回文件描述符 s.ioctl() 控制套接字的模式(仅支持Windows) 面向阻塞的套接字方法 s.setblocking() 设置套接字的阻塞或非阻塞模式 s.settimeout() 设置阻塞套接字操作的超时时间 s.gettimeout() 获取阻塞套接字操作的超时时间 面向文件的套接字方法 s.fileno() 套接字的文件描述符 s.makefile() 创建与套接字关联的文件对象 数据属性 s.family 套接字家族 s.type 套接字类型 s.proto 套接字协议 socket模块属性 属性名称 描述 数据属性 AF_UNIX、AF_INET、AF_INET6、AF_NETLINK、AF_TIPC Python中支持的套接字地址家族 SO_STREAM、SO_DGRAM 套接字类型(TCP=流，UDP=数据报) has_ipv6 指示是否支持IPv6的布尔标记 异常 error 套接字相关错误 herror 主机和地址相关错误 gaierror 地址相关错误 timeout 超时时间 函数 socket() 以给定的地址家族、套接字类型和协议类型(可选) 创建一个套接字对象 socketpair() 以给定的地址家族、套接字类型和协议类型(可选) 创建一个套接字对象 create_connection() 常规函数，它接收一个地址(主机号，端口号)对，返回套接字对象 fromfd() 以一个打开的文件描述符创建一个套接字对象 ssl() 通过套接字启动一个安全套接字层连接；不执行证书验证 getaddrinfo() 获取一个五元组序列形式的地址信息 getnameinfo() 给定一个套接字地址，返回(主机名，端口号)二元组 getfqdn() 返回完整的域名 gethostname() 返回当前主机名 gethostbyname() 将一个主机名映射到它的IP地址 gethostbyname_ex() gethostbyname()的扩展版本，它返回主机名、别名主机集合和IP地址列表 gethostbyaddr() 讲一个IP地址映射到DNS信息；返回与gethostbyname_ex()相同的三元组 getprotobyname() 将一个协议名(如‘TCP’)映射到一个数字 getservbyname()/getservbyport() 将一个服务名映射到一个端口号，或者反过来；对于任何一个函数来说，协议名都是可选的 ntohl()/ntohs() 将来自网络的整数装换为主机字节序 htonl()/htons() 将来自主机的整数转换为网络字节序 inet_aton()/inet_ntoa() 将IP地址八进制字符串转换成32位的包格式，或者反过来(仅用于IPv4地址) inet_pton()/inet_ntop() 将IP地址字符串转换成打包的二进制格式，或者反过来(同时适用于IPv4和IPv6) getdefaulttimeout()/setdefaulttimeout() 以秒(浮点数)为单位返回默认套接字超时时间；以秒(浮点数)为单位设置默认套接字超时时间 详情参阅socket模块文档 创建TCP服务器/客户端TCP服务器 下面是TCP服务器端的通用伪码，这是设计服务器的一种方式，可根据需求修改来操作服务器 123456789ss = socket() #创建服务器套接字ss.bind() #套接字与地址绑定ss.listen() #监听连接inf_loop: #服务器无线循环 cs = ss.accept() #接受客户端连接 comm_loop: #通信循环 cs.recv()/cs.send() #对话(接收/发送) cs.close() #关闭客户端套接字ss.close() #关闭服务器套接字 TCP时间戳服务器 12345678910111213141516171819202122232425262728293031323334353637383940#!usr/bin/python3# -*- coding:UTF-8 -*-# 导入socket模块和time.ctime()的所有属性from socket import *from time import ctime# HOST变量是空白，这是对bind()方法的标识，标识它可以使用任何可用的地址# 选择一个随机的端口号# 缓冲区大小为1KBHOST = ''PORT = 12345BUFSIZE = 1024ADDR = (HOST, PORT)# 分配了TCP服务套接字# 将套接字绑定到服务器地址# 开启TCP的监听调用# listen()方法的参数是在连接被转接或拒绝之前，传入连接请求的最大数tcpSerSock = socket(AF_INET, SOCK_STREAM)tcpSerSock.bind(ADDR)tcpSerSock.listen(5)while True: # 服务器循环，等待客户端的连接的连接 print('waiting for connection...') tcpCliSock, addr = tcpSerSock.accept() print('...connected from:', addr) while True: # 当一个连接请求出现时，进入对话循环，接收消息 data = tcpCliSock.recv(BUFSIZE) if not data: # 当消息为空时，退出对话循环 # 关闭客户端连接，等待下一个连接请求 break tcpCliSock.send(bytes('[%s] %s' % ( ctime(), data.decode('utf-8')), 'utf-8')) tcpCliSock.close() TCP客户端 下面是TCP客户端的通用伪码 12345cs = socket() #创建客户端套接字cs.connect() #尝试连接服务器comm_loop: #通信循环 cs.send()/cs.recv #对话(发送/接收)cs.close() #关闭客户端套接字 TCP时间戳客户端 1234567891011121314151617181920212223242526272829303132333435#!usr/bin/python3# -*- coding: UTF-8 -*-# 导入socket模块所有属性from socket import *# 服务器的主机名# 服务器的端口号,应与服务器设置的完全相同# 缓冲区大小为1KBHOST = '127.0.0.1'PORT = 12345BUFSIZE = 1024ADDR = (HOST, PORT)# 分配了TCP客户端套接字# 主动调用并连接到服务器tcpCliSock = socket(AF_INET, SOCK_STREAM)tcpCliSock.connect(ADDR)while True: # 无限循环，输入消息 data = bytes(input('&gt; '), 'utf-8') if not data: # 消息为空则退出循环 break # 发送输入的信息 # 接收服务器返回的信息，最后打印 tcpCliSock.send(data) data = tcpCliSock.recv(BUFSIZE) if not data: # 消息为空则退出循环 break print(data.decode('utf-8'))# 关闭客户端tcpCliSock.close() TCP服务器和客户端运行结果 在运行程序时，必须 首先运行服务器 程序，然后再运行客户端程序。如果先运行客户端程序，将会报未连接到服务器的错误。 按正确的顺序启动程序后，在客户端输入信息，将会接收到加上时间戳处理后的信息，如果直接输入回车，将会关闭客户端，而服务器将会等待下一个连接请求 服务器运行结果 123waiting for connection......connected from: (&apos;127.0.0.1&apos;, 53220)waiting for connection... 客户端运行结果 12345678&gt; hello[Fri Feb 23 14:22:58 2018] hello&gt; hi[Fri Feb 23 14:23:02 2018] hi&gt; hello world[Fri Feb 23 14:23:09 2018] hello world&gt;Process finished with exit code 0 创建UDP服务器/客户端UDP服务器 下面是UDP服务器的伪码 12345ss = socket() #创建服务器套接字ss.bind() #绑定服务器套接字inf_loop: #服务器无线循环 cs = ss.recvfrom()/ss.sendto() #关闭(接收/发送)ss.close() #关闭服务器套接字 UDP时间戳服务器 1234567891011121314151617181920212223#!usr/bin/python3# -*- coding:UTF-8 -*-# 导入socket模块和time.ctime()的全部属性from socket import *from time import ctime# 与TCP相同，由于是无连接，所以没有调用监听传入连接HOST = ''PORT = 12345BUFSIZE = 1024ADDR = (HOST, PORT)udpSerSock = socket(AF_INET, SOCK_DGRAM)udpSerSock.bind(ADDR)while True: # 进入循环等待消息，一条消息到达时，处理并返回它，然后等待下一条消息 print('waiting for message...') data, addr = udpSerSock.recvfrom(BUFSIZE) udpSerSock.sendto(bytes('[%s] %s' % ( ctime(), data.decode('utf-8')), 'utf-8'), addr) print('...received from and returned to:', addr) UDP客户端 下面是客户端的伪码 1234cs = socket() #创建客户端套接字comm_loop: #通信循环 cs.sendto()/cs.recvfrom() #对话(发送/接收)cs.close() #关闭客户端套接字 UDP时间戳客户端 12345678910111213141516171819202122#!usr/bin/python3 # -*- coding:UTF-8 -*- from socket import * HOST = '127.0.0.1' PORT = 12345 BUFSIZE = 1024 ADDR = (HOST, PORT) udpClienSock = socket(AF_INET, SOCK_DGRAM) while True: data = bytes(input('&gt;'), 'utf-8') if not data: break udpClienSock.sendto(data, ADDR) data, ADDR = udpClienSock.recvfrom(BUFSIZE) if not data: break print(data.decode('utf-8')) udpClienSock.close() UDP服务器和客户端运行结果 因为UDP面向无连接的服务，所以程序的启动顺序没有要求。当服务器处理完一个数据报之后在等待下一个继续处理 服务器运行结果 12345waiting for message......received from and returned to: (&apos;127.0.0.1&apos;, 51434)waiting for message......received from and returned to: (&apos;127.0.0.1&apos;, 51434)waiting for message... 客户端运行结果 1234567&gt;hello[Fri Feb 23 15:23:57 2018] hello&gt;hi[Fri Feb 23 15:24:03 2018] hi&gt;Process finished with exit code 0 1.AF_UNIX 是基于文件的套接字，代表 地址家族(address family):UNIX，AF_INET 是基于网络的套接字，代表 地址家族：因特网， AF_INET6 用于底6版因特网协议(IPv6)寻址。 SOCK_STREAM 表示面向连接的TCP套接字， SOCK_DGRAM 代表无连接的UDP套接字。 ↩]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python正则表达式(三)]]></title>
    <url>%2F2018%2F02%2F12%2FPython%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[在之前的两篇博文中，已经对正则表达式基本及核心的知识点进行了罗列和总结。而对于正则表达式的使用却缺乏实践。本文将基于《Python核心编程(第三版)》的练习题进行一些练习。 正则表达式 识别后续的字符串：“bat”、“bit”、“but”、“hat”、“hit”或者“hut”。 1234567891011121314import remode = re.compile(r'bat|bit|but|hat|hit|hut')#mode = re.compile(r'[bh][iau]t')strs = ['bat', 'bit', 'but', 'hat', 'hit', 'hut']for s in strs: if mode.match(s) is not None:mode.match(s).group()#输出结果'bat''bit''but''hat''hit''hut' 匹配由单个空格分隔的任意单词对，也就是姓和名。 12345678import remode = re.compile(r'^[A-Za-z]+ [A-Za-z]+$')strs = ['david Bob', 'D.Jone Steven', 'Lucy D May']for s in strs: if mode.match(s) is not None:mode.match(s).group()#输出结果'david Bob' 匹配由单个逗号和单个空白符分隔的任何单词和单个字母，如姓氏的首字母。 123456789import remode = re.compile(r'[A-Za-z]+,\s[A-Za-z]+')strs = ['david, Bob', 'D.Jone, Steven', 'Lucy, D, May']for s in strs: if mode.match(s) is not None:mode.match(s).group()#输出结果'david, Bob''Lucy, D' 匹配所有有效Python 标识符1的集合。 123456789101112import remode = re.compile(r'[^0-9][\w_]+')#用in排除关键字strs = ['1var', 'v_ar', '_var', 'var', 'var_9', 'var_']for s in strs: if mode.match(s) is not None:mode.match(s).group()#输出结果'v_ar''_var''var''var_9''var_' 根据读者当地的格式，匹配街道地址（使你的正则表达式足够通用，来匹配任意数量的街道单词，包括类型名称）。例如，美国街道地址使用如下格式：1180 BordeauxDrive。使你的正则表达式足够灵活，以支持多单词的街道名称，如3120 De la CruzBoulevard。 123456789import remode = re.compile(r'^\d&#123;4&#125;( [A-Z][a-z]+)+$')strs = ['1221 Bordeaux Drive', '54565 Bordeaux Drive', 'Bordeaux Drive', '1221 Bordeaux Drive Drive']for s in strs: if mode.match(s) is not None:mode.match(s).group()#输出结果'1221 Bordeaux Drive''1221 Bordeaux Drive Drive' 匹配以“www”起始且以“.com”结尾的简单Web 域名；例如，www://www. yahoo.com/。选做题：你的正则表达式也可以支持其他高级域名，如.edu、.net 等（例如，http://www.foothill.edu）。 1234567891011import remode = re.compile(r'^(http[s]?://)?www\.(\w+\.)+(com|net|edu)$')strs=['https://www.baidu.com', 'http://www.bilibili.com', 'www.baidu.com', 'baidu.com', 'www.cqupt.edu']for s in strs: if mode.match(s) is not None:mode.match(s).group()#输出结果'https://www.baidu.com''http://www.bilibili.com''www.baidu.com''www.cqupt.edu' 匹配所有能够表示Python 整数的字符串集。 12345678910import remode = re.compile(r'^\d+[lL]?$')strs = ['123', '123l', '12312L']for s in strs: if mode.match(s) is not None:mode.match(s).group()#输出结果'123''123l''12312L' 匹配所有能够表示Python 长整数的字符串集。 123456789import remode = re.compile(r'^\d+[lL]$')strs = ['123', '123l', '12312L']for s in strs: if mode.match(s) is not None:mode.match(s).group()#输出结果'123l''12312L' 匹配所有能够表示Python 浮点数的字符串集。 12345678910import remode = re.compile(r'(0|[1-9]\d*)(\.\d+)?$')strs = ['00.10', '0.123', '12.23', '12', '12.36l']for s in strs: if mode.match(s) is not None:mode.match(s).group() #输出结果'0.123''12.23''12' 匹配所有能够表示Python 复数的字符串集。 12345678910import remode = re.compile(r'^((0|[1-9]\d*)(\.\d+)?\+)?((0|[1-9]\d*)(\.\d+)?j)?$')strs = ['12.3+1.2j', '1+2j', '4j']for s in strs: if mode.match(s) is not None:mode.match(s).group() #输出结果'12.3+1.2j''1+2j''4j' 匹配所有能够表示有效电子邮件地址的集合（从一个宽松的正则表达式开始，然后尝试使它尽可能严谨，不过要保持正确的功能）。 123456789101112import remode = re.compile(r'^\w+@(\w+\.)+(com|com\.cn|net)$')strs = ['12345@qq.com', 'sina@163.com', 'qq@sina.com.cn', 'net@21cn.com', 'new123@163.sina.com']for s in strs: if mode.match(s) is not None:mode.match(s).group() #输出结果'12345@qq.com''sina@163.com''qq@sina.com.cn''net@21cn.com''new123@163.sina.com' type()。内置函数type()返回一个类型对象，如下所示，该对象将表示为一个Pythonic类型的字符串。 12345678910import remode = re.compile(r'&lt;type \'(.*)\'&gt;')strs = ['&lt;type \'int\'&gt;', '&lt;type \'float\'&gt;', '&lt;type \'builtin_function_or_method\'&gt;']for s in strs: if mode.match(s) is not None:mode.match(s).group(1)#输出结果'int''float''builtin_function_or_method' 处理日期。1.2 节提供了来匹配单个或者两个数字字符串的正则表达式模式，来表示1～9 的月份(0?[1-9])。创建一个正则表达式来表示标准日历中剩余三个月的数字。 12345678910import remode = re.compile(r'1[0-2]')strs = ['10', '11', '12']for s in strs: if mode.match(s) is not None:mode.match(s).group()#输出结果'10''11''12' 创建一个允许使用连字符的正则表达式，但是仅能用于正确的位置。例如，15 位的信用卡号码使用4-6-5 的模式，表明4 个数字-连字符-6 个数字-连字符-5 个数字；16 位的信用卡号码使用4-4-4-4 的模式。 123456789import remode = re.compile(r'\d&#123;4&#125;-((\d&#123;6&#125;-\d&#123;5&#125;)|(\d&#123;4&#125;-\d&#123;4&#125;-\d&#123;4&#125;))')strs = ['1234-567890-12345', '1234-5678-8012-3456']for s in strs: if mode.match(s) is not None:mode.match(s).group()#输出结果'1234-567890-12345''1234-5678-8012-3456' 1.标识符有字母、数字、下划线组成，但不能由数字开头 ↩]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python正则表达式(二)]]></title>
    <url>%2F2018%2F02%2F10%2FPython%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[正则表达式的匹配规则基本已经在上一篇博文中全部罗列出来了，下面便是结合到具体语言进行学习和练习了。由于个人兴趣和想要专研的方向，在这里将会使用Python 1 语言进行描述。 正则表达式和Python语言re模块：核心函数和方法 函数方法 描述 仅仅是re函数模块 compile(pattern, flags=0) 使用任何可选的标记来编译正则表达式的模式，然后返回一个正则表达式对象 re模块函数和正则表达式对象的方法 match(pattern, string, flags=0) 尝试使用带有可选的标记的正则表达式的模式来匹配字符串，如果匹配成功，就返回匹配对象；如果失败，就返回None search(pattern, string, flags=0) 使用可选标记搜索字符串中第一次出现的正则表达式模式。如果匹配成功，则返回匹配对象；如果匹配失败，怎返回None findall(pattern, string [,flags]) 查找字符串中所有(非重复)出现的正则表达式模式，并返回一个匹配列表 finditer(pattern, string[,flags]) 与findall()函数相同，但返回的不是一个列表，而是一个迭代器。对于每一次匹配，迭代器都返回一个匹配对象 split(pattern, string, max=0) 根据正则表达式的模式分隔符，split函数将字符串分割为列表，然后返回成功的列表，分割最多操作max次(默认分割所有匹配成功的位置) sub(pattern, repl, string, count=0) 使用repl替换所有正则表达式的模式在字符串中出现的位置，除非定义count，否则就讲替换所有出现的位置（另见subn()函数，该函数返回替换操作的数目） purge() 清除隐式编译的正则表达式模式 常见的匹配对象方法 group(num=0) 返回整个匹配对象，或者编号为num的特定子组 groups(default=None) 返回一个包含所有匹配子组的元组(如果没有成功匹配，则返回一个空元组) groupdict(default=None) 返回一个包含所有匹配的命名子组的字典，所有的子组名称作为字典的键(如果没有成功匹配，则返回一个空字典) 常用的模块属性（用于大多数正则表达式函数的标记） re.I,re.IGNORECASE 不去分大小写的匹配 re.L,re.LOCALE 根据所使用的本地语言环境通过\w、\w、\b、\B、\s、\S实现匹配 re.M,re.MULTILINE ^和$分别匹配目标字符串中行的起始和结尾，而不是严格匹配整个字符串本身的起始和结尾 re.S,re.DOTALL “.”(点号)通常匹配除了\n(换行符)之外的所有单个字符：该标记表示”.”(点号)能匹配全部字符 re.X,re.VERBOSE 通过反斜线转移，否则所有空格加上#(以及在该行中后续文字)都被忽略，除非在一个字符类中或者允许注释并且提高可读性 部分方法总结 compile(pattern, flags=0)2 使用预编译使用推荐的方式，但不是必须的，可以通过设置标志位(上表已罗列出使用频繁的标记，详情可以查阅文档),标志位通过 （|）合并 group(num=0) 和 groups(default=None) 匹配对象3的两个主要方法。 group() 要么返回整个匹配对象，要么按要求返回特定子组。 groups() 仅返回一个包含唯一或全部子组的元组。如果没有子组的要求，group() 返回整个匹配，groups() 返回一个空元组。 match(pattern, string, flags=0) match() 方法试图从字符串的起始部分对模式进行匹配。如果匹配成功，返回一个匹配对象；如果失败就返回None 12345678910111213 #匹配成功 m = re.match('foo', 'foo') #模式匹配字符串 if m is not None: #如果匹配成功，就输出匹配内容 m.group()'foo' #输出结果#匹配失败m = re.match('foo', 'Bfoo') #模式匹配字符串if m is not None: #如果匹配成功，就输出匹配内容 m.group() #因为起始字符为'B',所以匹配不成功，无任何输出 search(pattern, string, flags=0) search() 的工作方式和 match() 相同，不同之处在于 search() 会用它的字符串参数在任意位置对给定正则表达式模式搜索第一次出现的匹配情况。如果搜索到成功的匹配，就返回一个匹配对象；否则，就返回None。 123456#将上面使用match()方法匹配的串改用search()匹配m = re.search('foo', 'Bfoo') #模式匹配字符串if m is not None: #如果匹配成功，就输出匹配内容 m.group()'foo' #可以看到就算起始位置未能匹配，也能匹配成功 findall(pattern, string[,flags]) 和 finditer(pattern, string[,flags]) findall() 总是返回一个列表，如果没有找到匹配对象，返回一个空列表 finditer() 是一个与 findall() 类似但更节省内存的变体，finditer() 在匹配对象中迭代4 1234567891011121314#findall()匹配re.findall('car', 'carry the barcardi to the car') #模式匹配字符串['car', 'car', 'car'] #返回结果#finditer()匹配iter = re.finditer('car', 'carry the barcardi to the car') #模式匹配字符串for i in iter: #遍历迭代器 print(i.group())#输出结果carcarcar sub(pattern, repl, string, count=0) 和 subn(pattern, repl, string, count=0) sub() 和 subn() 用于实现搜索和替换功能。两者都是将某字符串中所有匹配正则表达式的部分进行某种形式的替换。和 sub() 不同的是，subn() 返回一个表示替换的总数，替换后的字符串和表示替换总数的数字一起作为一个拥有两个元素的元组返回 12345678910#sub()re.sub('car', 'cat', 'My car is not only a car.') #模式匹配字符串'My cat is not only a cat.' #输出结果#subn()re.subn('car', 'cat', 'My car is not only a car.') #模式匹配字符串('My cat is not only a cat.', 2) #输出结果 split(pattern, string, max=0) 正则表达式对象的 split() 方法和字符串的工作方式类似，但它是基于正则表达式的模式分割字符串。 123456789101112131415161718192021222324re.split(':', 'str1:str2:str3') #模式匹配字符串['str1', 'str2', 'str3'] #输出结果，与'str1:str2:str3'.split(':')相同#split()复杂用法#使用split()基于逗号分割字符串，如果空格紧跟在5个数字或者两个大写字母之后，就用split()分割该空格#使用(?=)正向前视断言，不适用输入字符串 而是使用后面的空格作为分割字符串import reDATA = ( 'Mountain View, CA 94040', 'Sunnyvale, CA', 'Los Altos, 94023', 'Cupertino 95014', 'Palo Alto CA',)for datum in DATA: print(re.split(', |(?= (?:\d&#123;5&#125;|[A-Z]&#123;2&#125;)) ', datum))#输出结果['Mountain View', 'CA', '94040']['Sunnyvale', 'CA']['Los Altos', '94023']['Cupertino', '95014']['Palo Alto', 'CA'] 符号的使用| 与 . 和 [] 包括择一匹配符号|、点号.，点号不匹配非字符或换行付\n（即空字符） 字符集[]中的字符只取其一 重复、特殊字符5以及分组 ?操作符表示前面的模式出现零次或一次+操作符表示前面的模式出现至少一次*操作符表示前面的模式出现任意次(包括0次)分组从左起第一个括号开始算第一个分组 123456789101112131415m = re.match('(\w(\w\w))-(\d\d\d)','abc-123')m.group() #完整匹配'abc-123' #输出结果m.group(1) #第一组'abc' #输出结果 m.group(2) #第二组'bc' #输出结果m.group(3) #第三组'123' #输出结果m.groups() #全部子组('abc', 'bc', '123') #输出结果 1.这里Python指代的是Python3.6.4 ↩2.预编译可以提升执行效率，而 re.compile() 方法提供了这个功能。模块函数会对已编译的对象进行缓存，所以无论使用 match() 和 search() 在执行时编译的正则表达式,还是使用 compile() 编译的表达式,在再次使用时都会查询缓存。但使用 compile() 同样可以节省查询缓存的时间 ↩3.除了正则表达式对象之外，还有另外一个对象类型：匹配对象。这些是成功调用 match() 和 search() 返回的对象。 ↩4.如果遇到无法调用 next()方法，可以使用 __next__()方法代替。 ↩5.特殊字符的详情可以参考上一篇博文 ↩]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python正则表达式(一)]]></title>
    <url>%2F2018%2F02%2F09%2FPython%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[在Python的学习过程中，正则表达式始终是一道绕不过去的坎.无论提取服务器日志文件还是爬取网页，正则表达式始终扮演着至关重要的角色。下面便对自己学习过程中的一些正则表达式基础做一个总结。 特殊符号和字符 表示法 描述 正则表达式示例 备注 符号 literal 匹配文本字符串的字面值literal foo 只是匹配foo，相当于取等 re1&#124; re2 匹配正则表达式re1或re2 foo&#124; bar 匹配foo或者bar，二选一 . 匹配任何字符(除了\n之外) a.a 匹配axa、aaa、aca等，两个a中间可以是除了\n的任意字符 ^ 匹配字符串起始部分 ^Foo 匹配Foo，不匹配aFoo $ 匹配字符串终止部分 Bar$ 只匹配Bar,不匹配aBar等 * 匹配0次或者多次前面出现的正则表达式 [A-Za-z0-9]* 匹配任意多个字母或数字 + 匹配1次或者多次前面出现的正则表达式 [A-Za-z0-9]+ 匹配一到多个个字母或数字 ? 匹配0次或者1次前面出现的正则表达式 [A-Za-z0-9] 要么有一个字母或数字要么没有 {N} 匹配N次前面出现的正则表达式 [0-9]{3} 匹配三个数字 {M,N} 匹配M~N次前面出现的正则表达式 [0-9]{5,9} 匹配5到9个数字(包括5个和9个) […] 匹配来自字符集的任意单一字符 [aeiou] 匹配一个元音字母 [..x~y..] 匹配x~y范围内的任意单一字符 [A-Za-z] 匹配任意一个英文字母 [^…] 不匹配此字符集中出现的任何一个字符，包括某一范围的字符(如果在此字符集中出现) [\^aeiou][\^A-Za-z0-9] 匹配一个非元音字母和一个非字母数字字符 (*&#124;+&#124;?&#124;{})? 用于匹配上面频繁出现/重复出现符号的非贪婪版本(*、+、?、{}) .*?[a-z] (非贪婪是指尽可能少的匹配) (…) 匹配封闭的正则表达式,然后另存为子组 f(oo&#124; u)bar 匹配foobar,fubar 特殊字符 \d 匹配任何十进制数字，与[0-9]一致(\D和\d相反，不匹配任何非数值型的数字) data\d+.txt 匹配data1.txt、data12.txt \w 匹配任何字母数字字符，与[A-Za-z0-9]相同(\W与之相反) [A-Za-z_]\w+ 匹配任意字母或_加一个或多个字母数字字符(asda,_asda) \s 匹配任何空格字符，与[\n\t\r\v\f]相同(\S与之相反) of\sthe 匹配of the (\n:换行符&#124;\t:水平制表符&#124;\r:回车&#124;\v:垂直制表符&#124;\f:换页符) \b 匹配任何单词边界(\B与之相反) \bThe\b 匹配of The a，不匹配ofThe a \N 匹配已保存的子组N(与上面(…)配合使用) price:\16 匹配price:和前面第16个子组的值 \c 逐字匹配任何特殊字符(即仅按字面意义匹配，不包含特殊含义，\为对特殊字符的转义表示) * 匹配* \A(\Z) 匹配字符串的起始(结束)(另见上面的^和$) \ADear 匹配以Dear开头的 扩展表示法 （?iLmsux） 在正则表达式中嵌入一个或多个特殊”标记”参数(或者通过函数/方法) （?x）,(?im) (?:…) 表示一个匹配不用保存的分组 (?:\w+.)* 匹配任意多个一个或多个字母数字字符与.的组合但不保存改分组 (?P…) 像一个仅由name标识而不是数字ID标识的正则分组匹配 (?P) 给匹配的分组命名为data (?P=name) 在同一个字符串中匹配由(?P)分组之前的文本 (?P=data) 匹配名字为data的串 (?#…) 表示注释，所有内容都被忽略 (?#comment) (?=…) 匹配条件是如果…出现在之后的位置，而不使用输入字符串；称作正向前视断言 (?=.com) 如果一个字符串后面跟着“.com”才做匹配操作，并不适用任何目标字符串 (?!…) 匹配条件是如果…不出现在之后的位置，而不使用输入字符串；称作负向前视断言 (?!.net) 如果一个字符串后面不是跟着“.net”，才做匹配操作 (?&lt;=…) 匹配条件是如果…出现在之前的位置，而不使用输入字符串；称作正向后视断言 (?&lt;=800-) 如果字符串之前为“800-”才做匹配，并不使用任何输入字符串 (?&lt;!…) 匹配条件是如果…不出现在之前的位置，而不使用输入字符串；称作负向后视断言 (?&lt;!192\.168\.) 如果一个字符串之前不是“192.168.”才做匹配，并不适用任何输入字符串 (?(id/name)Y&#124;N 如果分组所提供的id或name(名称)存在，就返回正则表达式的条件匹配Y，如果不存在，就返回N;N是可选项 (?(1)y&#124;x) 如果一个匹配组1(\1)存在就y匹配；否则，就与x匹配 以上为正则表达式的一些基本的符号定义与用法，熟练掌握这些符号是写出高效表达式的基础。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
</search>
