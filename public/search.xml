<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[pandas入门(一)]]></title>
    <url>%2F2018%2F03%2F19%2Fpandas%E5%85%A5%E9%97%A8-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[SeriesSeries1 是一种类似于一维数组的对象，它由一组数据(各种NumPy数据类型)以及一组与之相关的数据标签(即索引)组成。Series的字符串表现形式为：索引在左边，值在右边。如果没有为数据指定索引，会自动创建一个0到n-1的整数型索引。可以通过index参数指定索引来代替自动生成的索引:12345678910111213141516171819In [4]: ser1 = Series([1,2,2,3])In [5]: ser1Out[5]:0 11 22 23 3dtype: int64In [6]: ser2 = Series([1,2,2,3],index=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])In [7]: ser2Out[7]:a 1b 2c 2d 3dtype: int64 可以通过索引的方式选取Series中的单个或一组值；数组运算(布尔型数组进行过滤，标量乘法，应用数学函数)都会保留索引和值之间的连接；Series可以看成是一个定长的有序字典，可以用在原本需要字典参数的函数中:1234567891011121314151617181920212223242526272829In [8]: ser2[&apos;a&apos;]Out[8]: 1In [9]: ser2[[&apos;a&apos;,&apos;b&apos;]]Out[9]:a 1b 2dtype: int64In [10]: ser2*2Out[10]:a 2b 4c 4d 6dtype: int64In [11]: ser2[ser2&gt;=2]Out[11]:b 2c 2d 3dtype: int64In [12]: &apos;a&apos; in ser2Out[12]: TrueIn [13]: &apos;g&apos; in ser2Out[13]: False 可以直接通过字典来创建Series，则Series中的索引就是原字典的键(有序列表)，如果键对应的值找不到，将会是使用NA表示缺失数据,pandas的isnull和notnull函数可用于检测缺失数据：123456789101112131415161718192021In [14]: dic = &#123;&apos;a&apos;:1,&apos;b&apos;:2,&apos;c&apos;:3&#125;In [15]: dics = Series(dic)In [16]: dicsOut[16]:a 1b 2c 3dtype: int64In [17]: states = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]In [18]: dicstates = Series(dic,index=states)In [19]: dicstatesOut[19]:a 1.0b 2.0c 3.0d NaN Series在算数运算中会自动对齐不同索引的数据：12345678910111213141516171819202122In [20]: dicsOut[20]:a 1b 2c 3dtype: int64In [21]: dicstatesOut[21]:a 1.0b 2.0c 3.0d NaNdtype: float64In [22]: dics+dicstatesOut[22]:a 2.0b 4.0c 6.0d NaNdtype: float64 Series本身及其索引有一个name属性，同时Series的索引可以通过赋值的方式就地修改:1234567891011121314151617181920In [23]: dics.name=&apos;dics&apos;In [24]: dics.index.name=&apos;letter&apos;In [25]: dicsOut[25]:lettera 1b 2c 3Name: dics, dtype: int64In [26]: dics.index=[&apos;z&apos;,&apos;x&apos;,&apos;y&apos;]In [27]: dicsOut[27]:z 1x 2y 3Name: dics, dtype: int64 DataFrame构造DataFrame 可以输入给DataFrame构造器的数据| 类型 | 说明 ||:—————————-:|:———————————————————————————-:|| 二维ndarray | 数据矩阵，还可以传入行标和列标 || 由数组、列标或元组组成的字典 | 每个序列会变成DataFrame的一列，所有序列的长度必须相同 || NumPy的结构化/记录数组 | 类似于“由数组组成的字典” || 由Series组成的字典 | 每个Series会成为一列。如果没有显示指定索引，则个Series的索引会被合并成结果的行索引 || 由字典组成的字典 | 各内层字典会成为一列。键会被合并成结果的行索引，跟“由Series组成的字典”情况一样 || 字典或Series的列表 | 各项将会成为DataFrame的一行。字典键或Series索引的并集将会成为DataFrame的列标 || 另一个DataFrame | 该DataFrame的索引将会被沿用，除非显式指定了其他索引 || NumPy的MaskedArray | 类似于“二维ndarray”的情况，只是掩码值在结果DataFrame会编程NA/缺失值 | DataFrame 是一个表格型的数据结构。它含有一组有序的列，每列可以是不同的值类型(数值、字符串、布尔值等)。DataFrame既有行索引也有列索引，它可以被看做由Series组成的字典(共同用一个索引)，DataFrame面向行和面向列的操作基本上是平衡的。构建DataFrame可以通过直接传入一个由等长列表或NumPy数组组成的字典，和Series一样DataFrame也会自动加上索引且全部列会被有序排列，如果指定了列索引，则DataFrame的列会按照指定顺序进行排列。如果传入的列在数据中找不到，会产生NA值：123456789101112131415161718192021222324In [30]: data =&#123;&apos;state&apos;:[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;], ...: &apos;year&apos;:[2000,2001,2002,2003], ...: &apos;pop&apos;:[1,2,3,4]&#125;In [31]: frame = DataFrame(data)In [32]: frameOut[32]: pop state year0 1 a 20001 2 b 20012 3 c 20023 4 d 2003In [34]: DataFrame(data,columns=[&apos;year&apos;,&apos;pop&apos;,&apos;state&apos;,&apos;debt&apos;],index=[&apos;i1&apos;,&apos;i2&apos;,&apos;i3&apos;,&apos;i4&apos;])Out[34]: year pop state debti1 2000 1 a NaNi2 2001 2 b NaNi3 2002 3 c NaNi4 2003 4 d NaNIn [35]: frame.columnsOut[35]: Index([&apos;pop&apos;, &apos;state&apos;, &apos;year&apos;], dtype=&apos;object&apos;) 可以通过字典标记的方式或属性的方式将DataFrame的列获取为一个Series，返回的Series拥有原DataFrame相同的索引，且其name属性已经被相应地设置好了。行也可以通过位置或名称的方式进行获取，比如用索引字段ix:12345678910111213141516171819202122In [40]: frame.stateOut[40]:0 a1 b2 c3 dName: state, dtype: objectIn [41]: frame[&apos;year&apos;]Out[41]:0 20001 20012 20023 2003Name: year, dtype: int64In [42]: frame.ix[1]Out[42]:pop 2state byear 2001Name: 1, dtype: object 列可以通过赋值的方式进行修改，将列表或数组给某个列时，其长度必须跟DataFrame的长度相匹配。如果赋值的事一个Series就会精确匹配DataFrame的索引，所有的空位都将被填上缺失值，为不存在的列赋值会创建出一个新列，关键字del可以删除列:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061In [49]: frame2=DataFrame(data,columns=[&apos;year&apos;,&apos;pop&apos;,&apos;state&apos;,&apos;debt&apos;],index=[&apos;i1&apos;,&apos;i2&apos;,&apos;i3&apos;,&apos;i4&apos;])In [50]: frame2Out[50]: year pop state debti1 2000 1 a NaNi2 2001 2 b NaNi3 2002 3 c NaNi4 2003 4 d NaNIn [51]: frame2[&apos;debt&apos;]=np.arange(4.)In [52]: frame2Out[52]: year pop state debti1 2000 1 a 0.0i2 2001 2 b 1.0i3 2002 3 c 2.0i4 2003 4 d 3.0In [53]: frame2=DataFrame(data,columns=[&apos;year&apos;,&apos;pop&apos;,&apos;state&apos;,&apos;debt&apos;],index=[&apos;i1&apos;,&apos;i2&apos;,&apos;i3&apos;,&apos;i4&apos;])In [54]: frame2Out[54]: year pop state debti1 2000 1 a NaNi2 2001 2 b NaNi3 2002 3 c NaNi4 2003 4 d NaNIn [55]: val = Series([-1,-2,-3],index=[&apos;i1&apos;,&apos;i3&apos;,&apos;i4&apos;])In [56]: frame2[&apos;debt&apos;]=valIn [57]: frame2Out[57]: year pop state debti1 2000 1 a -1.0i2 2001 2 b NaNi3 2002 3 c -2.0i4 2003 4 d -3.0In [58]: frame2[&apos;big&apos;]= frame2[&apos;pop&apos;]&gt;=3In [59]: frame2Out[59]: year pop state debt bigi1 2000 1 a -1.0 Falsei2 2001 2 b NaN Falsei3 2002 3 c -2.0 Truei4 2003 4 d -3.0 TrueIn [60]: del frame2[&apos;big&apos;]In [61]: frame2Out[61]: year pop state debti1 2000 1 a -1.0i2 2001 2 b NaNi3 2002 3 c -2.0i4 2003 4 d -3.0 嵌套字典被传给DataFrame后会被解释为：外层字典的键作为列，内层字典键作为行索引，可以通过T进行转置。内层字典的键会被合并，排序以形成最终的索引。如果现实指定了索引，就不会如此。同理，Series组成的字典也是一样的用法:123456789101112131415161718192021222324252627282930313233In [63]: pop = &#123;&apos;out1&apos;:&#123;2002:1.1,2001:1.2&#125;, ...: &apos;out2&apos;:&#123;2001:1.3,2004:1.4&#125;&#125;In [64]: frame3 = DataFrame(pop)In [65]: frame3Out[65]: out1 out22001 1.2 1.32002 1.1 NaN2004 NaN 1.4In [66]: frame3.TOut[66]: 2001 2002 2004out1 1.2 1.1 NaNout2 1.3 NaN 1.4In [67]: DataFrame(pop,index=[2002,2001,2004])Out[67]: out1 out22002 1.1 NaN2001 1.2 1.32004 NaN 1.4In [68]: sData = &#123;&apos;out1&apos;:frame3[&apos;out1&apos;][:-1], ...: &apos;out2&apos;:frame3[&apos;out2&apos;][:-1]&#125;In [69]: DataFrame(sData)Out[69]: out1 out22001 1.2 1.32002 1.1 NaN 设置了DataFrame的index和columns的name属性，这些信息将会被显示出来，values属性会以二维ndarray的形式返回DataFrame中的数据，如果DataFrame各列的数据类型不同，则值数组的数据类型就会选用能兼容所有列的数据类型：123456789101112131415161718192021222324In [70]: frame3.index.name=&apos;year&apos;In [71]: frame3.columns.name=&apos;state&apos;In [72]: frame3Out[72]:state out1 out2year2001 1.2 1.32002 1.1 NaN2004 NaN 1.4In [73]: frame3.valuesOut[73]:array([[ 1.2, 1.3], [ 1.1, nan], [ nan, 1.4]])In [74]: frame2.valuesOut[74]:array([[2000, 1, &apos;a&apos;, -1.0], [2001, 2, &apos;b&apos;, nan], [2002, 3, &apos;c&apos;, -2.0], [2003, 4, &apos;d&apos;, -3.0]], dtype=object) 索引对象pandas的索引对象负责管理轴标签和其他元数据。 pandas中主要的Index对象| 类 | 说明 ||:————-:|:——————————————————————:|| Index | 最泛化的Index对象，将轴标签表示为一个由Python对象组成的NumPy数组 || Int64Index | 针对整数的特殊Index || MultiIndex | “层次化”索引对象，表示单个轴上的多层索引。可以看做由元组组成的数组 || DatetimeIndex | 存储纳秒级时间戳(用NumPy的datetime64类型表示) || PeriodIndex | 针对Period数据(时间间隔)的特殊Index | Index的方法和属性| 方法 | 说明 ||:————:|:————————————————–:|| append | 连接另一个Index对象，产生一个新的Index || diff | 计算差集，并得到一个Index || intersection | 计算交集 || union | 计算并集 || isin | 计算一个指示各值是否都包含在参数集合中的布尔型数组 || delete | 删除索引i处的元素，并得到新的Index || drop | 删除传入的值，并得到新的Index || insert | 将元素插入到索引i处，并得到新的Index || is_monotonic | 当各元素均大于等于前一个元素时，返回True || is_unique | 当Index没有重复值时，返回True || unique | 计算Index中唯一值的数组 | 构建Series或DataFrame时，所得到的任何数组或其他序列的标签都会被转换成一个Index，Index对象是 不可修改的，这使得Index对象在多个数据结构之间安全共享。除了长得像数组，Index的功能也类似与一个固定大小的集合，每个索引都有一些方法和属性，它们用于设置逻辑并回答有关索引所包含数据的常见问题:123456789101112131415161718192021222324252627282930In [76]: obj = Series(range(3),index=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;])In [77]: index =obj.indexIn [78]: indexOut[78]: Index([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], dtype=&apos;object&apos;)In [79]: index[:-1]Out[79]: Index([&apos;a&apos;, &apos;b&apos;], dtype=&apos;object&apos;)In [80]: inde=pd.Index(np.arange(3))In [81]: obj2=Series([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;],index=inde)In [82]: obj2.index is indeOut[82]: TrueIn [83]: frame3Out[83]:state out1 out2year2001 1.2 1.32002 1.1 NaN2004 NaN 1.4In [84]: &apos;out1&apos; in frame3.columnsOut[84]: TrueIn [85]: 2005 in frame3.indexOut[85]: False 1.使用 from pandas import Series, DataFrame和 import pandas as pd引入相关的包 ↩]]></content>
      <categories>
        <category>true</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[numpy基础(一)]]></title>
    <url>%2F2018%2F03%2F16%2Fnumpy%E5%9F%BA%E7%A1%80-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[NumPy1的部分功能如下： ndarray，一个具有矢量运算和复杂广播能力的快熟且节省空间的多维数组 用于对数组数据进行快速运算的标准数学函数 线性代数、随机数生成及傅里叶变换功能 用于集成C、C++、Fortran等语言编写的代码的工具 对于大部分数据分析应用，关注的功能集中在： 用于数据整理和清理、子集构造和过滤、转换等快速的矢量化数组运算 常用的数组算法，如排序、唯一化、集合运算等 高效的描述统计和数据聚合/摘要运算 用于异构数据集的合并/连接运算的数据对齐和关系型数据运算 将条件逻辑表述为数组表达式(而不是带有if-ekif-else分支的循环) 数据的分组运算(聚合、转换、函数应用等) 多维数组对象(ndarray)N维数组对象(即ndarray)是一个快速而灵活的大数据集容器。可以利用这种数组执行一些数学运算，语法和标量元素之间的运算一样：12345678910111213141516In [4]: data = np.array([[1,2,3],[3,4,5]])In [5]: dataOut[5]:array([[1, 2, 3], [3, 4, 5]])In [6]: data*10Out[6]:array([[10, 20, 30], [30, 40, 50]])In [7]: data+dataOut[7]:array([[ 2, 4, 6], [ 6, 8, 10]]) 创建ndarrayarray函数是创建数组最简单的方法，它接受一切序列型的对象(包括其他数组)，然后产生一个新的含有传入数据的NumPy数组。 数组创建函数 函数 说明 array 将输入数据(列表、元组或其他序列类型)转换为ndarray。要么推断出dtype，要么显示指定dtype。默认直接复制输入数据 asarray 将输入转换为ndarray，如果输入本身就是一个ndarray就不进行复制 arange 类似于内置的range，但返回的是一个ndarray而不是列表 ones、ones_like 根据指定的形状和dtype创建一个全1数组。ones_like以另一个数组为参数，并根据其形状和dtype创建一个全1数组 zeros、zeros_like 类似于ones、ones_like，产生全0数组 empty、empty_like 创建新数组，只分配内存空间但不填充任何值 eye、identity 创建一个正方的NXN单位矩阵(对角线为1，其余为0) 列表转换 1234In [8]: arr1 = np.array([1,2,3])In [9]: arr1Out[9]: array([1, 2, 3]) 嵌套序列将会被转换为一个多维数组: 123456In [10]: arr2 = np.array([[1,2,3],[1,2,3]])In [11]: arr2Out[11]:array([[1, 2, 3], [1, 2, 3]]) 除非显式说明，np.array会尝试为新建的数组推断一个合适的数据类型。数据类型保存在一个特殊的dtype对象中:12In [12]: arr1.dtypeOut[12]: dtype(&apos;int32&apos;) 除了np.array之外，zeros和ones可以创建指定长度或形状的全0或全1数组。empty可以创建一个没有任何具体值的数组。使用这些方法创建数组，只需传入一个表示形状的元组:12345678910111213141516171819In [15]: np.zeros(10)Out[15]: array([ 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])In [16]: np.zeros((3,2))Out[16]:array([[ 0., 0.], [ 0., 0.], [ 0., 0.]])In [17]: np.empty((3,2,3))Out[17]:array([[[ 6.23042070e-307, 4.67296746e-307, 1.69121096e-306], [ 1.33511290e-306, 1.15711989e-306, 1.42418987e-306]], [[ 1.37961641e-306, 1.60220528e-306, 1.24611266e-306], [ 9.34598925e-307, 1.24612081e-306, 1.11260755e-306]], [[ 1.60220393e-306, 1.51320640e-306, 9.34609790e-307], [ 1.86921279e-306, 1.24610723e-306, 0.00000000e+000]]]) 使用empty方法创建的数组返回的是一些未初始化的垃圾值，而不是0arange是Python内置函数range的数组版:12In [18]: np.arange(5)Out[18]: array([0, 1, 2, 3, 4]) ndarray的数据类型 NumPy的数据类型 类型 类型代码 说明 int8、uint8 i1、u1 有符号和无符号的8位(1个字节)整型 int16、uint16 i2、u2 有符号和无符号的18位(2个字节)整型 int32、uint32 i4、u4 有符号和无符号的32位(4个字节)整型 int64、uint64 i8、u8 有符号和无符号的64位(8个字节)整型 float16 f2 半精度浮点数 float32 f4或f 标准的单精度浮点数。与C的float兼容 float64 f8或d 标准的双精度浮点数。与C的double和Python的float对象兼容 float128 f16或g 扩展精度浮点数 complex64、complex128、complex256 c32 复数 bool ? 存储True和False的布尔类型 object O Python对象类型 string_ S 固定长度的字符串类型(每个字符1个字节)。例如要创建一个长度为10的字符串，应使用S10 unicode_ U 固定长度的unicode类型(字节数由平台决定)。跟字符串的定义方式一样(如U10) 可以再创建array对象时使用dtype参数设定数据类型，也可以通过astype方法显示转换其dtype,如果将浮点数转换成整数，则小数部分将会被截断；如果字符串数组全是数字，也可以用astype将其转换为数值形式：123456789101112In [19]: arr = np.array([1.2,-3.4,5.6], dtype=&apos;f8&apos;)In [20]: arr.dtypeOut[20]: dtype(&apos;float64&apos;)In [21]: arr.astype(np.int32)Out[21]: array([ 1, -3, 5])In [22]: numeric_string = np.array([&apos;1.5&apos;,&apos;2.5&apos;,&apos;1.1&apos;],dtype=np.string_)In [23]: numeric_string.astype(np.float64)Out[23]: array([ 1.5, 2.5, 1.1]) 数组和标量之间的运算矢量化 是指数组不用编写任何循环即可对数据执行批量运算。大小相等的数组之间的任何算术运算都会将运算应用到元素级：1234567891011In [24]: arr = np.array([[1,1,1],[2,2,2]])In [25]: arr*arrOut[25]:array([[1, 1, 1], [4, 4, 4]])In [26]: arr+arrOut[26]:array([[2, 2, 2], [4, 4, 4]]) 数组和标量的运算会将标量值传播到各个元素:123456789In [27]: 1/arrOut[27]:array([[ 1. , 1. , 1. ], [ 0.5, 0.5, 0.5]])In [28]: arr ** 0.5Out[28]:array([[ 1. , 1. , 1. ], [ 1.41421356, 1.41421356, 1.41421356]]) 基本的索引和切片将一个标量赋值给一个切片时。改值会自动传播到整个选区。跟列表最重要的区别在于数组切片是原始数组的视图。这说明数据不会被复制，视图上的任何修改都会直接反映到原数组上:2 1234567891011121314151617In [35]: arr = np.arange(10)In [36]: arrOut[36]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])In [37]: arr_slice = arr[2:5]In [38]: arr_sliceOut[38]: array([2, 3, 4])In [39]: arr_slice[1:2] = 1000In [40]: arrOut[40]: array([ 0, 1, 2, 1000, 4, 5, 6, 7, 8, 9])In [41]: arr_sliceOut[41]: array([ 2, 1000, 4]) 对于高维数组，各索引的位置上的元素不在是标量，而是降维数组，索引对各个元素进行递归访问。对二维数组而言，一级索引对应的事一维数组，二级索引对应的是一维数组下的元素索引(这里一维数组的元素是标量),索引有两种方式:123456789101112131415In [42]: arr = np.array([[1,2,3],[4,5,6]])In [43]: arrOut[43]:array([[1, 2, 3], [4, 5, 6]])In [44]: arr[0]Out[44]: array([1, 2, 3])In [45]: arr[0][1]Out[45]: 2In [46]: arr[0,2]Out[46]: 3 对于高维数组而言，不添加索引返回整个数组，添加一级索引，返回一个降维数组(这里是2x3的数组)，添加二级索引则在一级索引的基础上添加索引返回(这里是一维数组):1234567891011121314151617In [47]: arr = np.array([[[1,2,3],[4,5,6]],[[7,8,9],[10,11,12]]])In [48]: arrOut[48]:array([[[ 1, 2, 3], [ 4, 5, 6]], [[ 7, 8, 9], [10, 11, 12]]])In [49]: arr[0]Out[49]:array([[1, 2, 3], [4, 5, 6]])In [50]: arr[0,1]Out[50]: array([4, 5, 6]) 标量和数组都可以赋值给原数组:123456789101112131415161718192021222324252627282930313233343536In [67]: arr = np.array([[[1,2,3],[4,5,6]],[[7,8,9],[10,11,12]]])In [68]: arrOut[68]:array([[[ 1, 2, 3], [ 4, 5, 6]], [[ 7, 8, 9], [10, 11, 12]]])In [69]: old_arr = arr[0].copy()In [70]: old_arrOut[70]:array([[1, 2, 3], [4, 5, 6]])In [71]: arr[0]= 1In [72]: arrOut[72]:array([[[ 1, 1, 1], [ 1, 1, 1]], [[ 7, 8, 9], [10, 11, 12]]])In [73]: arr[0] = old_arrIn [74]: arrOut[74]:array([[[ 1, 2, 3], [ 4, 5, 6]], [[ 7, 8, 9], [10, 11, 12]]]) 切片索引ndarray的切片语法跟Python列表的一维对象差不多，但是高纬度对象的花样很多，可以在一个或多个轴上进行切片，也可以跟整数索引混合使用,传入多个切片和索引相同都是递归切片:312345678910111213141516In [75]: arr2d = np.array([[1,2,3],[3,4,5]])In [76]: arr2dOut[76]:array([[1, 2, 3], [3, 4, 5]])In [77]: arr2d[:2]Out[77]:array([[1, 2, 3], [3, 4, 5]])In [78]: arr2d[:2,:1]Out[78]:array([[1], [3]]) 同时传入索引和切片可以得到低纬度的切片:12In [80]: arr2d[1,:1]Out[80]: array([3]) 只有:表示选取整个轴，可以通过这个对高纬度的进行切片：1234In [81]: arr2d[:,:1]Out[81]:array([[1], [3]]) 同时对切片表达式的赋值也会扩展到整个选区：123456In [82]: arr2d[:,:1] = 0In [83]: arr2dOut[83]:array([[0, 2, 3], [0, 4, 5]]) 布尔型索引可以对数组使用比较运算，其返回一个布尔型数组；可以使用布尔型数组进行数组索引，会返回True对应的数组，布尔型数组的长度必须跟被索引的轴长度一致:12345678910111213141516171819202122232425In [84]: names = np.array([&apos;bob&apos;,&apos;john&apos;,&apos;tom&apos;])In [85]: data = randn(3,6)In [86]: namesOut[86]:array([&apos;bob&apos;, &apos;john&apos;, &apos;tom&apos;], dtype=&apos;&lt;U4&apos;)In [87]: dataOut[87]:array([[-1.38783828, 1.53823048, -0.83396793, 2.53149852, -0.55033656, 0.13621489], [-1.92912846, 1.45011928, 0.76228734, 1.37168505, 0.71817348, -0.48010419], [-0.27052654, 0.72243318, -0.53976533, -0.55488584, -0.18700473, -0.06341261]])In [88]: names == &apos;bob&apos;Out[88]: array([ True, False, False], dtype=bool)In [90]: data[names == &apos;bob&apos;]Out[90]:array([[-1.38783828, 1.53823048, -0.83396793, 2.53149852, -0.55033656, 0.13621489]]) 布尔型数组还可以和切片、整数(或整数序列)混合使用:12345In [91]: data[names == &apos;bob&apos;,2:]Out[91]: array([[-0.83396793, 2.53149852, -0.55033656, 0.13621489]])In [92]: data[names == &apos;bob&apos;,2]Out[92]: array([-0.83396793]) 要选取除某个元素以外的值，可以使用不等号(!=)，也可以通过~对条件进行否定；同时也可以使用&amp;(和)、|(或)之类的布尔运算符：1234567891011121314151617181920212223In [93]: data[names != &apos;bob&apos;]Out[93]:array([[-1.92912846, 1.45011928, 0.76228734, 1.37168505, 0.71817348, -0.48010419], [-0.27052654, 0.72243318, -0.53976533, -0.55488584, -0.18700473, -0.06341261]])In [95]: data[~(names == &apos;bob&apos;)]Out[95]:array([[-1.92912846, 1.45011928, 0.76228734, 1.37168505, 0.71817348, -0.48010419], [-0.27052654, 0.72243318, -0.53976533, -0.55488584, -0.18700473, -0.06341261]])In [97]: data[(names == &apos;bob&apos;)| (names==&apos;tom&apos;)]Out[97]:array([[-1.38783828, 1.53823048, -0.83396793, 2.53149852, -0.55033656, 0.13621489], [-0.27052654, 0.72243318, -0.53976533, -0.55488584, -0.18700473, -0.06341261]])In [98]: data[(names == &apos;bob&apos;)&amp; (names==&apos;tom&apos;)]Out[98]: array([], shape=(0, 6), dtype=float64) 通过布尔索引选取数组中的数据，总是创建数据的副本，即使返回一模一样的数组。 花式索引花式索引(Fancy indexing)指的是利用整数数组进行索引。为了以特定顺序选取行子集，只需传入一个指定顺序的整数列表或ndarray即可：12345678910111213141516171819202122In [102]: arr = np.empty((7,4))In [103]: for i in range(7): ...: arr[i]=i ...:In [104]: arrOut[104]:array([[ 0., 0., 0., 0.], [ 1., 1., 1., 1.], [ 2., 2., 2., 2.], [ 3., 3., 3., 3.], [ 4., 4., 4., 4.], [ 5., 5., 5., 5.], [ 6., 6., 6., 6.]])In [105]: arr[[4,3,1,2]]Out[105]:array([[ 4., 4., 4., 4.], [ 3., 3., 3., 3.], [ 1., 1., 1., 1.], [ 2., 2., 2., 2.]]) 使用负数索引将会从末尾开始选取行:123456In [106]: arr[[-4,-3,-1,-2]]Out[106]:array([[ 3., 3., 3., 3.], [ 4., 4., 4., 4.], [ 6., 6., 6., 6.], [ 5., 5., 5., 5.]]) 一次性传入多个索引数组返回的事一个以为数组，其中的元素对应各个索引元组：1234567891011121314151617In [107]: arr = np.arange(32).reshape((8,4))In [108]: arrOut[108]:array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23], [24, 25, 26, 27], [28, 29, 30, 31]])In [109]: arr[[1,2,3,4],[1,2,3,4]]In [110]: arr[[1,2,3,4],[0,1,2,3]]Out[110]: array([ 4, 9, 14, 19]) 其中选出的元素是(1,0),(2,1),(3,2),(4,3)。而选取矩阵的行列子集的方法如下：123456In [111]: arr[[1,2,3,4]][:,[0,1,2,3]]Out[111]:array([[ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15], [16, 17, 18, 19]]) 选取矩阵的另一个方法是使用np.ix_函数，它可以将两个一维整数数组转换为一个用于选取方形区域的索引器：123456In [112]: arr[np.ix_([1,2,3,4],[0,1,2,3])]Out[112]:array([[ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15], [16, 17, 18, 19]]) 花式索引总是将数据复制到新数组中。 数组转置和轴对换转置(transpose)是重塑的一种特殊形式，它返回的是源数据的视图。数组不仅有transpose方法，还有一个特殊的T属性，在计算内积的时候经常需要用到：12345678910111213In [114]: arr.TOut[114]:array([[ 0, 4, 8, 12, 16, 20, 24, 28], [ 1, 5, 9, 13, 17, 21, 25, 29], [ 2, 6, 10, 14, 18, 22, 26, 30], [ 3, 7, 11, 15, 19, 23, 27, 31]])In [115]: np.dot(arr.T, arr)Out[115]:array([[2240, 2352, 2464, 2576], [2352, 2472, 2592, 2712], [2464, 2592, 2720, 2848], [2576, 2712, 2848, 2984]]) transpose需要得到一个由轴编号组成的元组才能对这些轴进行转置:12345678910111213141516171819202122232425262728In [126]: arrOut[126]:array([[[ 0, 1, 2], [ 3, 4, 5]], [[ 6, 7, 8], [ 9, 10, 11]]])In [127]: arr.shapeOut[127]: (2, 2, 3)In [128]: arr.transpose((1,2,0))Out[128]:array([[[ 0, 6], [ 1, 7], [ 2, 8]], [[ 3, 9], [ 4, 10], [ 5, 11]]])In [129]: arr.transpose((1,0,2))Out[129]:array([[[ 0, 1, 2], [ 6, 7, 8]], [[ 3, 4, 5], [ 9, 10, 11]]]) 上面arr.shape返回的结果是(2,2,3) 表明这是一个三维数组，形状为2x2x3,执行arr.transpose((1,2,0))对三个轴进行了重新排列形状变成了2x3x2。在原数组中元素对应的下标为：12345[[[(0,0,0), (0,0,1), (0,0,2)], [(0,1,0), (0,1,1), (0,1,2)]], [[(1,0,0), (1,0,1), (1,0,2)], [(1,1,0), (1,1,1),(1,1,2)]]] 进行轴变换之后的原下标变为:123456789101112131415(0,0,0)-&gt;(0,0,0)(0,0,1)-&gt;(0,1,0)(0,0,2)-&gt;(0,2,0)(0,1,0)-&gt;(1,0,0)(0,1,1)-&gt;(1,1,0)(0,1,2)-&gt;(1,2,0)(1,0,0)-&gt;(0,0,1)(1,0,1)-&gt;(0,1,1)(1,0,2)-&gt;(0,2,1)(1,1,0)-&gt;(1,0,1)(1,1,1)-&gt;(1,1,1)(1,1,2)-&gt;(1,2,1) 将将上面重新编号后的索引对应轴排列并将原数组对应的数字填入其中：123456[[[(0,0,0), (0,0,1)], -&gt; (0,0,0) ,(1,0,0) -&gt; 0,6 [(0,1,0), (0,1,1)], -&gt; (0,0,1) ,(1,0,1) -&gt; 1,7 [(0,2,0), (0,2,1)]], -&gt; (0,0,2) ,(1,0,2) -&gt; 2,8 [[(1,0,0), (1,0,1)], -&gt; (0,1,0) ,(1,1,0) -&gt; 3,9 [(1,1,0), (1,1,1)], -&gt; (0,1,1) ,(1,1,1) -&gt; 4,10 [(1,2,0), (1,2,1)]] -&gt; (0,1,2) ,(1,1,2) -&gt; 5, 11 所以最后的数组变为：1234567array([[[ 0, 6], [ 1, 7], [ 2, 8]], [[ 3, 9], [ 4, 10], [ 5, 11]]]) swapaxes方法需要接受一对轴编号,其返回的事源数据的视图:12345678910111213array([[[ 0, 1, 2], [ 3, 4, 5]], [[ 6, 7, 8], [ 9, 10, 11]]])In [138]: arr.swapaxes(0,1)Out[138]:array([[[ 0, 1, 2], [ 6, 7, 8]], [[ 3, 4, 5], [ 9, 10, 11]]]) 1.NumPy将通过语句import numpy as np导入 ↩2.使用副本需要显式地进行复制操作，arr[1:4].copy() ↩3.轴根据shape返回元组的大小确认，如果arr.shape返回(2,2,3)则表示这是一个三维数组，0就是对应第一个2的数轴，指的第一维，1对应第二个2的数轴，指的第二维，2对应3的数轴，指的第三维 ↩]]></content>
      <categories>
        <category>true</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>NumPy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPython入门]]></title>
    <url>%2F2018%2F03%2F15%2FIPython%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[IPython基础IPython的环境需要自行安装。如果已经安装了Python，可以通过执行pip install ipython安装。然后只需要在命令行输入ipython就能启动：12345Python 3.6.4 (v3.6.4:d48eceb, Dec 19 2017, 06:54:40) [MSC v.1900 64 bit (AMD64)]Type &apos;copyright&apos;, &apos;credits&apos; or &apos;license&apos; for more informationIPython 6.2.1 -- An enhanced Interactive Python. Type &apos;?&apos; for help.In [1]: 可以在IPython中执行任何Python语句，和使用Python解释器一样：1234567891011121314151617181920In [1]: import numpy as npIn [2]: from numpy.random import randnIn [3]: data = &#123;i:randn() for i in range(10)&#125;In [4]: dataOut[4]:&#123;0: -0.24193324837938815, 1: 0.22563840475528563, 2: 0.14465306885873513, 3: 0.5076262433687561, 4: 0.9067731627966235, 5: 0.23827518072962814, 6: 0.3233586627456586, 7: 0.0327013232275763, 8: -0.357340429464286, 9: -1.4105691657079547&#125;In [5]: 许多Python对象都被格式化为可读性更好的形式 Tab键自动完成在shell中输入表达式时，只要按下Tab键，当前命名空间中任何与已输入的字符串相匹配的变量(对象、函数等)就会被找出来：12345678In [5]: an_example1 = 15In [6]: an_example2 = 20In [7]: an&lt;TAB&gt; an_example1 AnalogCommonProxyStub.dll an_example2 and any() 也可以在任何对象后面输入一个句点以便自动完成方法和属性的输入：123456In [7]: a = [1, 2, 3]In [8]: a.&lt;TAB&gt; append() count() insert() reverse() clear() extend() pop() sort() copy() index() remove() 应用在模块上:123456In [8]: import datetimeIn [9]: datetime. date() MAXYEAR timedelta datetime MINYEAR timezone datetime_CAPI time() tzinfo() IPython默认会隐藏那些以下划线开头的方法和属性。如果需要应Tab键自动完成，可以先输入一个下划线。也可以直接修改IPython配置文件中的相关设置。Tab键还可以找出电脑文件系统中与之匹配的东西：1234In [6]: ca&lt;TAB&gt; callable() %%capture catchLink/ 其中 catchLibk/ 为当前目录下的一个子目录。在使用补全目录的时候需要使用正斜杠(/)，文件夹或文件名中间不能有空格。 内省在变量前面或者后面加上一个问号(?)就可以将有关该对象的一些通用信息显示:123456789In [2]: b = []In [3]: b?Type: listString form: []Length: 0Docstring:list() -&gt; new empty listlist(iterable) -&gt; new list initialized from iterable&apos;s items 如果该对象是一个函数或实例方法，则其docstring也会被显示出来：1234567891011121314151617181920In [4]: def add_number(a,b): ...: &quot;&quot;&quot; ...: Add two numbers together ...: Returns ...: ----------------------- ...: the sum: type of arguments ...: &quot;&quot;&quot; ...: return a+b ...: ...:In [5]: add_number?Signature: add_number(a, b)Docstring:Add two numbers togetherReturns-----------------------the sum: type of argumentsFile: d:\python\&lt;ipython-input-4-7144b04645ed&gt;Type: function 使用??还将显示源代码:12345678910111213In [6]: add_number??Signature: add_number(a, b)Source:def add_number(a,b): &quot;&quot;&quot; Add two numbers together Returns ----------------------- the sum: type of arguments &quot;&quot;&quot; return a+bFile: d:\python\&lt;ipython-input-4-7144b04645ed&gt;Type: function ?还可以搜索IPython的命名空间，一些字符再配以通配符(*)即可显示出所有与该通配符表达式相匹配的名称:12345678In [7]: import numpy as npIn [8]: np.*load*?np.__loader__np.loadnp.loadsnp.loadtxtnp.pkgload %run命令在IPython会话环境中，所有文件都可以通过%run命令当做Python程序来运行。现在在目录下有一个叫做ipython_script_test.py的脚本：1234567891011#!/usr/bin/python3# -*- coding:utf-8 -*-def f(x, y, z): return (x+y) /za = 1b = 2c = 3result = f(a, b, c) 然后运行，并且运行成功后该文件中所定义的全部变量(import、函数和全局变量)都可以在IPython shell中访问:1234567In [9]: %run ipython_script_test.pyIn [10]: resultOut[10]: 1.0In [11]: aOut[11]: 1 中断正在执行的代码任何代码在执行时只要按下“Ctrl-C/control-C”,就会引发一个KeyboardInterrupt，除非Python代码已经调用某个已编译的扩展模块需要等待Python解释器重新获取控制权外，绝大部分Python程序将立即停止执行。 执行剪切板中的代码使用%paste和%cpaste两个魔术函数粘贴代码在shell中以整体执行： %paste 123456789In [12]: %pastedef f(x, y, z): return (x+y) /za = 1b = 2c = 3result = f(a, b, c)## -- End pasted text -- %cpaste 相比于%paste，%cpaste多出了一个用于粘贴代码的特殊提示符,若果发现粘贴的代码有错，只需按下“Ctrl-C/control-C”即可终止%cpaste提示符：12345678910In [16]: %cpastePasting code; enter &apos;--&apos; alone on the line to stop or use Ctrl-D.:def f(x, y, z):: return (x+y) /z::a = 1:b = 2:c = 3:result = f(a, b, c):-- 键盘快捷键IPython提供了许多用于提示符导航和查阅历史shell命令的键盘快捷键(C指代Ctrl或control)： 命令 说明 C-P或上箭头 后向搜索命令历史中以当前输入的文本开头的命令 C-N或下箭头 前向搜索命令历史中以当前输入的文本开头的命令 C-R 按行读取的反向历史搜索(部分匹配) C-Shift-V/Command-Shift-V 从剪切板粘贴文本 C-C 终止当前正在执行的代码 C-A 将光标移动到行首 C-E 将光标移动到行尾 C-K 删除从光标开始至行尾的文本 C-U 清楚当前行的所有文本(只是和C-K相反，即删除从光标开始至行首的文本) C-F 将光标向前移动一个字符 C-b 将光标向后移动一个字符 C-L 清屏 异常和跟踪如果%run某段脚本或执行某条语句是发生异常，IPython会默认输出整个调用栈跟踪，其中还会附上调用栈各点附近的几行代码作为上下文参考:12345678910111213141516In [17]: %run ipython_bug.py---------------------------------------------------------------------------ZeroDivisionError Traceback (most recent call last)D:\Python\ipython\ipython_bug.py in &lt;module&gt;() 5 b = 2 6 c = 0----&gt; 7 result = f(a, b, c)D:\Python\ipython\ipython_bug.py in f(x, y, z) 1 def f(x, y, z):----&gt; 2 return (x+y) /z 3 4 a = 1 5 b = 2ZeroDivisionError: division by zero 魔术命令IPython有一些特殊命令，它们有的为常见任务提供便利，有的则使控制IPython系统的行为更轻松。魔术命令以百分号 % 为前缀的命令。例如通过%timeit检测任何Python语句的执行时间:1234In [41]: a = np.random.randn(100,100)In [42]: %timeit np.dot(a,a)237 µs ± 40 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each) 魔术命令可以看做运行于IPython系统中的命令行程序，使用?即可查看其选项:123456789101112131415161718192021222324252627282930313233343536373839In [44]: %reset?Docstring:Resets the namespace by removing all names defined by the user, ifcalled without arguments, or by removing some types of objects, suchas everything currently in IPython&apos;s In[] and Out[] containers (seethe parameters for details).Parameters-----------f : force reset without asking for confirmation.-s : &apos;Soft&apos; reset: Only clears your namespace, leaving history intact. References to objects may be kept. By default (without this option), we do a &apos;hard&apos; reset, giving you a new session and removing all references to objects from the current session.in : reset input historyout : reset output historydhist : reset directory historyarray : reset only variables that are NumPy arraysSee Also--------reset_selective : invoked as ``%reset_selective``Examples--------:: In [6]: a = 1 In [7]: a Out[7]: 1 In [8]: &apos;a&apos; in _ip.user_ns Out[8]: True 魔术命令可以不带百分号使用，只要没有定义与其同名的变量。 常用的魔术命令 命令 说明 %quickref 显示Python的快速参考 %magic 显示所有魔术命令的详细文档 %debug 从最新的异常跟踪的底部进入交互式调试器 %hist 打印命令的输入(可选输出)历史 %pdb 在异常发生后自动进入调试器 %paste 执行剪切板中的Python代码 %cpaste 打开一个特殊提示符以便手工粘贴待执行的Python代码 %reset 删除interactive命名空间的全部变量/名称 %page OBJECT 通过分页器打印输出OBJECT %run script.py 在IPython中执行一个Python脚本文件 %prun statement 通过cProfile执行statement，并打印分析器的输出结果 %time statement 报告statement的执行时间 %timeit statement 多次执行statement以计算系统平均执行时间。对那些执行时间非常小的代码很有用 %who、%who_is、%whos 显示interactive命名空间中定义的变量，信息级别/冗余度可变 %xdel variable 删除variable，并参加过时清除其在IPython中的对象上的一切引用 matplotlib集成与pylab模式启动IPython时加上--pylab标记来集成matplotlibipython --pylab。这样IPython会默认GUI后台集成，就可以创建matplotlib绘图了。并且NumPy和matplotlib的大部分功能会被引入到最顶层的interactive命名空间以产生一个交互式的计算环境。也可以通过%gui对此进行手工设置。123456Python 3.6.4 (v3.6.4:d48eceb, Dec 19 2017, 06:54:40) [MSC v.1900 64 bit (AMD64)]Type &apos;copyright&apos;, &apos;credits&apos; or &apos;license&apos; for more informationIPython 6.2.1 -- An enhanced Interactive Python. Type &apos;?&apos; for help.Using matplotlib backend: TkAggIn [1]: 使用命令历史IPython维护着一个位于硬盘上的小型数据库，其中含有执行过的每条命令的文本： 只需很少的按键次数即可搜索、自动完成并执行之前已经执行过的命令 在会话间持久化命令历史 将输入/输出历史记录到日志文件 搜索并重用命令历史如果需要输入之前执行过的相同的命令，只需要按照上面的快捷键表操作，就可以搜索出命令历史中第一个与输入的字符相匹配的命令。既可以后向搜索也可以前向搜索。 输入和输出变量IPython会将输入(输入的文本)和输出(返回的对象)的引用保存在一些特殊变量中。最近的两个输出结果分别保存在 _(一个下划线)和 __(两个下划线)变量中：1234567891011121314In [6]: 1+1Out[6]: 2In [7]: _Out[7]: 2In [8]: _+1Out[8]: 3In [9]: 3+1Out[9]: 4In [10]: __Out[10]: 3 输入的文本保存在名为_ix的变量中，其中 X 是输入行的行号。每个输入变量都有一个对应的输出变量_x:12345In [11]: _i6Out[11]: &apos;1+1&apos;In [12]: _6Out[12]: 2 由于输入变量是字符串，因此可以用Python的exec()方法重新执行:1234In [18]: exec(_i6)In [19]: _Out[19]: &apos;1+1&apos; 有几个魔术命令可以用于控制输入和输出历史。%hist用于打印全部或部分输入历史，可以选择是否带行号。%reset用于清空interactive命名空间，并可选择是否清空输入和输出缓存。%xdel用于从IPython系统中移除特定对象的一切引用。 记录输入和输出IPython能够记录整个控制台会话，包括输入和输出。执行%logstart即可开始记录日志：12345678In [20]: %logstartActivating auto-logging. Current session state plus future input saved.Filename : ipython_log.pyMode : rotateOutput logging : FalseRaw input log : FalseTimestamping : FalseState : active IPython的日志功能可以在任何时刻开启。还有与%logstart配套的%logoff、%logon、%logstate和%logstop，可以参考其文档。 与操作系统交互可以在IPython中实现标准的Windows或UNIX命令行活动，将命令的执行结果保存在Python对象中 跟系统相关的IPython魔术命令 命令 说明 !cmd 在系统shell中执行cmd output=!cmd args 执行cmd，并将stout存放在output中 %alias alias_name cmd 为系统shell命令定义别名 %bookmark 使用IPython的目录书签系统 %cd directory 将系统工作目录更改为directory %pwd 返回系统的当前工作目录 %pushd directory 将当前目录入栈，并转向目标目录 %popd 弹出栈顶目录，并转向该目录 %dirs 返回一个含有当前目录栈的列表 %dhist 打印目录访问历史 %env 以dict形式返回系统环境变量 shell命令和别名在IPython中，以感叹号(!)开头的命令行表示其后的所有内容需要在系统shell中执行:1234In [23]: !pythonPython 3.6.4 (v3.6.4:d48eceb, Dec 19 2017, 06:54:40) [MSC v.1900 64 bit (AMD64)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; 还可以将shell命令的控制台输出存放到变量中，只需将 ! 开头的表达式赋值给变量:1234In [152]: ip_info = !lsIn [153]: ip_infoOut[153]: [&apos;experiment.py&apos;, &apos;ipython_bug.py&apos;, &apos;ipython_script_test.py&apos;] 软件开发工具IPython集成并加强了Python内置的pdb调试器，同时提供了一些简单易用的代码运行时间及性能分析工具。 交互式调试器IPython的调试器增强了pdb，如Tab键自动完成、语法高亮、为异常跟踪的每条信息添加上下文参考。%debug命令(在发生异常之后马上输入)将会调用那个“事后”调试器，并直接跳转到引发异常的那个栈帧：123456789101112131415161718192021222324In [45]: %run ipython_bug.py---------------------------------------------------------------------------ZeroDivisionError Traceback (most recent call last)D:\Python\ipython\ipython_bug.py in &lt;module&gt;() 5 b = 2 6 c = 0----&gt; 7 result = f(a, b, c)D:\Python\ipython\ipython_bug.py in f(x, y, z) 1 def f(x, y, z):----&gt; 2 return (x+y) /z 3 4 a = 1 5 b = 2ZeroDivisionError: division by zeroIn [46]: %debug&gt; d:\python\ipython\ipython_bug.py(2)f() 1 def f(x, y, z):----&gt; 2 return (x+y) /z 3 4 a = 1 5 b = 2 在这个调试器中，可以执行任意Python代码并查看各个栈帧中的一切对象和数据。默认是从最低级开始(即错误发生的地方)。输入u(或up)和d(或down)即可在栈跟踪的各级别之间切换:123456789101112131415ipdb&gt; u&gt; d:\python\ipython\ipython_bug.py(7)&lt;module&gt;() 3 4 a = 1 5 b = 2 6 c = 0----&gt; 7 result = f(a, b, c)ipdb&gt; d&gt; d:\python\ipython\ipython_bug.py(2)f() 1 def f(x, y, z):----&gt; 2 return (x+y) /z 3 4 a = 1 5 b = 2 执行%pdp命令可以让IPython在出现异常之后自动调用调试器。如果需要设置断点或对函数/脚本进行单步调试以查看各条语句的执行情况时，可以使用带有-d选项的%run命令，这会在执行脚本文件中的代码之前打开调试器，然后输入s(或step)步进才能进入脚本:123456789101112131415161718192021222324252627282930313233In [50]: %run -d ipython_bug.pyBreakpoint 1 at d:\python\ipython\ipython_bug.py:1NOTE: Enter &apos;c&apos; at the ipdb&gt; prompt to continue execution.&gt; d:\python\ipython\ipython_bug.py(1)&lt;module&gt;()1---&gt; 1 def f(x, y, z): 2 return (x+y) /z 3 4 a = 1 5 b = 2ipdb&gt; s&gt; d:\python\ipython\ipython_bug.py(4)&lt;module&gt;() 2 return (x+y) /z 3----&gt; 4 a = 1 5 b = 2 6 c = 0ipdb&gt; s&gt; d:\python\ipython\ipython_bug.py(5)&lt;module&gt;() 3 4 a = 1----&gt; 5 b = 2 6 c = 0 7 result = f(a, b, c)ipdb&gt; s&gt; d:\python\ipython\ipython_bug.py(6)&lt;module&gt;() 3 4 a = 1 5 b = 2----&gt; 6 c = 0 7 result = f(a, b, c) 通过b num在num行出设置断点，输入c(或continue)使脚本一直运行下去直到该断点时为止,然后输入n(或next)直到执行下一行(即step over):1234567891011121314151617181920212223242526272829303132333435363738In [53]: %run -d ipython_bug.pyBreakpoint 1 at d:\python\ipython\ipython_bug.py:1NOTE: Enter &apos;c&apos; at the ipdb&gt; prompt to continue execution.&gt; d:\python\ipython\ipython_bug.py(1)&lt;module&gt;()1---&gt; 1 def f(x, y, z): 2 return (x+y) /z 3 4 a = 1 5 b = 2ipdb&gt; b 7Breakpoint 2 at d:\python\ipython\ipython_bug.py:7ipdb&gt; c&gt; d:\python\ipython\ipython_bug.py(7)&lt;module&gt;() 3 4 a = 1 5 b = 2 6 c = 02---&gt; 7 result = f(a, b, c)ipdb&gt; nZeroDivisionError: division by zero&gt; d:\python\ipython\ipython_bug.py(7)&lt;module&gt;() 3 4 a = 1 5 b = 2 6 c = 02---&gt; 7 result = f(a, b, c)ipdb&gt; n--Return--None&gt; d:\python\ipython\ipython_bug.py(7)&lt;module&gt;() 3 4 a = 1 5 b = 2 6 c = 02---&gt; 7 result = f(a, b, c) IPython调试器命令 命令 功能 h(elp) 显示命令列表 help command 显示command的文档 c(ontinue) 恢复程序的执行 q(uit) 退出调试器，不再执行任何代码 b(readk) number 在当前文件的第number行设置一个断点 b path/to/file.py:number 在指定文件的第number行设置一个断点 s(tep) 单步进入函数调用 n(ext) 执行当前行，并前进到当前级别的下一行 u(p)/d(own) 在函数调用栈中向上或向下移动 a(rgs) 显示当前函数的参数 debug statement 在新的(递归)调试器中调用语句statement l(ist) statement 显示当前行，以及当前栈级别的上下文参考代码 w(here) 打印当前位置的完整栈跟踪(包括上下文参考代码) 测试代码的执行时间:%time和%timeit%time一次执行一条语句，然后报告总体执行时间1234567In [56]: strings = [&apos;foo&apos;,&apos;bar&apos;,&apos;abc&apos;,&apos;foobar&apos;,&apos;python&apos;,&apos;Guide Peple&apos;]*100000In [57]: %time method1 = [x for x in strings if x.startswith(&apos;foo&apos;)]Wall time: 102 msIn [58]: %time method2 = [x for x in strings if x[:3] == &apos;foo&apos;]Wall time: 59.2 ms %timeit对于任意语句，它会自动多次执行以产生一个非常精确的平均执行时间12345In [59]: %timeit method1 = [x for x in strings if x.startswith(&apos;foo&apos;)]100 ms ± 5.73 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)In [60]: %timeit method2 = [x for x in strings if x[:3] == &apos;foo&apos;]57 ms ± 7.12 ms per loop (mean ± std. dev. of 7 runs, 10 loops each) 基本性能分析：%prun和%run -p代码的性能分析跟代码执行时间密切相关，只不过它关注的事耗费时间的位置，主要的Python性能分析工具是cProfile模块。CProfile在执行一个程序或代码块时，会记录各函数所耗费的时间。CProfile一般在命令行上使用，它将执行整个程序然后输出各函数的执行时间。%prun分析的是Python语句而不是整个.py文件：123456789101112131415161718192021222324252627In [141]: %cpastePasting code; enter &apos;--&apos; alone on the line to stop or use Ctrl-D.:def run_experiment(niter=100): k = 100 results = [] for _ in range(niter): mat = np.random.randn(k, k) max_eigenvalue = np.abs(eigvals(mat)).max() results.append(max_eigenvalue) return results:::::::::--In [142]: %prun -l 7 -s cumulative run_experiment() 3804 function calls in 0.901 seconds Ordered by: cumulative time List reduced from 31 to 7 due to restriction &lt;7&gt; ncalls tottime percall cumtime percall filename:lineno(function) 1 0.000 0.000 0.901 0.901 &#123;built-in method builtins.exec&#125; 1 0.000 0.000 0.901 0.901 &lt;string&gt;:1(&lt;module&gt;) 1 0.002 0.002 0.901 0.901 &lt;ipython-input-141-78ef833ef08b&gt;:1(run_experiment) 100 0.814 0.008 0.838 0.008 linalg.py:834(eigvals) 100 0.060 0.001 0.060 0.001 &#123;method &apos;randn&apos; of &apos;mtrand.RandomState&apos; objects&#125; 100 0.012 0.000 0.018 0.000 linalg.py:213(_assertFinite) 300 0.008 0.000 0.008 0.000 &#123;method &apos;reduce&apos; of &apos;numpy.ufunc&apos; objects&#125; 执行%run -p -s cumulative experiment.py也能达到以上的效果，无需退出IPython:123456789101112131415In [75]: %run -p -l 7 -s cumulative experiment.pyLargest one we saw:11.9165340849 3888 function calls (3887 primitive calls) in 0.467 seconds Ordered by: cumulative time List reduced from 77 to 7 due to restriction &lt;7&gt; ncalls tottime percall cumtime percall filename:lineno(function) 2/1 0.000 0.000 0.467 0.467 &#123;built-in method builtins.exec&#125; 1 0.000 0.000 0.467 0.467 &lt;string&gt;:1(&lt;module&gt;) 1 0.000 0.000 0.467 0.467 interactiveshell.py:2445(safe_execfile) 1 0.000 0.000 0.467 0.467 py3compat.py:182(execfile) 1 0.000 0.000 0.467 0.467 experiment.py:1(&lt;module&gt;) 1 0.001 0.001 0.466 0.466 experiment.py:5(run_experiment) 100 0.431 0.004 0.436 0.004 linalg.py:819(eigvals) ipython html notebook需要安装 jupyter 来使用该功能:1pip3 install jupyter 这是一个基于Web的交互式计算文档格式。它有一种基于JSON的文档格式.upynb，可以轻松分享代码、输出结果以及图片等内容。执行如下命令启动：1jupyter notebook 这是运行于命令行上的轻量级服务器进程，Web浏览器会自动打开Notebook的仪表盘。]]></content>
      <categories>
        <category>true</category>
      </categories>
      <tags>
        <tag>IPython</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python文本处理]]></title>
    <url>%2F2018%2F03%2F13%2FPython%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[逗号分割值(CSV)CSV简介逗号分割值(Comma-Spearated Value, CSV) 通常用于在电子表格软件和纯文本之间交互数据。CSV文件内容仅仅是一些用逗号分隔的原始字符串值。CSV格式的文件需要专门用于解析和生成CSV的库，不能使用str.splt(&#39;,&#39;)来解析，因为会处理单个字段中含有逗号的情形。123456789101112131415161718192021222324252627282930#!/usr/bin/python3# -*- coding:utf-8 -*-import csv# 创建需要导入的数据源DATA = ( (1, 'Web Clients and Servers', 'base64,urllib'), (2, 'Web program：CGI &amp; WSGI', 'cgi, time, wsgiref'), (3, 'Web Services', 'urllib,twython'))print('*** WRITTING CSV DATA')# 打开一个csv文件，使用utf-8编码，同时为了防止写入时附加多的空白行设置newline为空with open('bookdata.csv', 'w', encoding='utf-8', newline='') as w: # csv.writer笑一个打开的文件(或类文件)对象，返回一个writer对象 # 可以用来在打开的文件中逐行写入逗号分隔的数据。 writer = csv.writer(w) for record in DATA: writer.writerow(record)# writer对象提供一个writerow()方法print('****REVIEW OF SAVED DATA')with open('bookdata.csv', 'r', encoding='utf-8') as r: # csv.reader()用于返回一个可迭代对象，可以读取该对象并解析为CSV数据的每一行 # csv.reader()使用一个已打开文件的句柄，返回一个reader对象 # 当逐行迭代数据时，CSV数据会自动解析并返回给用户 reader = csv.reader(r) for chap, title, modpkgs in reader: print('Chapter %s: %r (featureing %s)' % (chap, title, modpkgs)) 输出结果 12345*** WRITTING CSV DATA****REVIEW OF SAVED DATAChapter 1: &apos;Web Clients and Servers&apos; (featureing base64,urllib)Chapter 2: &apos;Web program：CGI &amp; WSGI&apos; (featureing cgi, time, wsgiref)Chapter 3: &apos;Web Services&apos; (featureing urllib,twython) csv模块还提供csv.DictReader类和csv.DictWriter类，用于将CSV数据读进字典中(首先查找是否使用给定字段名，如果没有，就是用第一行作为键)，接着将字典字段写入CSV文件中。 JSONJSON是JavaScript的子集，专门用于指定结构化的数据。JSON是以人类更易读的方式传输结构化数据。 JSON和Python类型之间的区别 JSON Python3 object dict array list tuple string str number(int) int number(real) float true True false False null None json提供了dump()/load()和dumps()/loads()。除了基本参数外，这些函数还包含许多仅用于JSON的选项。模块还包括encoder类和decoder类，用户既可以继承也可以直接使用。Python字典可以转化为JSON对象，Python列表和元组也可以转成对应的JSON数组。12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/python3# -*- coding:UTF-8 -*-# 返回一个表示Python对象的字符串# 用来美观地输出Python对象from json import dumpsfrom pprint import pprint# Python字典，使用字典是因为其可以构建具有结构化层次的属性。# 在等价的JSON表示方法中，会移除所有额外的逗号Books = &#123; '0000001': &#123; 'title': 'Core', 'edition': 2, 'year': 2007, &#125;, '0000002': &#123; 'title': 'Python Programming', 'edition': 3, 'authors': ['Jack', 'Bob', 'Jerry'], 'year': 2009, &#125;, '0000003': &#123; 'title': 'Programming', 'year': 2009, &#125;&#125;# 显示转储的Python字典print('***RAW DICT***')print(Books)# 使用更美观的方法输出print('***PRETTY_PRINTED DICT***')pprint(Books)# 使用json.dumps()内置的美观的输出方式，传递缩进级别print('***PRETTY_PRINTED JSON***')print(dumps(Books, indent=4)) 输出结果 12345678910111213141516171819202122232425262728293031***RAW DICT***&#123;&apos;0000001&apos;: &#123;&apos;title&apos;: &apos;Core&apos;, &apos;edition&apos;: 2, &apos;year&apos;: 2007&#125;, &apos;0000002&apos;: &#123;&apos;title&apos;: &apos;Python Programming&apos;, &apos;edition&apos;: 3, &apos;authors&apos;: [&apos;Jack&apos;, &apos;Bob&apos;, &apos;Jerry&apos;], &apos;year&apos;: 2009&#125;, &apos;0000003&apos;: &#123;&apos;title&apos;: &apos;Programming&apos;, &apos;year&apos;: 2009&#125;&#125;***PRETTY_PRINTED DICT***&#123;&apos;0000001&apos;: &#123;&apos;edition&apos;: 2, &apos;title&apos;: &apos;Core&apos;, &apos;year&apos;: 2007&#125;, &apos;0000002&apos;: &#123;&apos;authors&apos;: [&apos;Jack&apos;, &apos;Bob&apos;, &apos;Jerry&apos;], &apos;edition&apos;: 3, &apos;title&apos;: &apos;Python Programming&apos;, &apos;year&apos;: 2009&#125;, &apos;0000003&apos;: &#123;&apos;title&apos;: &apos;Programming&apos;, &apos;year&apos;: 2009&#125;&#125;***PRETTY_PRINTED JSON***&#123; &quot;0000001&quot;: &#123; &quot;title&quot;: &quot;Core&quot;, &quot;edition&quot;: 2, &quot;year&quot;: 2007 &#125;, &quot;0000002&quot;: &#123; &quot;title&quot;: &quot;Python Programming&quot;, &quot;edition&quot;: 3, &quot;authors&quot;: [ &quot;Jack&quot;, &quot;Bob&quot;, &quot;Jerry&quot; ], &quot;year&quot;: 2009 &#125;, &quot;0000003&quot;: &#123; &quot;title&quot;: &quot;Programming&quot;, &quot;year&quot;: 2009 &#125;&#125; XMLXML数据是纯文本数据，但是其可读性不高，所以需要使用解析器进行解析。 将字典转化为XML 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#!/usr/bin/python3# -*- coding:UTF-8 -*-#from xml.etree.ElementTree import Element, SubElement, tostringfrom xml.dom.minidom import parseString# Python字典，使用字典是因为其可以构建具有结构化层次的属性。# 在等价的JSON表示方法中，会移除所有额外的逗号Books = &#123; '0000001': &#123; 'title': 'Core', 'edition': 2, 'year': 2007, &#125;, '0000002': &#123; 'title': 'Python Programming', 'edition': 3, 'authors': 'Jack:Bob:Jerry', 'year': 2009, &#125;, '0000003': &#123; 'title': 'Programming', 'year': 2009, &#125;&#125;# 创建顶层对象# 将所有其他内容添加到该节点下books = Element('books')for isbn, info in Books.items(): # 对于每一本书添加一个book子节点 # 如果原字典没有提供作者和版本，则使用提供的默认值。 book = SubElement(books, 'book') info.setdefault('authors', 'Bob') info.setdefault('edition', 1) for key, val in info.items(): # 遍历所有键值对，将这些内容作为其他子节点添加到每个book中 SubElement(book, key).text = ', '.join(str(val).split(':'))xml = tostring(books)print('*** RAW XML***')print(xml)print('***PRETTY-PRINTED XML***')dom = parseString(xml)print(dom.toprettyxml(' '))print('***FLAT STRUCTURE***')for elmt in books.iter(): print(elmt.tag, '-', elmt.text)print('\n***TITLE ONLY***')for book in books.findall('.//title'): print(book.text) 输出结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647*** RAW XML***b&apos;&lt;books&gt;&lt;book&gt;&lt;title&gt;Core&lt;/title&gt;&lt;edition&gt;2&lt;/edition&gt;&lt;year&gt;2007&lt;/year&gt;&lt;authors&gt;Bob&lt;/authors&gt;&lt;/book&gt;&lt;book&gt;&lt;title&gt;Python Programming&lt;/title&gt;&lt;edition&gt;3&lt;/edition&gt;&lt;authors&gt;Jack, Bob, Jerry&lt;/authors&gt;&lt;year&gt;2009&lt;/year&gt;&lt;/book&gt;&lt;book&gt;&lt;title&gt;Programming&lt;/title&gt;&lt;year&gt;2009&lt;/year&gt;&lt;authors&gt;Bob&lt;/authors&gt;&lt;edition&gt;1&lt;/edition&gt;&lt;/book&gt;&lt;/books&gt;&apos;***PRETTY-PRINTED XML***&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;books&gt; &lt;book&gt; &lt;title&gt;Core&lt;/title&gt; &lt;edition&gt;2&lt;/edition&gt; &lt;year&gt;2007&lt;/year&gt; &lt;authors&gt;Bob&lt;/authors&gt; &lt;/book&gt; &lt;book&gt; &lt;title&gt;Python Programming&lt;/title&gt; &lt;edition&gt;3&lt;/edition&gt; &lt;authors&gt;Jack, Bob, Jerry&lt;/authors&gt; &lt;year&gt;2009&lt;/year&gt; &lt;/book&gt; &lt;book&gt; &lt;title&gt;Programming&lt;/title&gt; &lt;year&gt;2009&lt;/year&gt; &lt;authors&gt;Bob&lt;/authors&gt; &lt;edition&gt;1&lt;/edition&gt; &lt;/book&gt;&lt;/books&gt;***FLAT STRUCTURE***books - Nonebook - Nonetitle - Coreedition - 2year - 2007authors - Bobbook - Nonetitle - Python Programmingedition - 3authors - Jack, Bob, Jerryyear - 2009book - Nonetitle - Programmingyear - 2009authors - Bobedition - 1***TITLE ONLY***CorePython ProgrammingProgramming]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>文本处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web框架:Django]]></title>
    <url>%2F2018%2F03%2F12%2FWeb%E6%A1%86%E6%9E%B6-Django%2F</url>
    <content type="text"><![CDATA[Django简介 安装在使用Django开发之前，必须安装必需的组件，包括依赖组件和Django本身 1pip3 install django 项目和应用项目 是指的一系列文件，用来创建并运行一个完整的Web站点。在项目文件夹下，有一个或多个子文件夹，每个文件夹有特定的功能，称为 应用。应用不一定要位于项目文件夹中。应用可以专注于项目某一方面的功能，或可以作为通用组件，用于不同的项目。应用是一个具有特定功能的子模块，这些子模块组合起来就能完成Web站点的功能。 在Django中创建项目Django自带有一个名为django-admin.py/django-admin.exe的工具，它可以简.化任务。在POSIX平台上，一般在/usr/local/bin、/usr/bin这样的目录中。使用Windows系统会安装在Python包下的Scripts目录下，如E:\Python\Python36\Scripts。两种系统都应该确保文件位于PATH环境变量中。在项目文件加下执行命令创建项目: 1django-admin.py startproject mysite Django项目文件 文件名 描述/用途 init.py 告诉Python这是一个软件包 urls.py 全局URL配置(“URLconf”) setting.py 项目相关的配置 manage.py 应用的命令行接口 运行开发服务器Django内置Web服务器，该服务器运行在本地，专门用于开发阶段，仅用于开发用途。使用开发服务器有以下几个优点： 可以直接运行与测试项目和应用，无需完整的生产环境 当改动Python源码文件并重新载入模块时，开发服务器会自动检测，无须每次编辑代码后手动重启 开发服务器知道如何为Django管理应用程序寻找和显示静态媒体文件，所以无须立即了解管理方面的内容 启动服务器 1python manage.py runserver 应用创建应用在项目目录下使用如下命令创建一个应用：1python3 ./manage.py startapp blog 这样就建立了一个blog目录，其中有如下内容： 文件名 描述/目的 __init.py 告诉Python这是一个包 urls.py 应用的URL配置文件(“URLconf”)，这个文件并不像项目的URLconf那样自动创建 models.py 数据模型 views.py 视图函数(即MVC中的控制器) tests.py 单元测试 与项目类似，应用也是一个Python包。本地应用的URLconf需要手动创建，接着使用URLconf里的include()指令将请求分配给应用的URLconf。为了让Django知道这个新应用是项目的一部分，需要编辑 settings.py，将应用名称(blog)添加到元组的末尾。Django使用 INSTALLED_APPS 来配置系统的不同部分，包括自动管理应用程序和测试框架。123456789INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'blog'] 创建模型添加数据库服务创建模型models.py 将定义博客的数据结构，首先创建一个基本类型。数据模型表示将会存储在数据库每条记录的数据类型。Django提供了许多字段类型，用来将数据映射到应用中。1234567891011121314from django.db import models# Create your models here.class BlogPost(models.Model): """ django.db.models.Model的子类Model是Django中用于数据模型的标准基类。 BlogPost中的字段像普通类属性那样定义， 每个都是特定字段类的实例，每个实例对应数据库中的一条记录。 """ title = models.CharField(max_length=150) body = models.TextField() timestamp = models.DateTimeField() 创建数据库在项目的setting.py文件中设置数据库。关于数据库，有6个相关设置(有时只需要两个):ENGINE、NAME、HOST、PORT、USER、PASSWORD。只需要在相关设置选项后面添上需要让Django使用的数据库服务器中合适的值即可。 使用MySQL 1234567891011DATABASES = &#123; # 使用mysql 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'django_test', 'USER': 'root', 'PASSWORD': '', 'HOST': 'localhost', 'PORT': '3306', &#125;&#125; 使用SQLiteSQLite一般用于测试，它没有主机、端口、用户、密码信息。因为其使用本地文件存储信息，本地文件系统的访问权限就是数据库的访问控制。SQLite不仅可以使用本地文件，还可以使用纯内存数据库。使用实际的Web服务器(如Apache)来使用SQLite时，需要确保拥有Web服务器进程的账户同时拥有数据库文件本身和含有数据库文件目录的写入权限。 1234567DATABASES = &#123; # 使用sqlite 'default': &#123; 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), &#125;&#125; 创建表使用 makemigrations 参数创建映射文件，当执行命令时Django会查找INSTALLED_APPS中列出的应用的models.py文件。对于每个找到的模型，都会创建一个映射表。1python3 ./manage.py makemigrations 使用 migrate 映射到数据库1python3 ./manage.py migrate Python应用Shell在Django中使用Python shell即使没有模版(view)或视图(controller)，也可以通过添加一些BlogPost项来测试数据模型。如果应用由RDBMS支持，则可以为每个blog项的表添加一个数据记录。如果使用的是NoSQL数据库，则需要向数据库中添加其他对象、文档或实体。通过以下命令启动shell(使用对应版本)：123456python3 ./manage.py shellPython 3.6.4 (default, Jan 6 2018, 11:51:59)Type &apos;copyright&apos;, &apos;credits&apos; or &apos;license&apos; for more informationIPython 6.2.1 -- An enhanced Interactive Python. Type &apos;?&apos; for help.In [1]: Django shell和标准的shell相比更专注于Django项目的环境，可以与视图函数和数据模型交互，这个shell会自动设置环境变量，包括sys.path，它可以访问Django与自己项目中的模块和包，否则需要手动配置。除了标准shell之外，还有其他的交互式解释器可供选择。Django更倾向于使用功能丰富的shell，如IPython和bpython，这些shell在普通的解释器基础上提供及其强大的功能。运行shell命令时，Django首先查找含有扩展功能的shell，如果没有回返回标准解释器。这里使用的是IPython。也可以使用 -i 来强制使用普通解释器。1234567python3 ./manage.py shell -i pythonPython 3.6.4 (default, Jan 6 2018, 11:51:59)[GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.39.2)] on darwinType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.(InteractiveConsole)&gt;&gt;&gt; 测试数据模型在启动Python shell之后输入一些Python或IPython命令来测试应用及其数据模型。1234567891011121314151617181920212223242526272829303132333435In [1]: from datetime import datetimeIn [2]: from blog.models import BlogPostIn [3]: BlogPost.objects.all()Out[3]: &lt;QuerySet [&lt;BlogPost: BlogPost object (1)&gt;, &lt;BlogPost: BlogPost object (2)&gt;, &lt;BlogPost: BlogPost object (3)&gt;]&gt;In [4]: bp = BlogPost(title=&apos;my blog&apos;, body=&apos;&apos;&apos; ...: my 1st blog... ...: yoooo!&apos;&apos;&apos;, ...: timestamp=datetime.now())In [5]: bpOut[5]: &lt;BlogPost: BlogPost object (None)&gt;In [6]: bp.save()In [7]: BlogPost.objects.count()Out[7]: 4In [9]: bp = BlogPost.objects.all()[0]In [11]: print(bp.title)test shellIn [13]: print(bp.body)my 1st blog post...yo!In [14]: bp.timestamp.ctime()Out[14]: &apos;Sun Mar 11 08:13:31 2018&apos; 前两行命令导入相应的对象，第3步查询数据库中BlogPost对象，第4步是实例化一个BlogPost对象来向数据库中添加BlogPost对象，向其中传入对应属性的值(title、body和timestamp)。创建完对象后，需要通过BlogPost.save()方法将其写入到数据库中。完成创建和写入后，使用BlogPost.objects.count()方法确认数据库中对象的个数。然后获取BlogPost对象列表的第一个元素并获取对应属性的值。设置时区:123456789LANGUAGE_CODE = 'zh-hans'TIME_ZONE = 'Asia/Shanghai'USE_I18N = TrueUSE_L10N = TrueUSE_TZ = False Django管理应用admin应用让开发者在完成完整的UI之前验证处理数据的代码。 设置admin在 setting.py 的INSTALLED_APP中添加&#39;django.contrib.admin&#39;,，然后运行python3 ./manage.py makemigrations和python3 ./manage.py migrate两条命令来创建其对应的表。在admin设置完之后于 urls.py 中设置url路径：123456from django.contrib import adminfrom django.urls import pathurlpatterns = [ path('admin/', admin.site.urls),] 最后应用程序需要告诉Django哪个模型需要在admin页面中显示并编辑，这时候就需要在应用的 admin.py 中注册BlogPost：1234from django.contrib import adminfrom blog import models# Register your models here.admin.site.register(models.BlogPost) 使用admin使用命令python3 ./manage.py runserver启动服务，然后在浏览器中输入 http://localhost:8000/admin 访问admin页面。在访问之前使用python3 manage.py createsuperuser创建的超级用户的用户名和密码用于登录管理页面。（账号：root，密码：Aa123456）为了更好地显示博文列表，更新blog/admin.py文件，使用新的BlogPostAdmin类：12345678910from django.contrib import adminfrom blog import models# Register your models here.class BlogPostAdmin(admin.ModelAdmin): list_display = ('title', 'timestamp')admin.site.register(models.BlogPost, BlogPostAdmin) 创建博客的用户界面Django shell和admin是针对于开发者的工具，而现在需要构建用户的界面。Web页面应该有以下几个经典组建： 模板，用于显示通过Python类字典对象传入的信息 视图函数，用于执行针对请求的核心逻辑。视图会从数据库中获取信息，并格式化显示结果 模式，将传入的请求映射到对应的视图中，同时也可以将参数传递给视图 Django是自底向上处理请求，它首先查找匹配的URL模式，接着调用对应的视图函数，最后将渲染好的数据通过模板展现给用户。构建应用可以按照如下顺序： 因为需要一些可观察对象，所以先创建基本的模板 设计一个简单的URL模式，让Django可以立刻访问应用 开发出一个视图函数原型，然后在此基础上迭代开发在构建应用过程中模板和URL模式不会发生太大的变化，而应用的核心是视图。这非常符合 测试驱动模型(TDD) 的开发模式。 创建模板 变量标签变量标签 是由 花括号() 括起来的内容，花括号内用于显示对象的内容。在变量标签中，可以使用Python风格的 点分割标识 访问这些变量的属性。这些值可以是纯数据，也可以是可调用对象，如果是后者，会自动调用这些对象而无需添加圆括号”()”来表示这个函数或方法可调用。 过滤器过滤器 是在变量标签中使用的特殊函数，它能在标签中立即对变量进行处理。方法是在变量右边插入一个 管道符号(“|”)，接着跟上过滤器名称。&lt;h2&gt; { { post.title | title } } &lt;/h2&gt; 上下文上下文 是一种特殊的Python字典，是传递给模板的变量。假设通过上下文传入的BlogPost对象称为”post”。通过上下文传入所有的博文，这样可以通过循环显示所有文章。 块标签块标签 通过花括号和百分号来表示：&#123;%…%&#125;，它们用于向HTML模版中插入如循环或判断这样的逻辑。 将HTML模版代码保存到一个简单的模版文件中，命名为archive.html，放置在应用文件夹下的 templates 目录下，模版名称任取，但模版目录一定是 templates12345&#123;%for post in posts%&#125; &lt;h2&gt;&#123;&#123;post.title&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;post.timestamp&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;post.body&#125;&#125;&lt;/h2&gt;&#123;% endfor%&#125; 创建URL模式 项目的URLconf服务器通过WSGI的功能，最终会将请求传递给Django。接受请求的类型(GET、POST等)和路径(URL中除了协议、主机、端口之外的内容)并传递到项目的URLconf文件(mysite/urls.py)。为了符合代码重用、DRY、在一处调试相同的代码等准则，需要应用能负责自己的URL。在项目的urls.py(这里时mysite/urls.py)中添加url配置项，让其指向应用的URLconf。123456789from django.contrib import adminfrom django.urls import pathfrom django.urls import includeurlpatterns = [ path('admin/', admin.site.urls), # include函数将动作推迟到其他URLconf # 这里将以blog/开通的请求缓存起来，并传递给mysite/blog/urls.py path('blog/', include('blog.urls'))] include() 会移除当前的URL路径头，路径中剩下的部分传递给下游URLconf中的path()函数。（当输入’http://localhost:8080/blog/foo/bar‘ 这个URL时，项目的URLconf接收到的是blog/foo/bar，匹配blog找到一个include()函数，然后将foo/bar传递给mysite/blog/urls.py）。上述代码中使用include()和未使用include()的区别在于使用include()传递的是 字符串，未使用include传递的是 对象。 应用的URLconf在项目的URLconf中通过include()包含blog.urls，让匹配blog应用的URL将剩余的部分传递到blog应用中处理。在mysite/blog/urls.py(没有就创建),添加以下代码：123456from django.urls import *import blog.viewsurlpatterns = [ # 第一个参数是路径，第二个参数是视图函数，在调用到这个URL时用于处理信息 path('', blog.views.archive)] 请求URL的头部分(blog/)匹配到的是根URLconf已经被去除。添加新的视图在列表中添加一行代码即可。 创建视图函数一个简单的视图函数会从数据库获取所有博文，并使用模板显示给用户： 向数据库查询所有博客条目 载入模板文件 为模板创建上下文字典 将模板渲染到HTML中 通过HTTP响应返回HTML在应用的views.py中添加如下代码:12345678910from django.shortcuts import renderfrom blog.models import BlogPostfrom django.template import loader, Contextfrom django.shortcuts import render_to_response# Create your views here.def archive(request): posts = BlogPost.objects.all() return render_to_response('archive.html', &#123;'posts': posts&#125;) 改进输出现在得到了一个可以工作的应用，有了可以工作的简单博客，可以响应客户端的请求，从数据库提取信息，向用户显示博文。现在更改查询方式，让博文按时间逆序显示，并且限制每页显示的数目。 BlogPOST是数据模型类。Objects属性是模型的Manager类，其中含有all()方法来获取QuerySet。QuerySet执行“惰性迭代”，在求值时才会真正查询数据库。 实现排序只需调用order_by()方法时提供一个排序参数即可(views.py)：1234def archive(request): # 在timestamp前面加上减号(-)指定按时间逆序排列。正常的升序只需要移除减号 posts = BlogPost.objects.all().order_by('-timestamp') return render_to_response('archive.html', &#123;'posts': posts&#125;) 为了测试限制显示数目，先启动Django shell添加数据：12345678910python ./manage.py shellPython 3.6.4 (v3.6.4:d48eceb, Dec 19 2017, 06:54:40) [MSC v.1900 64 bit (AMD64)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.(InteractiveConsole)&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; from blog.models import BlogPost&gt;&gt;&gt; for i in range(10):... bp = BlogPost(title=&apos;post $%d&apos; % i ,body=&apos;body of post $%d&apos; %d, timestamp=datetime.now())... bp.save()... 然后使用切片的方式获取最新的10篇(views.py)：1234def archive(request): # 在timestamp前面加上减号(-)指定按时间逆序排列。正常的升序只需要移除减号 posts = BlogPost.objects.all().order_by('-timestamp')[:10] return render_to_response('archive.html', &#123;'posts': posts&#125;) 设置模型的默认排序方式 如果在模型中设置首选的排序方式，其他基于Django的应用或访问这个数据的项目也会使用这个顺序。为了给模型设置默认顺序，需要创建一个名为 Meta 的内部类，在其中设置一个名为 ordering 的属性(models.py):123456789101112class BlogPost(models.Model): """ django.db.models.Model的子类Model是Django中用于数据模型的标准基类。 BlogPost中的字段像普通类属性那样定义， 每个都是特定字段类的实例，每个实例对应数据库中的一条记录。 """ title = models.CharField(max_length=150) body = models.TextField() timestamp = models.DateTimeField() class Meta: ordering = ('-timestamp',) 取消视图函数中的排序(views.py):1234def archive(request): # 在timestamp前面加上减号(-)指定按时间逆序排列。正常的升序只需要移除减号 posts = BlogPost.objects.all()[:10] return render_to_response('archive.html', &#123;'posts': posts&#125;) 处理用户输入 添加一个HTML表单，让用户可以输入数据(archive.html),为了防止 1234567891011121314&lt;form action="/blog/create/" method="post"&gt; Title: &lt;input type="text" name="title"&gt;&lt;br&gt; Body: &lt;textarea name="body" rows="3" cols="60"&gt;&lt;/textarea&gt;&lt;br&gt; &lt;input type="submit"&gt;&lt;/form&gt;&lt;hr&gt;&#123;%for post in posts%&#125; &lt;h2&gt;&#123;&#123;post.title&#125;&#125;&lt;/h2&gt; &lt;p&gt;&#123;&#123;post.timestamp&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;post.body&#125;&#125;&lt;/p&gt;&lt;hr&gt;&#123;% endfor %&#125; 插入(URL，视图)这样的URLConf项使用前面的HTML，需要用到/blog/create/的路径，所以需要将其关联到一个视图函数中，该函数用于把内容保存到数据库中，这个函数命名为create_blogpost()，在应用的urls.py中添加： 1234567from django.urls import *import blog.viewsurlpatterns = [ # 第一个参数是路径，第二个参数是视图函数，在调用到这个URL时用于处理信息 path('', blog.views.archive), path(r'create/', blog.views.create_blogpost)] 创建视图来处理用户输入在应用的views.py中添加上面定义的处理方法 1234567891011def create_blogpost(request): if request.method == 'POST': # 检查POST请求 # 创建新的BlogPost项，获取表单数据，并用当前时间建立时间戳。 BlogPost( title=request.POST.get('title'), body=request.POST.get('body'), timestamp=datetime.now() ).save() # 重定向会/blog return HttpResponseRedirect('/blog') 在完成上面的步骤之后，会发现创建表单的调用会被拦截报403的错误。这是因为Django有数据保留特性，不允许不安全的POST通过 跨站点请求伪造（Cross-site Request Forgery,CSRF） 来进行攻击。需要在HTML表单添加CSRF标记(&#123;% csrf_token %&#125;):123456789101112131415&lt;form action="/blog/create/" method="post"&gt;&#123;%csrf_token%&#125; Title: &lt;input type="text" name="title"&gt;&lt;br&gt; Body: &lt;textarea name="body" rows="3" cols="60"&gt;&lt;/textarea&gt;&lt;br&gt; &lt;input type="submit"&gt;&lt;/form&gt;&lt;hr&gt; &#123;%for post in posts%&#125; &lt;h2&gt;&#123;&#123;post.title&#125;&#125;&lt;/h2&gt; &lt;p&gt;&#123;&#123;post.timestamp&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;post.body&#125;&#125;&lt;/p&gt;&lt;hr&gt;&#123;% endfor %&#125; 通过模板发送向这些标记请求的上下文实例，这里将archive()方法调用的render_to_response()改为render:1234def archive(request): # 在timestamp前面加上减号(-)指定按时间逆序排列。正常的升序只需要移除减号 posts = BlogPost.objects.all()[:10] return render(request, 'archive.html', &#123;'posts': posts&#125;) 表单和模型表单 如果表单字段完全匹配一个数据模型，则通过Django ModelForm能更好的完成任务(models.py): 123456class BlogPostForm(forms.ModelForm): class Meta: # 定义一个Meta类，他表示表单基于哪个数据模型。当生成HTML表单时，会含有对应数据模型中的所有属性字段。 # 不信赖用户输入正确的时间戳可以通过添加exclude属性来设置。 model = BlogPost exclude = ('timestamp',) 使用ModelForm来生成HTML表单(archive.html): 123456789101112&lt;form action="/blog/create/" method="post"&gt;&#123;%csrf_token%&#125; &lt;table&gt;&#123;&#123;form&#125;&#125;&lt;/table&gt; &lt;input type="submit"&gt;&lt;/form&gt;&lt;hr&gt; &#123;%for post in posts%&#125; &lt;h2&gt;&#123;&#123;post.title&#125;&#125;&lt;/h2&gt; &lt;p&gt;&#123;&#123;post.timestamp&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;post.body&#125;&#125;&lt;/p&gt;&lt;hr&gt;&#123;% endfor %&#125; 因为数据已经存在于数据模型中，便不用去通过请求获取单个字段，而由于timestamp不能从表单获取，所以修改后的views.py中create_blogpost()方法如下: 12345678910111213141516def create_blogpost(request): if request.method == 'POST': # 检查POST请求 # 创建新的BlogPost项，获取表单数据，并用当前时间建立时间戳。 # BlogPost( # title=request.POST.get('title'), # body=request.POST.get('body'), # timestamp=datetime.now() # ).save() form = BlogPostForm(request.POST) if form.is_valid(): post = form.save(commit=False) post.timestamp = datetime.now() post.save() # 重定向会/blog return HttpResponseRedirect('/blog') 添加测试Django通过扩展Python自带的单元测试模块来提供测试功能。Django还可以测试文档字符串(即docstring)，这称为 文档测试(doctest) 应用的tests.py 12345678910111213141516171819202122232425262728293031323334353637383940414243from django.test import TestCasefrom datetime import datetimefrom django.test.client import Clientfrom blog.models import BlogPost# Create your tests here.class BlogPostTest(TestCase): # 测试方法必须以“test_”开头，方法名后面的部分随意。 def test_obj_create(self): # 这里仅仅通过测试确保对象成功创建，并验证标题内容 BlogPost.objects.create( title='raw title', body='raw body', timestamp=datetime.now()) # 如果两个参数相等则测试成功，否则该测试失败 # 这里验证对象的数目和标题 self.assertEqual(1, BlogPost.objects.count()) self.assertEqual('raw title', BlogPost.objects.get(id=1).title) def test_home(self): # 在'/blog/'中调用应用的主页面，确保收到200这个HTTP返回码 response = self.client.get('/blog/') self.assertIn(response.status_code, (200, )) def test_slash(self): # 测试确认重定向 response = self.client.get('/') self.assertIn(response.status_code, (301, 302)) def test_empty_create(self): # 测试'/blog/create/'生成的视图，测试在没有任何数据就错误地生成GET请求， # 代码应该忽略掉这个请求，然后重定向到'/blog' response = self.client.get('/blog/create/') self.assertIn(response.status_code, (301, 302)) def test_post_create(self): # 模拟真实用户请求通过POST发送真实数据，创建博客项，让后将用户重定向到"/blog" response = self.client.post('/blog/create/', &#123; 'title': 'post title', 'body': 'post body' &#125;) self.assertIn(response.status_code, (301, 302)) self.assertEqual(1, BlogPost.objects.count()) self.assertEqual('post title', BlogPost.objects.get(id=1).title) 源代码]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Web框架</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CGI和WSGI]]></title>
    <url>%2F2018%2F03%2F08%2FCGI%E5%92%8CWSGI%2F</url>
    <content type="text"><![CDATA[CGI这里将会主要介绍CGI的含义、与Web服务器的工作方式，使用Python创建CGI应用 CGI简介 通用网关接口(Common Gateway Interface CGI) 在Web服务器和应用之间充当了交互作用 Web服务器从客户端接收到请求(GET或POST)，并调用相应的应用程序 Web服务器和客户端等待HTML页面 应用程序处理完成后将会生成动态的HTML页面返回服务器，服务器将这个结果返回给用户 表单处理过程，服务器与外部应用程序交互，收到并生成的HTML页面通过CGI返回客户端含有需要用户输入项(文本框、单选按钮等)、Submit按钮、图片的Web页面，都会涉及某种CGI活动。创建HTML的CGI应用程序通常是高级语言来实现的，可以接受、处理用户数据，向服务器端返回HTML页面。CGI有明显的局限性，以及限制Web服务器同时处理客户端的数量。(CGI被抛弃的原因) CGI应用程序和和相关模块 CGI应用程序CGI 应用程序和典型的应用程序主要区别在于输入、输出以及用户和程序的交互方面。当一个CGI脚本启动后，需要获得用户提供的表单数据，但这些数据必须从Web客户端才可以获得，这就是 请求(request)。与标准输出不同，这些输出将会发送回连接的Web客户端，而不是发送到屏幕、GUI窗口或者硬盘上。这些返回的数据必须是具有一系列有效头文件的HTML标签数据。用户和脚本之间没有任何交互，所有交互都发生在Web客户端(基于用户的行为)、Web服务器端和CGI应用程序间。 cgi模块cgi模块有一个主要类 FieldStorage 完成了所有的工作。Python CGI脚本启动会实例化这个类，通过Web服务器从Web客户端读出相关的用户信息。在实例化完成后，其中会包含一个类似字典的对象，它具有一系列键值对。键就是通过表单传入的表单条目的名字，而值则包含响应的数据。这些值有三个对象：FieldStorage 对象；MiniFieldStorage 对象用在没有文件上传或mulitple-part格式数据的情况下，MiniFieldStorage 实例只包含名称和数据的键值对；当表单中的某个字段有多个输入值时，还可以是这些对象的列表。 cgitb模块cgitb模块用于在浏览器中看到Web应用程序的回溯信息，而不是“内部服务器错误”。 CGI应用程序 再启动服务器的目录下创建一个cgi-bin目录，放入Python CGI脚本。将一些HTML文件放到启动服务器的目录中。确保启动服务器目录中有个cgi-bin目录，同时确保其中有相应的.py文件。否则服务器将会把Python文件作为静态文本返回而不是执行它们 CGI服务器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#!/usr/bin/python3# -*- coding:UTF-8 -*-from cgi import FieldStoragefrom os import environfrom io import StringIOfrom urllib.parse import quote, unquoteclass AdvCGI(object): # 创建header和url静态类变量，在显示不同页面的方法中会用到这些变量 header = 'Content-Type:text/html\n\n' url = '/cgi-bin/advcgi.py' # HTML静态文本表单，其中含有程序语言设置和每种语言的HTML元素 formhtml = ''' &lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;Advanced CGI Demo&lt;/TITLE&gt; &lt;/HEAD&gt; &lt;BODY&gt; &lt;H2&gt;Advanced CGI Demo&lt;/H2&gt; &lt;FORM METHOD=post ACTION='%s' ENCTYPE='multipart/form-data'&gt; &lt;H3&gt;My Cookie Setting&lt;/H3&gt; &lt;LI&gt; &lt;CODE&gt;&lt;B&gt;CPPuser = %s&lt;/B&gt;&lt;/CODE&gt; &lt;H3&gt;Enter cookie value&lt;BR&gt; &lt;INPUT NAME=cookie value='%s'/&gt;(&lt;I&gt;optional&lt;/I&gt;) &lt;/H3&gt; &lt;H3&gt;Enter your name&lt;BR&gt; &lt;INPUT NAME=person VALUE='%s'/&gt;(&lt;I&gt;required&lt;/I&gt;) &lt;/H3&gt; &lt;H3&gt;What languages can you program in ? (&lt;I&gt;at least one required&lt;/I&gt;) &lt;/H3&gt; %s &lt;H3&gt;Enter file to upload&lt;SMALL&gt;(max size 4k)&lt;/SMALL&gt;&lt;/H3&gt; &lt;INPUT TYPE=file NAME=upfile VALUE='%s' SIZE=45&gt; &lt;P&gt;&lt;INPUT TYPE=submit /&gt; &lt;/LI&gt; &lt;/FORM&gt; &lt;/BODY&gt; &lt;/HTML&gt; ''' langset = ('Python', 'Java', 'C++', 'C', 'JavaScript') langItem = '&lt;INPUT TYPE=checkbox NAME=lang VALUE="%s"%s&gt; %s\n' def get_cpp_cookies(self): """ 当浏览器对应用进行连续调用时，将相同的cookie通过HTTP头发送回服务器 :return: """ # 通过HTTP_COOKIE访问这些值 if 'HTTP_COOKIE' in environ: cookies = [x.strip() for x in environ['HTTP_COOKIE'].split(';')] for eachCookie in cookies: # 寻找以CPP开头的字符串 # 只查找，名为“CPPuser”和“CPPinfo”的cookie值 if len(eachCookie) &gt; 6 and eachCookie[:3] == 'CPP': # 去除索引8处的值进行计算，计算结果保存到Python对象中 tag = eachCookie[3:7] try: # 查看cookie负载，对于非法的Python对象，仅仅保存相应的字符串值。 self.cookies[tag] = eval(unquote(eachCookie[8:])) except (NameError, SyntaxError): self.cookies[tag] = unquote(eachCookie[8:]) # 如果这个cookie丢失，就给他指定一个空字符串 if 'info' not in self.cookies: self.cookies['info'] = '' if 'user' not in self.cookies: self.cookies['user'] = '' else: self.cookies['info'] = self.cookies['user'] = '' if self.cookies['info'] != '': self.who, langstr, self.fn = self.cookies['info'].split(';') self.langs = langstr.split(',') else: self.who = self.fn = '' self.langs = ['Python'] def show_form(self): """ 将表单显示给用户 :return: """ # 从之前的请求中(如果有)获取cookie，并适当地调整表单的格式 self.get_cpp_cookies() langstr = [] for eachLang in AdvCGI.langset: langstr.append(AdvCGI.langItem % ( eachLang, ' CHECKED' if eachLang in self.langs else '', eachLang)) if not ('user' in self.cookies and self.cookies['user']): cookstatus = '&lt;I&gt;(cookie has not been set yet)&lt;/I&gt;' usercook = '' else: usercook = cookstatus = self.cookies['user'] print('%s%s' % (AdvCGI.header, AdvCGI.formhtml % ( AdvCGI.url, cookstatus, usercook, self.who, ''.join(langstr), self.fn))) errhtml = ''' &lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;Advanced CGI Demo&lt;/TITLE&gt; &lt;/HEAD&gt; &lt;BODY&gt; &lt;H3&gt;ERROR&lt;/H3&gt; &lt;B&gt;%s&lt;/B&gt; &lt;P&gt; &lt;FORM&gt; &lt;INPUT TYPE= button VALUE=Back ONCLICK="window.history.back()"&gt;&lt;/INPUT&gt; &lt;/FORM&gt; &lt;/BODY&gt; &lt;/HTML&gt; ''' def show_error(self): """ 生成错误页面 :return: """ print('%s%s' % (AdvCGI.header, AdvCGI.errhtml % (self.error))) reshtml = ''' &lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;Advanced CGI Demo&lt;/TITLE&gt; &lt;/HEAD&gt; &lt;BODY&gt; &lt;H2&gt;Your Uploaded Data&lt;/H2&gt; &lt;H3&gt;Your cookie value is: &lt;B&gt;%s&lt;/B&gt;&lt;/H3&gt; &lt;H3&gt;Your name is: &lt;B&gt;%s&lt;/B&gt;&lt;/H3&gt; &lt;H3&gt;You can program in the following languages:&lt;/H3&gt; &lt;UL&gt;%s&lt;/UL&gt; &lt;H3&gt;Your uploaded file...&lt;BR&gt; Name: &lt;I&gt;%s&lt;/I&gt;&lt;BR&gt; Contents: &lt;/H3&gt; &lt;PRE&gt;%s&lt;/PRE&gt; Click &lt;A HREF="%s"&gt;&lt;B&gt;here&lt;/B&gt;&lt;/A&gt; to return to form. &lt;/BODY&gt; &lt;/HTML&gt;''' def set_cpp_cookies(self): """ 应用程序调用这个方法来发送cookie（从Web服务器）到浏览器，并存储在浏览器中 :return: """ for eachCookie in self.cookies: print('Set-Cookie: CPP%s=%s; path=/' % ( eachCookie, quote(self.cookies[eachCookie]))) def doResult(self): """ 生成结果页面 :return: """ MAXBYTES = 4096 langlist = ''.join('&lt;LI&gt;%s&lt;BR&gt;' % eachLang for eachLang in self.langs) filedata = self.fp.read(MAXBYTES) if len(filedata) == MAXBYTES and f.read(): filedata = '%s%s' % (filedata, '...&lt;B&gt;&lt;I&gt;(file truncated due to size)&lt;/I&gt;&lt;/B&gt;') self.fp.close() if filedata == '': filedata = '&lt;B&gt;&lt;I&gt;(file not give or upload error)&lt;/I&gt;&lt;/B&gt;' filename = self.fn if not ('user' in self.cookies and self.cookies['user']): cookstatus = '&lt;I&gt;(cookie has not been set yet)&lt;/I&gt;' usercook = '' else: usercook = cookstatus = self.cookies['user'] self.cookies['info'] = ':'.join((self.who, ','.join(self.langs), filename)) self.set_cpp_cookies() print('%s%s' % ( AdvCGI.header, AdvCGI.reshtml % (cookstatus, self.who, langlist, filename, filedata, AdvCGI.url))) def go(self): self.cookies = &#123;&#125; self.error = '' form = FieldStorage() if not list(form.keys()): self.show_form() return if 'person' in form: print(form.keys()) self.who = form['person'].value.strip().title() if self.who == '': self.error = 'Your name is required.(blank)' else: self.error = 'Your name is required.(missing)' self.cookies['user'] = unquote(form['cookie'].value.strip()) if 'cookie' in form else '' if 'lang' in form: lang_data = form['lang'] if isinstance(lang_data, list): self.langs = [eachLang.value for eachLang in lang_data] else: self.langs = [lang_data.value] else: self.error = 'At least one language required' if 'upfile' in form: upfile = form['upfile'] self.fn = upfile.filename or '' if upfile.file: self.fp = upfile.file else: self.fp = StringIO('(no data)') else: self.fp = StringIO('(no file)') self.fn = '' if not self.error: self.doResult() else: self.show_error()if __name__ == '__main__': page = AdvCGI() page.go() 启动程序 将启动程序放在启动目录中，然后执行。 1234567#!/usr/bin/python# -*- coding:UTF-8 -*-from http.server import CGIHTTPRequestHandler, testif __name__ == '__main__': test(CGIHTTPRequestHandler) 源代码 WSGIWSGI1 是为了替代CGI而出现的。 服务器集成和外部进程 服务器集成服务器集成也叫 服务器API，其针对CGI性能的解决方案是将网关集成进服务器，不是讲服务器切分成多个语言解释器来分别处理请求，而是生成函数调用，运行应用程序代码，在运行过程中进行响应。服务器根据对应的API通过一组预先创建的进程或线程处理工作。服务器API的会使含有bug的代码影响服务器执行效率，不同语言的实现无法兼容，应用程序必须线程安全。 外部进程外部进程让CGI应用在服务器外部运行。当有请求进入时，服务器将这个请求传递到外部进程中。外部进程存在时间长，不是处理完单个请求后就终止，所以其扩展性比纯CGI好。因为使用了不同的调用机制，所以造成开发者的负担，不仅要开发应用本省，还要决定于服务器的集成。 WSGI简介WSGI只是定义的一个接口，其目标是在Web服务器和Web框架层之间提供一个通用的API标准，减少之间的会操作性并形成统一的调用方式。根据WSGI定义，其应用是可调用对象，其参数固定为：含有服务器环境变量的字典；可调用对象，该对象使用HTTP状态码和返回给客户端的HTTP头来初始化响应。 WSGI服务器在服务器端，必须调用应用，传入环境变量和start_response()这个可调用对象，接着等待应用执行完毕。在执行完成后，必须获得返回的可迭代对象，将这些数据返回给客户端。 1.WSGI只是做一个简单的了解，可以结合框架一起看。 ↩]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Web编程</tag>
        <tag>CGI</tag>
        <tag>WSGI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python Web客户端和服务器]]></title>
    <url>%2F2018%2F03%2F06%2FPython-Web%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Python Web客户端工具浏览器只是Web客户端的一种。任何一个向Web服务器端发送请求来获取数据的应用程序都是“客户端”。使用urllib模块下载或者访问Web上信息的应用程序就是简单的Web客户端。 统一资源定位符 URL(统一资源定位符)适用于网页浏览的一个地址，这个地址用来在Web上定位一个文档，或者调用一个CGI程序来为客户端生成一个文档。URL是多种统一资源标识符(Uniform Resource Identifier, URI)的一部分。一个URL是一个简单的URI，它使用已有的协议或方案(http/ftp等)。非URL的URI有时称为统一资源名称(Uniform Resource Name, URN)，现在唯一使用的URI只有URL。 URL使用以下格式：post_sch://net_loc/path;parans?query#frag Web地址的各个组件 URL组件 描述 post_sch 网络协议或下载方案 net_loc 服务器所在地(也许含有用户信息) path 使用斜杠(/)分割的文件或CGI应用的路径 params 可选参数 query 连接符(&amp;)分割的一系列键值对 frag 指定文档内特定锚的部分 net_loc可以拆分为多个组件，一些可选一些必备：user:passwd@host:port 网络地址的各个组件 组件 描述 user 用户名或登录(FTP) passwd 用户密码(FTP) host 运行Web服务器的计算机名称或地址(必需的) port 端口号(如果不是默认的80) Python3 使用urllib.parse和urllib.request两种不同的模块分别以不同的功能和兼容性来处理URL urllib.parse模块 urllib.parse核心函数 urllib.parse函数 描述 urllib.parse.urlparse(urlstring, scheme=’’,allow_fragments=True) 将urlstring解析成各个组件，如果在urlstring中没有给定协议或者方法，使用scheme；allow_fragments决定是否允许URL片段 urllib.parse.urlunparse(parts) 将URL数据的一个元组拼成URL字符串 urllib.parse.urljoin(base,url,allow_fragments=True) 将URL的根域名和url拼合成一个完整的URL；allow_fragments的决定是否允许URL片段 urllib.parse.quote(string,safe=’/‘,encoding=None,errors=None) 对string在URL里无法使用的字符进行编码，safe中的字符无需编码 urllib.parse.quote_plus(string,safe=’’,encoding,errors) 除了将空格编译成加(+)号(而非20%)之外，其他功能与quote()相似 urllib.parse.unquote(string,encoding=’utf-8’,errors=’replace’) 将string编译过的字符解码 urllib.parse.unquote_plus(string,encoding=’utf-8’,errors=’replace’) 除了将加好转换为空格，其他功能与unquote()相同 urllib.parse.urlencode(query,doseq=False,safe=’’,encoding=None,errors=None,quote_via=quote_plus) 将query通过quote_plus()编译成有效的CGI查询自妇产，用quote_plus()对这个字符串进行编码 下面将对每个方法进行演示,首先导入urllib.parse下面的所有方法from urllib.parse import * urllib.parse.urlparse(urlstring, scheme=’’,allow_fragments=True) 123urlparse('http://coldjune.com/categories/')# 输出结果ParseResult(scheme='http', netloc='coldjune.com', path='/categories/', params='', query='', fragment='') urllib.parse.urlunparse(parts) 123urlunparse(('http', 'coldjune.com', '/categories/', '', '', ''))# 输出结果'http://coldjune.com/categories/' urllib.parse.urljoin(base,url,allow_fragments=True) 1234567891011121314151617# 如果是绝对路径将整个替换除根域名以外的所有内容urljoin('http://coldjune.com/categories/1.html','/tags/2.html')# 输出结果'http://coldjune.com/tags/2.html'# 如果是相对路径将会将末端文件去掉与心得url连接urljoin('http://coldjune.com/categories/1.html','tags/2.html')# 输出结果'http://coldjune.com/categories/tags/2.html'``* *urllib.parse.quote(string,safe='/',encoding=None,errors=None)*&gt; 逗号、下划线、句号、斜线和字母数字这类符号不需要转换，其他均需转换。URL不能使用的字符前面会被加上百分号(%)同时转换为十六进制(%xx,xx表示这个字母的十六进制) ```Python quote('http://www.~coldjune.com/tag categoriese?name=coold&amp;search=6') # 输出结果 'http%3A//www.%7Ecoldjune.com/tag%20categoriese%3Fname%3Dcoold%26search%3D6' urllib.parse.unquote(string,encoding=’utf-8’,errors=’replace’) 123unquote('http%3A//www.%7Ecoldjune.com/tag%20categoriese%3Fname%3Dcoold%26search%3D6')# 输出结果'http://www.~coldjune.com/tag categoriese?name=coold&amp;search=6' urllib.parse.quote_plus(string,safe=’’,encoding,errors) 123quote_plus('http://www.~coldjune.com/tag categoriese?name=coold&amp;search=6')# 输出结果'http%3A%2F%2Fwww.%7Ecoldjune.com%2Ftag+categoriese%3Fname%3Dcoold%26search%3D6' urllib.parse.unquote_plus(string,encoding=’utf-8’,errors=’replace’) 123unquote_plus('http%3A%2F%2Fwww.%7Ecoldjune.com%2Ftag+categoriese%3Fname%3Dcoold%26search%3D6')# 输出结果'http://www.~coldjune.com/tag categoriese?name=coold&amp;search=6' urllib.parse.urlencode(query,doseq=False,safe=’’,encoding=None,errors=None,quote_via=quote_plus) 1234query=&#123;'name':'coldjune','search':'6'&#125;urlencode(query)# 输出结果'name=coldjune&amp;search=6' urllib.request模块/包 urllib.request模块核心函数 urllib.request函数 描述 urllib.request.urlopen(url, data=None, [timeout,]*,cafile=None, capath=None,cadefault=False,context=None) 打开url(string或者Request对象)，data为发送给服务器的数据，timeout为超时属性， cafile,capath,cadefault为调用HTTPS请求时证书认证 urllib.request.urlretrieve(url,filename=None,reporthook=None,data=None) 将url中的文件下载到filename或临时文件中(如果没有指定filename)；如果函数正在执行，reporthook将会获得下载的统计信息 urllib.request.urlopen(url, data=None, [timeout,],cafile=None, capath=None,cadefault=False,context=None) urlopen()打开url所指向的URL；如果没有给定协议或者下载方案，或者传入”file”方案，urlopen()会打开一个本地文件。对于所有的HTTP请求，使用”GET”请求，向Web服务器发送的请求字符串应该是url的一部分；使用”POST”请求，请求的字符串应该放到data变量中。连接成功后返回的是一个文件类型对象 urlopen()文件类型对象的方法 方法 描述 f.read([bytes]) 从f中读出所有或bytes个字节 f.readline() 从f中读取一行 f.readlines() 从f中读取所有行，作为列表返回 f.close() 关闭f的URL连接 f.fileno() 返回f的文件句柄 f.info() 获取f的MIME头文件 f.geturl() 返回f的真正URL urllib.request.urlretrieve(url,filename=None,reporthook=None,data=None) urlretrieve（）用于下载完整的HTML 如果提供了reporthook函数，则在每块数据下载或传输完成后调用这个函数。调用使用目前读入的块数、块的字节数和文件的总字节数三个参数。urlretrieve()返回一个二元组(local_filename, headers)，local_filename是含有下载数据的本地文件名，headers是Web服务器响应后返回的一系列MIME文件头。 HTTP验证示例 需要先启动本地的tomcat并访问tomcat地址 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!/usr/bin/python3# -*- coding:UTF-8 -*-import urllib.requestimport urllib.errorimport urllib.parse# 初始化过程# 后续脚本使用的常量LOGIN = 'wesly'PASSWD = "you'llNeverGuess"URL = 'http://localhost:8080/docs/setup.html'REALM = 'Secure Archive'def handler_version(url): # 分配了一个基本处理程序类，添加了验证信息。 # 用该处理程序建立一个URL开启器 # 安装该开启器以便所有已打开的URL都能用到这些验证信息 hdlr = urllib.request.HTTPBasicAuthHandler() hdlr.add_password(REALM, urllib.parse.urlparse(url)[1], LOGIN, PASSWD) opener = urllib.request.build_opener(hdlr) urllib.request.install_opener(opener=opener) return urldef request_version(url): # 创建了一个Request对象，在HTTP请求中添加了简单的base64编码的验证头 # 该请求用来替换其中的URL字符串 from base64 import encodebytes req = urllib.request.Request(url) b64str = encodebytes(bytes('%s %s' % (LOGIN, PASSWD), 'utf-8'))[:-1] req.add_header("Authorization", 'Basic %s' % b64str) return reqfor funcType in ('handler', 'request'): # 用两种技术分别打开给定的URL，并显示服务器返回的HTML页面的第一行 print('***Using %s:' % funcType.upper()) url = eval('%s_version' % funcType)(URL) f = urllib.request.urlopen(url) print(str(f.readline(), 'utf-8')) f.close() 输出结果 12345***Using HANDLER:&lt;!DOCTYPE html SYSTEM &quot;about:legacy-compat&quot;&gt;***Using REQUEST:&lt;!DOCTYPE html SYSTEM &quot;about:legacy-compat&quot;&gt; Web客户端一个稍微复杂的Web客户端例子就是 网络爬虫。这些程序可以为了不同目的在因特网上探索和下载页面。 通过起始地址(URL)，下载该页面和其他后续连接页面，但是仅限于那些与开始页面有相同域名的页面。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#!/usr/bin/python3# -*- coding:UTF-8 -*-# 导入相关的包，其中bs4中的BeautifulSoup负责解析html文档import osimport sysimport urllib.requestimport urllib.parsefrom bs4 import BeautifulSoupclass Retriever(object): """ 从Web下载页面，解析每个文档中的连接并在必要的时候把它们加入"to-do"队列。 __slots__变量表示实例只能拥有self.url和self.file属性 """ __slots__ = ('url', 'file') def __init__(self, url): """ 创建Retriever对象时调用，将get_file()返回的URL字符串和对 应的文件名作为实例属性存储起来 :param url: 需要抓取的连接 """ self.url, self.file = self.get_file(url) def get_file(self, url, default='index.html'): """ 把指定的URL转换成本地存储的更加安全的文件，即从Web上下载这个文件 :param url: 指定URL获取页面 :param default: 默认的文件名 :return: 返回url和对应的文件名 """ # 将URL的http://前缀移除，丢掉任何为获取主机名 # 而附加的额外信息，如用户名、密码和端口号 parsed = urllib.parse.urlparse(url) host = parsed.netloc.split('@')[-1].split(':')[0] # 将字符进行解码，连接域名创建文件名 filepath = '%s%s' % (host, urllib.parse.unquote(parsed.path)) if not os.path.splitext(parsed.path)[1]: # 如果URL没有文件扩展名后这将default文件加上 filepath = os.path.join(filepath, default) # 获取文件路径 linkdir = os.path.dirname(filepath) if not os.path.isdir(linkdir): # 如果linkdir不是一个目录 if os.path.exists(linkdir): # 如果linkdir存在则删除 os.unlink(linkdir) # 创建同名目录 os.makedirs(linkdir) return url, filepath def download(self): """ 通过给定的连接下载对应的页面，并将url作为参数调用urllib.urlretrieve() 将其另存为文件名。如果出错返回一个以'*'开头的错误提示串 :return: 文件名 """ try: retval = urllib.request.urlretrieve(self.url, filename=self.file) except IOError as e: retval = (('***ERROR: bad URL "%s": %s' % (self.url, e)),) return retval def parse_links(self): """ 通过BeautifulSoup解析文件，查看文件包含的额外连接。 :return: 文件中包含连接的集合 """ with open(self.file, 'r', encoding='utf-8') as f: data = f.read() soup = BeautifulSoup(data, 'html.parser') parse_links = [] for x in soup.find_all('a'): if 'href' in x.attrs: parse_links.append(x['href']) return parse_linksclass Crawler(object): """ 管理Web站点的完整抓取过程。添加线程则可以为每个待抓取的站点分别创建实例 """ # 用于保持追踪从因特网上下载下来的对象数目。没成功一个递增1 count = 0 def __init__(self, url): """ self.q 是待下载的连接队列，这个队列在页面处理完毕时缩短，每个页面中发现新的连接则增长 self.seen 是已下载连接的集合 self.dom 用于存储主链接的域名，并用这个值判定后续连接的域名与主域名是否一致 :param url: 抓取的url """ self.q = [url] self.seen = set() parsed = urllib.parse.urlparse(url) host = parsed.netloc.split('@')[-1].split(':')[0] self.dom = '.'.join(host.split('.')[-2:]) def get_page(self, url, media=False): """ 用于下载页面并记录连接信息 :param url: :param media: :return: """ # 实例化Retriever类并传入需要抓取的连接 # 下在对应连接并取到文件名 r = Retriever(url) fname = r.download()[0] if fname[0] == '*': print(fname, '....skipping parse') return Crawler.count += 1 print('\n(', Crawler.count, ')') print('URL:', url) print('FILE:', fname) self.seen.add(url) # 跳过所有非Web页面 ftype = os.path.splitext(fname)[1] if ftype not in ('.htm', '.html'): return for link in r.parse_links(): if link.startswith('mailto:'): print('...discarded , mailto link') continue if not media: ftype = os.path.splitext(link)[1] if ftype in ('.mp3', '.mp4', '.m4av', '.wav'): print('... discarded, media file') continue if not link.startswith('http://') and ':' not in link: link = urllib.parse.quote(link, safe='#') link = urllib.parse.urljoin(url, link) print('*', link) if link not in self.seen: if self.dom not in link: print('... discarded, not in domain') else: # 如果没有下载过并且是属于该网站就加入待下载列表 if link not in self.q: self.q.append(link) print('...New, added to Q') else: print('...discarded, already in Q') else: print('...discarded, already processed') def go(self, media=False): """ 处理所有待下载连接 :param media: :return: """ while self.q: url = self.q.pop() self.get_page(url, media)def main(): if len(sys.argv) &gt; 1: url = sys.argv[1] else: try: url = input('Enter starting URL:') except (KeyboardInterrupt, EOFError): url = '' if not url: return if not url.startswith('http://') and not url.startswith('ftp://') and not url.startswith('https://'): url = 'http://%s' % url robot = Crawler(url) robot.go()if __name__ == '__main__': main() 解析Web页面BeautifulSoup是解析页面的常用库，这个库不是标准库，需要单独下载。其使用可以参照上例中的代码。 可编程的Web浏览可以使用MechanicalSoup用来模拟浏览器。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Web客户端和服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OFFICE转换工具]]></title>
    <url>%2F2018%2F03%2F06%2FOFFICE%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[全双工聊天室]]></title>
    <url>%2F2018%2F03%2F04%2F%E5%85%A8%E5%8F%8C%E5%B7%A5%E8%81%8A%E5%A4%A9%E5%AE%A4%2F</url>
    <content type="text"><![CDATA[在前面的学习中，学习了正则表达式、多线程、网络编程、数据库等相关知识点。这里结合多线程、网络编程、GUI等相关内容实现了一个全双工的聊天室。 设计思路 GUI部分框架的搭建，并编写通用部分代码，完成显示部分的基类 客户端和服务器对GUI基类进行扩展，用于显示各自特有的内容 编程线程的通用类，使所有线程的实现都通过该类，便于统一管理 完成客户端和服务器端的代码并进行整合调试 实现代码GUI的基类 chat_base.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#!/usr/bin/python3# -*- coding:UTF-8 -*-import tkinter as tkclass ChatWindowBase(object): # 窗口的基类，创建通用的窗口布局 def __init__(self): # 初始化方法 # 创建tkinter.TK()顶层窗口 # 所有主要控件都是构建在顶层窗口对象之上 # 通过tkinter.TK()创建 self.top = tk.Tk() # 在顶层窗口上添加Label控件 self.label = tk.Label(self.top, text='聊天室') # 通过Packer来管理和显示控件 # 调用pack()方法显示布局 self.label.pack() # 通过Frame控件创建子容器，用于存放其他控件 # 该对象将作为单个子对象代替父对象 self.chatfm = tk.Frame(self.top) # Scrollbar可以让显示的数据在超过Listbox的大小时能够移动列表 self.chatsb = tk.Scrollbar(self.chatfm) # 将Scrollbar放置在子容器的右侧，并且是针对y轴 self.chatsb.pack(side='right', fill='y') # 在子容器中创建高为15宽为50的Listbox # 将Listbox和Scrollbar关联起来 # 显示列表 # 显示子容器 # 控件的显示应该内部控件先显示，再显示外部控件 self.chats = tk.Listbox(self.chatfm, height=15, width=50, yscrollcommand=self.chatsb.set) self.chatsb.config(command=self.chats.yview()) self.chats.pack(side='left', fill='both') self.chatfm.pack() # 创建发送消息的子容器 self.sendfm = tk.Frame(self.top, width=50) # 创建输入框 # 绑定回车键，并且绑定send方法 # 绑定一个方法是指在触发一个事件时会去调用的方法 self.chatn = tk.Entry(self.sendfm, width=40) self.chatn.bind('&lt;Return&gt;', self.send) self.chatn.pack(side='left') # 添加按钮控件、绑定方法 self.sendchat = tk.Button(self.sendfm, text='发送', command=self.send) self.sendchat.pack(side='right', fill='both') self.sendfm.pack() def send(self, ev=None): # 创建发送消息的方法 # 空实现是为了继承时扩展 pass def receive(self): # 创建接受消息的方法 # 空实现是为了继承时扩展 pass 线程的通用类 chat_thread.py 123456789101112131415161718#!/usr/bin/python3# -*- coding:UTF-8 -*-import threadingclass ChatThread(threading.Thread): # 继承自threading.Thread，用于创建聊天室的通用线程 def __init__(self, func, args): # func: 方法 # args：方法所需要的参数 threading.Thread.__init__(self) self.func = func self.args = args def run(self): # 实现run方法，将参数传给相应的方法 self.func(*self.args) 服务端 chat_s.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#!/usr/bin/python3# -*- coding:UTF-8 -*-from chat_base import ChatWindowBasefrom chat_thread import ChatThreadfrom socket import *from time import ctimeimport tkinterHOST = ''PORT = 12345ADDR = (HOST, PORT)BUFSIZ = 1024class ChatS(ChatWindowBase): # 服务器的实现类，继承自ChatWindowBase def __init__(self): # 调用父类的__init__()方法 super(ChatS, self).__init__() self.label.configure(text='服务器') # 设置属性 # 用于保存客户端链接对象 # 用于保存客户端链接地址 self.send_sock = None self.addr = '' # 在服务器窗口创建时调用 self.receive() def send(self, ev=None): # 获取输入框信息 message = self.chatn.get() # 启动线程 ChatThread(self.send_s, (message,)).start() # 将输入框信息按照格式显示在Listbox self.chats.insert('end', '[%s]:to %s\n' % (ctime(), self.addr)) self.chats.insert('end', '%s' % message) # 删除输入框内容 self.chatn.delete(first=0, last=len(message)+1) def receive(self): # 创建socket链接 # 绑定地址 # 设置监听 # 阻塞直到有链接调用，然后保存链接的客户端对象和地址 sock = socket(AF_INET, SOCK_STREAM) sock.bind(ADDR) sock.listen(5) cli_sock, addr = sock.accept() self.addr = addr self.send_sock = cli_sock print('addr', addr) # 有链接接入时在Listbox中显示消息 self.chats.insert('end', '%s 上线' % str(addr)) # 更新顶层窗口 self.top.update() # 启动接受消息的线程 ChatThread(self.receive_s, (cli_sock, addr)).start() def send_s(self, message): # 向客户端发送消息 self.send_sock.send(bytes(message, 'utf-8')) def receive_s(self, cli_sock, addr): # 接受消息 # cli_sock: 客户端sock # addr: 客户端地址 while True: # 进入无限循环接受消息，并在Listbox显示消息 receiveData = cli_sock.recv(BUFSIZ) print('接受到消息', receiveData.decode('utf-8')) self.chats.insert('end', '[%s]:from %s' % (ctime(), addr)) self.chats.insert('end', '%s' % receiveData.decode('utf-8')) self.top.update()def main(): # 创建服务器窗口 s = ChatS() # 调用mainloop()运行整个GUI tkinter.mainloop()if __name__ == '__main__': main() 客户端 chat_c.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#!/usr/bin/python3# -*- coding:UTF-8 -*-from chat_base import ChatWindowBasefrom chat_thread import ChatThreadfrom socket import *from time import ctimeimport tkinterHOST = '127.0.0.1'PORT = 12345ADDR = (HOST, PORT)BUFSIZ = 1024class ChatC(ChatWindowBase): # 客户端的实现类，继承子ChatWindowBase方法 def __init__(self): # 初始化方法 # 在子类中必须调用父类的__init__()方法 super(ChatC, self).__init__() # 设置label的标题 self.label.configure(text='客户端') # 设置属性，用于保存sock对象用于发送和接受消息 self.sock = None # 在创建窗口时链接服务器， # 客户端需要比服务器后创建 # 否则链接会创建失败 self.receive() def send(self, ev=None): # 继承自父类，为控件调用的方法 # 获取输入框的值 message = self.chatn.get() # 创建发送消息的线程 # 将方法和方法需要的参数用作线程初始化，并启动线程 ChatThread(self.send_c, (message,)).start() # 在Listbox中按格式显示消息 self.chats.insert('end', '[%s]:to %s' % (ctime(), ADDR)) self.chats.insert('end', '%s' % message) # 删除输入框中的消息 self.chatn.delete(first=0, last=len(message)+1) # 通过更新顶层窗口显示消息 self.top.update() def receive(self): # 继承自父类 # 创建socket链接 self.sock = socket(AF_INET, SOCK_STREAM) self.sock.connect(ADDR) # 启动线程 # 将方法和方法需要的参数用作线程初始化，并启动线程 ChatThread(self.receive_c, (self.sock,)).start() def send_c(self, message): # 调用sock的send方法，向服务器发送消息 self.sock.send(bytes(message, 'utf-8')) def receive_c(self, sock): # 接受服务器数据的方法 while True: # 进入循环，等待服务器发送的消息 data = sock.recv(BUFSIZ) # 将消息按照格式显示到Listbox中 self.chats.insert('end', '[%s]:from %s' % (ctime(), ADDR)) self.chats.insert('end', '%s' % data.decode('utf-8')) # 更新控件 self.top.update()def main(): # 实例化客户端窗口 c = ChatC() # 调用mainloop方法运行整个GUI tkinter.mainloop()if __name__ == '__main__': main() 源代码]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>多线程</tag>
        <tag>网络编程</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python数据库编程(二)]]></title>
    <url>%2F2018%2F02%2F28%2FPython%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[上一篇中主要对直接操作数据库做了一个比较详细的总结，这里将会对使用ORM框架进行简要的描述。 ORMORM系统的作者将纯SQL语句进行了抽象化处理，将其实现为Python中的对象，这样只操作这些对象就能完成与生成SQL语句相同的任务。 python与ORMSQLAlchemy和SQLObject是两种不同的Python ORM。这两种ORM并不在Python标准库中，所以需要安装。 安装SQLAlchemypip3 install sqlalchemy 安装SQLObjectpip3 install -U SQLObject 在这里将会通过两种ORM移植上一篇的数据库适配器示例应用 SQLAlchemy SQLAlchemy相比于SQLObject的接口更加接近于SQL语句。SQLAlchemy中对象的抽象化十分完成，还可以以更好的灵活性提交原生的SQL语句 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#!/usr/bin/python3# -*- coding:UTF-8 -*-# 首先导入标准库中的模块(os.path、random)# 然后是第三方或外部模块(sqlalchemy)# 最后是应用的本地模块(ushuffleDB)from os.path import dirnamefrom random import randrange as randfrom sqlalchemy import Column, Integer, \ String, create_engine, exc, ormfrom sqlalchemy.ext.declarative \ import declarative_basefrom ushuffleDB import DBNAME, NAMELEN, \ randName, FIELDS, tformat, cformat, setup# 数据库类型+数据库驱动名称://用户名:密码@地址:端口号/数据库名称DSNs = &#123; 'mysql': 'mysql+pymysql://root:root@localhost:3306/%s' % DBNAME, 'sqlite': 'sqlite:///:memory:',&#125;# 使用SQLAlchemy的声明层# 使用导入的sqlalchemy.ext.declarative.declarative_base# 创建一个Base类Base = declarative_base()class Users(Base): # 数据子类 # __tablename__定义了映射的数据库表名 __tablename__ = 'users' # 列的属性，可以查阅文档来获取所有支持的数据类型 login = Column(String(NAMELEN)) userid = Column(Integer, primary_key=True) projid = Column(Integer) def __str__(self): # 用于返回易于阅读的数据行的字符串格式 return ''.join(map(tformat, (self.login, self.userid, self.projid)))class SQLAlchemyTest(object): def __init__(self, dsn): # 类的初始化执行了所有可能的操作以便得到一个可用的数据库，然后保存其连接 # 通过设置echo参数查看ORM生成的SQL语句 # create_engine('sqlite:///:memory:', echo=True) try: eng = create_engine(dsn) except ImportError: raise RuntimeError() try: eng.connect() except exc.OperationalError: # 此处连接失败是因为数据库不存在造成的 # 使用dirname()来截取掉数据库名，并保留DSN中的剩余部分 # 使数据库的连接可以正常运行 # 这是一个典型的操作任务而不是面向应用的任务，所以使用原生SQL eng = create_engine(dirname(dsn)) eng.execute('CREATE DATABASE %s' % DBNAME).close() eng = create_engine(dsn) # 创建一个会话对象，用于管理单独的事务对象 # 当涉及一个或多个数据库操作时，可以保证所有要写入的数据都必须提交 # 然后将这个会话对象保存，并将用户的表和引擎作为实例属性一同保存下来 # 引擎和表的元数据进行了额外的绑定，使这张表的所有操作都会绑定到这个指定的引擎中 Session = orm.sessionmaker(bind=eng) self.ses = Session() self.users = Users.__table__ self.eng = self.users.metadata.bind = eng def insert(self): # session.add_all()使用迭代的方式产生一系列的插入操作 self.ses.add_all( Users(login=who, userid=userid, projid=rand(1, 5)) for who, userid in randName() ) # 决定是提交还是回滚 self.ses.commit() def update(self): fr = rand(1, 5) to = rand(1, 5) i = -1 # 会话查询的功能，使用query.filter_by()方法进行查找 users = self.ses.query(Users).filter_by(projid=fr).all() for i, user in enumerate(users): user.projid = to self.ses.commit() return fr, to, i+1 def delete(self): rm = rand(1, 5) i = -1 users = self.ses.query(Users).filter_by(projid=rm).all() for i, user in enumerate(users): self.ses.delete(user) self.ses.commit() return rm, i+1 def dbDump(self): # 在屏幕上显示正确的输出 print('\n%s' % ''.join(map(cformat, FIELDS))) users = self.ses.query(Users).all() for user in users: print(user) self.ses.commit() def __getattr__(self, attr): # __getattr__()可以避开创建drop()和create()方法 # __getattr__()只有在属性查找失败时才会被调用 # 当调用orm.drop()并发现没有这个方法时，就会调用getattr(orm, 'drop') # 此时调用__getattr__()，并且将属性名委托给self.users。结束期会发现 # slef.users存在一个drop属性，然后传递这个方法调用到self.users.drop()中 return getattr(self.users, attr) def finish(self): # 关闭连接 self.ses.connection().close()def main(): # 入口函数 print('\n***Connnect to %r database' % DBNAME) db = setup() if db not in DSNs: print('ERROR: %r not supported, exit' % db) return try: orm = SQLAlchemyTest(DSNs[db]) except RuntimeError: print('ERROR: %r not supported, exit' % db) return print('\n*** Create users table(drop old one if appl.') orm.drop(checkfirst=True) orm.create() print('\n***Insert namse into table') orm.insert() orm.dbDump() print('\n***Move users to a random group') fr, to, num = orm.update() print('\t(%d users moved) from (%d) to (%d))' % (num, fr, to)) orm.dbDump() print('\n***Randomly delete group') rm, num = orm.delete() print('\t(group #%d; %d users removed)' % (rm, num)) orm.dbDump() print('\n***Drop users table') orm.drop() print('***Close cxns') orm.finish()if __name__ == '__main__': main() mysql输出结果 123456789101112131415161718192021222324252627282930313233343536***Connnect to &apos;test&apos; databaseChoose a database system: (M)ySQL (S)QLiteEnter choice:M*** Create users table(drop old one if appl.***Insert namse into tableLOGIN USERID PROJID Bob 1234 1 Dave 4523 1 Angela 4567 3 ***Move users to a random group (2 users moved) from (1) to (4))LOGIN USERID PROJID Bob 1234 4 Dave 4523 4 Angela 4567 3 ***Randomly delete group (group #2; 0 users removed)LOGIN USERID PROJID Bob 1234 4 Dave 4523 4 Angela 4567 3 ***Drop users table***Close cxns SQLite输出结果 1234567891011121314151617181920212223242526272829303132333435***Connnect to &apos;test&apos; databaseChoose a database system: (M)ySQL (S)QLiteEnter choice:S*** Create users table(drop old one if appl.***Insert namse into tableLOGIN USERID PROJID Bob 1234 2 Dave 4523 1 Angela 4567 2 ***Move users to a random group (2 users moved) from (2) to (2))LOGIN USERID PROJID Bob 1234 2 Dave 4523 1 Angela 4567 2 ***Randomly delete group (group #1; 1 users removed)LOGIN USERID PROJID Bob 1234 2 Angela 4567 2 ***Drop users table***Close cxns SQLObjectSQLObject需要mysqldb支持，但是由于mysqldb不再支持python3，所以根据提示安装替代方案Mysqlclient，选择对应的版本进行下载后执行相应的命令：pip3 install mysqlclient-1.3.12-cp36-cp36m-win_amd64.whl 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#!/usr/bin/python3# -*- coding:UTF-8 -*-# 使用SQLObject代替SQLAlchemy# 其余和使用SQLAlchemy的相同from os.path import dirnamefrom random import randrange as randfrom sqlobject import *from ushuffleDB import DBNAME, NAMELEN, \ randName, FIELDS, tformat, cformat, setupDSNs = &#123; 'mysql': 'mysql://root:root@127.0.0.1:3306/%s' % DBNAME, 'sqlite': 'sqlite:///:memory:',&#125;class Users(SQLObject): # 扩展了SQLObject.SQLObject类 # 定义列 login = StringCol(length=NAMELEN) userid = IntCol() projid = IntCol() def __str__(self): # 提供用于显示输出的方法 return ''.join(map(tformat, ( self.login, self.userid, self.projid)))class SQLObjectTest(object): def __init__(self, dsn): # 确保得到一个可用的数据库，然后返回连接 try: cxn = connectionForURI(dsn) except ImportError: raise RuntimeError() try: # 尝试对已存在的表建立连接 # 规避RMBMS适配器不可用，服务器不在线及数据库不存在等异常 cxn.releaseConnection(cxn.getConnection()) except dberrors.OperationalError: # 出现异常则创建表 cxn = connectionForURI(dirname(dsn)) cxn.query('CREATE DATABASE %s' % DBNAME) cxn = connectionForURI(dsn) # 成功后在self.cxn中保存连接对象 self.cxn = sqlhub.processConnection = cxn def insert(self): # 插入 for who, userid in randName(): Users(login=who, userid=userid, projid=rand(1, 5)) def update(self): # 更新 fr = rand(1, 5) to = rand(1, 5) i = -1 users = Users.selectBy(projid=fr) for i, user in enumerate(users): user.projid = to return fr, to, i+1 def delete(self): # 删除 rm = rand(1, 5) users = Users.selectBy(projid=rm) i = -1 for i, user in enumerate(users): user.destroySelf() return rm, i+1 def dbDump(self): print('\n%s' % ''.join(map(cformat, FIELDS))) for user in Users.select(): print(user) def finish(self): # 关闭连接 self.cxn.close()def main(): print('***Connect to %r database' % DBNAME) db = setup() if db not in DSNs: print('\nError: %r not support' % db) return try: orm = SQLObjectTest(DSNs[db]) except RuntimeError: print('\nError: %r not support' % db) return print('\n***Create users table(drop old one if appl.)') Users.dropTable(True) Users.createTable() print('\n*** Insert names into table') orm.insert() orm.dbDump() print('\n*** Move users to a random group') fr, to, num = orm.update() print('\t(%d users moved) from (%d) to (%d)' % (num, fr, to)) orm.dbDump() print('\n*** Randomly delete group') rm, num = orm.delete() print('\t(group #%d;%d users removed)' % (rm, num)) orm.dbDump() print('\n*** Drop users table') # 使用dropTable()方法 Users.dropTable() print('\n***Close cxns') orm.finish()if __name__ == '__main__': main() MySQL输出结果 123456789101112131415161718192021222324252627282930313233Choose a database system:(M)ySQL(S)QLiteEnter choice:M***Create users table(drop old one if appl.)*** Insert names into tableLOGIN USERID PROJID Bob 1234 4 Dave 4523 3 Angela 4567 1 *** Move users to a random group(0 users moved) from (2) to (4)LOGIN USERID PROJID Bob 1234 4 Dave 4523 3 Angela 4567 1 *** Randomly delete group(group #3;1 users removed)LOGIN USERID PROJID Bob 1234 4 Angela 4567 1 *** Drop users table***Close cxns SQLite输出结果 123456789101112131415161718192021222324252627282930313233Choose a database system:(M)ySQL(S)QLiteEnter choice:S***Create users table(drop old one if appl.)*** Insert names into tableLOGIN USERID PROJID Bob 1234 2 Angela 4567 4 Dave 4523 3 *** Move users to a random group(1 users moved) from (3) to (1)LOGIN USERID PROJID Bob 1234 2 Angela 4567 4 Dave 4523 1 *** Randomly delete group(group #2;1 users removed)LOGIN USERID PROJID Angela 4567 4 Dave 4523 1 *** Drop users table***Close cxns 非关系型数据库Web和社交服务会产生大量的数据，并且数据的产生速率可能要比关系型数据库能够处理得更快。非关系数据库有对象数据库、键-值对存储、文档存储（或数据存储）、图形数据库、表格数据库、列/可扩展记录/宽列数据库、多值数据库等很多种类。 MongoDBMongoDB是非常流行的文档存储非关系数据库。 文档存储(MongoDB、CouchDB/Amazon SimpleDB)与其他非关系数据库的区别在于它介于简单的键-值对存储(Redis、Voldemort)与列存储(HBase、Google Bigtable)之间。比基于列的存储更简单、约束更少。比普通的键-值对存储更加灵活。一般情况下其数据会另存为JSON对象、并且允许诸如字符串、数值、列表甚至嵌套等数据类型 MongoDB(以及NoSQL)要讨论的事文档、集合而不是关系数据库中的行和列。MongoDB将数据存储于特殊的JSON串(文档)中，由于它是一个二进制编码的序列化，通常也称其为BSON格式。它和JSON或者Python字典都很相似。 PyMongo:MongoDB和PythonPyMongo是Python MongoDB驱动程序中最正式的一个。使用之前需要安装MongoDB数据库和PyMongo：pip3 install pymongo在windows下需要运行mongo.exe启动MongoDB，进入cmd到MongoDB的bin目录下，执行如下命令.mongod --dbpath E:\MongoDB\data 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#!/usr/bin/python3# -*- coding:UTF-8 -*-# 主要导入的是MongoClient对象和及其包异常errorsfrom random import randrange as randfrom pymongo import MongoClient, errorsfrom ushuffleDB import DBNAME, randName, FIELDS, tformat, cformat# 设置了集合(“表”)名COLLECTION = 'users'class MongoTest(object): def __init__(self): # 创建一个连接，如果服务器不可达，则抛出异常 try: cxn = MongoClient() except errors.AutoReconnect: raise RuntimeError # 创建并复用数据库及“users”集合 # 关系数据库中的表会对列的格式进行定义， # 然后使遵循这个列定义的每条记录成为一行 # 非关系数据库中集合没有任何模式的需求， # 每条记录都有其特定的文档 # 每条记录都定义了自己的模式，所以保存的任何记录都会写入集合中 self.db = cxn[DBNAME] self.users = self.db[COLLECTION] def insert(self): # 向MongoDB的集合中添加值 # 使用dict()工厂函数为每条记录创建一个文档 # 然后将所有文档通过生成器表达式的方式传递给集合的insert()方法 self.users.insert( dict(login=who, userid=uid, projid=rand(1, 5) )for who, uid in randName() ) def update(self): # 集合的update()方法可以给开发者相比于典型的数据库系统更多的选项 fr = rand(1, 5) to = rand(1, 5) i = -1 # 在更新前，首先查询系统中的项目ID(projid)与要更新的项目组相匹配的所有用户 # 使用find()方法，并将查询条件传进去(类似SQL的SELECT语句) for i, user in enumerate(self.users.find(&#123;'projid': fr&#125;)): # 使用$set指令可以显式地修改已存在的值 # 每条MongoDB指令都代表一个修改操作，使得修改操作更加高效、有用和便捷 # 除了$set还有一些操作可以用于递增字段值、删除字段(键-值对)、对数组添加/删除值 # update()方法可以用来修改多个文档(将multi标志设为True) self.users.update(user, &#123; '$set': &#123;'projid': to&#125; &#125;) return fr, to, i+1 def delete(self): # 当得到所有匹配查询的用户后，一次性对其执行remove()操作进行删除 # 然后返回结果 rm = rand(1, 5) i = -1 for i, user in enumerate(self.users.find(&#123;'projid': rm&#125;)): self.users.remove(user) return rm, i+1 def dbDump(self): # 没有天剑会返回集合中所有用户并对数据进行字符串格式化向用户显示 print('%s' % ''.join(map(cformat, FIELDS))) for user in self.users.find(): print(''.join(map(tformat, ( user[k] for k in FIELDS))))def main(): print('***Connect to %r database' % DBNAME) try: mongo = MongoTest() except RuntimeError: print('\nERROR: MongoDB server unreadable, exit') return print('\n***Insert names into table') mongo.insert() mongo.dbDump() print('\n***Move users to a random group') fr, to, num = mongo.update() print('\t(%d users moved) from (%d) to (%d)' % (num, fr, to)) mongo.dbDump() print('\n*** Randomly delete group') rm, num = mongo.delete() print('\tgroup #%d; %d users removed' % (rm, num)) mongo.dbDump() print('\n***Drop users table') mongo.db.drop_collection(COLLECTION)if __name__ == '__main__': main() 执行结果 12345678910111213141516171819202122***Connect to &apos;test&apos; database***Insert names into tableLOGIN USERID PROJID Dave 4523 4 Bob 1234 4 Angela 4567 2 ***Move users to a random group (0 users moved) from (1) to (2)LOGIN USERID PROJID Dave 4523 4 Bob 1234 4 Angela 4567 2 *** Randomly delete group group #2; 1 users removedLOGIN USERID PROJID Dave 4523 4 Bob 1234 4 ***Drop users table]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据库编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python数据库编程(一)]]></title>
    <url>%2F2018%2F02%2F28%2FPython%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Python和大多数语言一样，访问数据库包括直接通过数据库接口访问和使用ORM访问两种方式。其中ORM访问的方式不需要显式地给出SQL命令。在Python中数据库是通过适配器的方式进行访问的。适配器是一个Python模块，使用它可以与关系型数据库的客户端库接口相连。 Python的DB-API DB-API是阐明一系列所需对象和数据库访问机制的标准，它可以为不同的数据库适配器和底层数据库系统提供一致性访问 模块属性DB-API模块属性 属性 描述 apilevel 需要适配器兼容的DB-API版本 threadsafety 本模块的线程安全级别 paramstyle 本模块的SQL语句参数风格 connect() Connect()函数 (多种异常) 数据属性 apilevel 该字符串指明了模块需要兼容的DB-API最高版本，默认值为1.0 threadsafety 0: 不支持线程安全。线程间不能共享模块1: 最小化线程安全支持：线程间可以共享模块，但是不能共享连接2: 适度的线程安全支持：线程间可以共享模块和连接，但是不能共享游标3: 完整的线程安全支持：线程间可以共享模块、连接和游标 如果有资源需要共享，那么就需要诸如自旋锁、信号量等同步原语达到原子锁定的目的 参数风格 paramstyle 参数风格 描述 示例 numeric 数值位置风格 WHERE name=:1 named 命名风格 WHERE name=:name pyformat Python字典printf()格式转换 WHERE name=%(name)s qmark 问号风格 WHERE name=? format ANSIC的printf()格式转换 WHERE name=%s 函数属性 connect()函数通过Connection对象访问数据库。兼容模块必须实现connect()函数。该函数创建并放回一个Connection对象 connect()函数使用例子：connect(dsn=&#39;myhost:MYDB&#39;, user=&#39;root&#39;, password=&#39;root&#39;) connect()函数属性 参数 描述 user 用户名 password 面 host 主机名 database 数据库名 dsn 数据源名 使用ODBC或JDBC的API需要使用DSN；直接使用数据库，更倾向于使用独立的登录参数。 异常 异常 描述 Warning 警告异常基类 Error 错误异常基类 InterfaceError 数据库接口(非数据库)错误 DatabaseError 数据库错误 DataError 处理数据时出现错误 OperationError 数据库操作执行期间出现的错误 IntegrityError 数据库关系完整性错误 InternalError 数据库内部错误 ProgrammingError SQL命令执行失败 NotSupportedError 出现不支持的操作 Connection对象 只有通过数据连接才能把命令传递到服务器，并得到返回的结果。当一个连接(或一个连接池)建立后，可以创建一个游标，向数据库发送请求，然后从数据库接收回应 Connection对象方法 方法名 描述 close() 关闭数据库连接 commit() 提交当前事务 rollback() 取消当前事务 cursor() 使用该连接创建(并返回)一个游标或类游标的对象 errorhandler(cxn,cur,errcls,errval) 作为给定连接的游标的处理程序 当使用close()时，这个连接将不能再使用，否则会进入到异常处理中 如果数据库不支持事务处理或启用了自动提交功能，commit()方法都无法使用 rollback()只能在支持事务处理的数据库中使用。发生异常时，rollback()会将数据库的状态恢复到事务处理开始时。 如果RDBMS(关系数据库管理系统)不支持游标，cursor()会返回一个尽可能模仿真实游标的对象 Cursor对象 游标可以让用户提交数据库命令，并获得查询的结果行。 对象属性 描述 arraysize 使用fetchmany()方法时，一次取出的结果行数，默认为1 connection 创建此游标的连接(可选) description 返回游标活动状态(7项元组):(name,type_code,display_size,internal_size,precision,scale,null-ok)，只有name和type_code是必需的 lastrowid 上次修改行的行ID(可选，如果不支持行ID，则返回None) rowcount 上次execute*()方法处理或影响的行数 callproc(func[,args]) 调用存储过程 close() 关闭游标 execute(op[,args]) 执行数据库查询或命令 executemany(op,args) 类似execute()和map()的结合，为给定的所有参数准备并执行数据库查询或命令 fetchone() 获取查询结果的下一行 fetchmany([size=cursor,arraysize]) 获取查询结果的下面size行 fetchall() 获取查询结果的所有(剩余)行 iter() 为游标创建迭代器对象(可选，参考nexi()) messages 游标执行后从数据库中获得的消息列表(元组集合，可选) next() 被迭代器用于获取查询结果的下一行(可选，类似fetchone(),参考iter()) nextset() 移动到下一个结果集合(如果支持) rownumber 当前结果集中游标的索引(以行为单位，从0开始，可选) setinputsizes(sizes) 设置允许的最大输入大小(必须有，但是实现是可选的) setoutputsize(size[,col]) 设置大列获取的最大缓冲区大小(必须有，但是实现是可选的) 游标对象最重要的属性是execute()和fetch()方法，所有针对数据库的服务请求都通过它们执行。当不需要是关闭游标 类型对象和构造函数 创建构造函数，从而构建可以简单地转换成适当数据库对象的特殊对象 类型对象 描述 Date(yr,mo,dy) 日期值对象 Time(hr,min,sec) 时间值对象 Timestamp(yr,mo,dy,hr,min,sec) 时间戳值对象 DateFromTicks(ticks) 日期对象，给出从新纪元时间（1970 年1 月1 日00:00:00 UTC）以来的秒数 TimeFromTicks(ticks) 时间对象，给出从新纪元时间（1970 年1 月1 日00:00:00 UTC）以来的秒数 TimestampFromTicks(ticks) 时间戳对象，给出从新纪元时间（1970 年1 月1 日00:00:00 UTC）以来的秒数 Binary(string) 对应二进制(长)字符串对象 STRING 表示基于字符串列的对象，比如VARCHAR BINARY 表示(长)二进制列的对象，比如RAW、BLOB NUMBER 表示数值列的对象 DATETIME 表示日期/时间列的对象 ROWID 表示“行ID”列的对象 SQL的NULL值对应于Python的NULL对象None 数据库适配器示例应用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201#!/usr/bin/python3# -*- coding:UTF-8 -*-# 导入必需的模块import osfrom random import randrange as rand# 创建了全局变量# 用于显示列的大小，以及支持的数据库种类COLSIZ = 10FIELDS = ('login', 'userid', 'projid')RDBMSs = &#123; 's': 'sqlite', 'm': 'mysql',&#125;DBNAME = 'test'DBUSER = 'root'# 数据库异常变量，根据用户选择运行的数据库系统的不同来制定数据库异常模块DB_EXC = NoneNAMELEN = 16# 格式化字符串以显示标题# 全大写格式化函数，接收每个列名并使用str.upper()方法把它转换为头部的全大写形式# 两个函数都将其输出左对齐，并限制为10个字符的宽度ljust(COLSIZ)tformat = lambda s: str(s).title().ljust(COLSIZ)cformat = lambda s: s.upper().ljust(COLSIZ)def setup(): return RDBMSs[input(''' Choose a database system: (M)ySQL (S)QLite Enter choice: ''').strip().lower()[0]]def connect(db): # 数据库一致性访问的核心 # 在每部分的开始出尝试加载对应的数据库模块，如果没有找到合适的模块 # 就返回None，表示无法支持数据库系统 global DB_EXC dbDir = '%s_%s' % (db, DBNAME) if db == 'sqlite': try: # 尝试加载sqlite3模块 import sqlite3 except ImportError: return None DB_EXC = sqlite3 # 当对SQLite调用connect()时，会使用已存在的目录 # 如果没有，则创建一个新目录 if not os.path.isdir(dbDir): os.mkdir(dbDir) cxn = sqlite3.connect(os.path.join(dbDir, DBNAME)) elif db == 'mysql': try: # 由于MySQLdb不支持python3.6，所以导入pymysql import pymysql import pymysql.err as DB_EXC try: cxn = pymysql.connect(host="localhost", user="root", password="root", port=3306, db=DBNAME) except DB_EXC.InternalError: try: cxn = pymysql.connect(host="localhost", user="root", password="root", port=3306) cxn.query('CREATE DATABASE %s' % DBNAME) cxn.commit() cxn.close() cxn = pymysql.connect(host="localhost", user="root", password="root", port=3306, db=DBNAME) except DB_EXC.InternalError: return None except ImportError: return None else: return None return cxndef create(cur): # 创建一个新表users try: cur.execute(''' CREATE TABLE users( login VARCHAR(%d), userid INTEGER, projid INTEGER ) ''' % NAMELEN) except DB_EXC.InternalError as e: # 如果发生错误，几乎总是这个表已经存在了 # 删除该表，重新创建 drop(cur) create(cur)# 删除数据库表的函数drop = lambda cur: cur.execute('DROP TABLE users')# 由用户名和用户ID组成的常量NAMES = ( ('bob', 1234), ('angela', 4567), ('dave', 4523))def randName(): # 生成器 pick = set(NAMES) while pick: yield pick.pop()def insert(cur, db): # 插入函数 # SQLite风格是qmark参数风格，而MySQL使用的是format参数风格 # 对于每个用户名-用户ID对，都会被分配到一个项目卒中。 # 项目ID从四个不同的组中随机选出的 if db == 'sqlite': cur.executemany("INSERT INTO users VALUES(?,?,?)", [(who, uid, rand(1, 5)) for who, uid in randName()]) elif db == 'mysql': cur.executemany("INSERT INTO users VALUES(%s, %s, %s)", [(who, uid, rand(1, 5)) for who, uid in randName()])# 返回最后一次操作后影响的行数，如果游标对象不支持该属性，则返回-1getRC = lambda cur: cur.rowcount if hasattr(cur, 'rowcount') else -1# update()和delete()函数会随机选择项目组中的成员# 更新操作会将其从当前组移动到另一个随机选择的组中# 删除操作会将该组的成员全部删除def update(cur): fr = rand(1, 5) to = rand(1, 5) cur.execute('UPDATE users SET projid=%d WHERE projid=%d' % (to, fr)) return fr, to, getRC(cur)def delete(cur): rm = rand(1, 5) cur.execute('DELETE FROM users WHERE projid=%d' % rm) return rm, getRC(cur)def dbDump(cur): # 来去所有行，将其按照打印格式进行格式化，然后显示 cur.execute('SELECT * FROM users') # 格式化标题 print('%s' % ''.join(map(cformat, FIELDS))) for data in cur.fetchall(): # 将数据(login,userid,projid)通过map()传递给tformat()， # 是数据转化为字符串，将其格式化为标题风格 # 字符串按照COLSIZ的列宽度进行左对齐 print(''.join(map(tformat, data)))def main(): # 主函数 db = setup() print('*** Connect to %r database' % db) cxn = connect(db) if not cxn: print('ERROR: %r not supported or unreadable, exit' % db) return cur = cxn.cursor() print('***Creating users table') create(cur=cur) print('***Inserting names into table') insert(cur, db) dbDump(cur) print('\n***Randomly moving folks') fr, to, num = update(cur) print('(%d users moved) from (%d) to (%d)' % (num, fr, to)) dbDump(cur) print('***Randomly choosing group') rm, num = delete(cur) print('\t(group #%d; %d users removed)' % (rm, num)) dbDump(cur) print('\n***Droping users table') drop(cur) print('\n*** Close cxns') cur.close() cxn.commit() cxn.close()if __name__ == '__main__': main() MySQL数据库访问结果 123456789101112131415161718192021222324252627Choose a database system: (M)ySQL (S)QLiteEnter choice:M*** Connect to &apos;mysql&apos; database***Creating users table***Inserting names into tableLOGIN USERID PROJID Dave 4523 2 Bob 1234 3 Angela 4567 3 ***Randomly moving folks(2 users moved) from (3) to (1)LOGIN USERID PROJID Dave 4523 2 Bob 1234 1 Angela 4567 1 ***Randomly choosing group (group #1; 2 users removed)LOGIN USERID PROJID Dave 4523 2 ***Droping users table*** Close cxns SQLite数据库访问结果 12345678910111213141516171819202122232425262728Choose a database system:(M)ySQL(S)QLiteEnter choice:S*** Connect to &apos;sqlite&apos; database***Creating users table***Inserting names into tableLOGIN USERID PROJID Dave 4523 1 Bob 1234 2 Angela 4567 3 ***Randomly moving folks(1 users moved) from (1) to (1)LOGIN USERID PROJID Dave 4523 1 Bob 1234 2 Angela 4567 3 ***Randomly choosing group(group #3; 1 users removed)LOGIN USERID PROJID Dave 4523 1 Bob 1234 2 ***Droping users table*** Close cxns]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据库编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python多线程(二)]]></title>
    <url>%2F2018%2F02%2F26%2FPython%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[在上篇主要对线程的概念做了一个简要的介绍，同时介绍了_thread模块和threading模块的使用方法，通过几个简短的程序实现了线程的调用。这篇将会记录一些多线程简单的应用以及相关生产者和消费者的问题。 多线程实践Python虚拟机是单线程（GIL）的原因，只有线程在执行I/O密集型的应用时才会更好地发挥Python的并发性。下面的例子是通过多线程下载图书排名信息的调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#!/usr/bin/python3# -*- coding:UTF-8 -*-from atexit import registerimport reimport threadingimport timeimport urllib.request# 匹配排名的正则表达式# 亚马逊的网站REGEX = re.compile(b'#([\d,]+) in Books')AMZN = 'https://www.amazon.com/dp/'# ISBN编号和书名ISBNs = &#123; '0132269937': 'Core Python Programming', '0132356139': 'Python Web Development with Django', '0137143419': 'Python Fundamentals'&#125;# 请求头# 因为亚马逊会检测爬虫,所以需要加上请求头伪装成浏览器访问headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 ' '(KHTML, like Gecko) Chrome/48.0.2564.116 Safari/537.36 TheWorld 7'&#125;def get_ranking(isbn): # 爬取网页,获取数据 # 使用str.format()格式化数据 url = '&#123;0&#125;&#123;1&#125;'.format(AMZN, isbn) # 爬取网页并解析 req = urllib.request.Request(url, headers=headers) page = urllib.request.urlopen(req) data = page.read() page.close() return str(REGEX.findall(data)[0], 'utf-8')def _show_ranking(isbn): # 显示结果 print('- %r ranked %s' % (ISBNs[isbn], get_ranking(isbn)))def _main(): print('At', time.ctime(), 'on Amazon...') for isbn in ISBNs: (threading.Thread(target=_show_ranking, args=(isbn,))).start() #_show_ranking(isbn)@registerdef _atexit(): # 注册一个退出函数，在脚本退出先请求调用这个函数 print('all DONE at:', time.ctime())if __name__ == '__main__': _main() 输出结果 12345At Tue Feb 27 10:40:51 2018 on Amazon...- &apos;Python Fundamentals&apos; ranked 4,358,513- &apos;Python Web Development with Django&apos; ranked 1,354,091- &apos;Core Python Programming&apos; ranked 458,510all DONE at: Tue Feb 27 10:42:39 2018 锁示例锁有两种状态:锁定 和 未锁定。同时它也支持两个函数：获得锁 和 释放锁。当多线程争夺锁时，允许第一个获得锁的线程进入临界区，并执行。之后到达的线程被阻塞，直到第一个线程执行结束，退出临界区，并释放锁。其他等待的线程随机获得锁并进入临界区。 锁和更多的随机性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#!/usr/bin/python3# -*- coding:UTF-8 -*-from __future__ import with_statementfrom atexit import registerfrom random import randrangefrom threading import Thread, Lock, current_threadfrom time import sleep, ctimeclass CleanOutputSet(set): # 集合的子类，将默认输出改变为将其所有元素 # 按照逗号分隔的字符串 def __str__(self): return ', '.join(x for x in self)# 锁# 随机数量的线程(3~6)，每个线程暂停或睡眠2~4秒lock = Lock()loops = (randrange(2, 5) for x in range(randrange(3, 7)))remaining = CleanOutputSet()def loop(sec): # 获取当前执行的线程名，然后获取锁并保存线程名 myname = current_thread().name lock.acquire() remaining.add(myname) print('[%s] Started %s' % (ctime(), myname)) # 释放锁并睡眠随机秒 lock.release() sleep(sec) # 重新获取锁，输出后再释放锁 lock.acquire() remaining.remove(myname) print('[%s] Completed %s (%d sec)' % (ctime(), myname, sec)) print(' (remaining: %s)' % (remaining or 'NONE')) lock.release()def loop_with(sec): myname = current_thread().name with lock: remaining.add(myname) print('[%s] Started %s' % (ctime(), myname)) sleep(sec) with lock: remaining.remove(myname) print('[%s] Completed %s (%d sec)' % (ctime(), myname, sec)) print(' (remaining: %s)' % (remaining or 'NONE'))def _main(): for pause in loops: # Thread(target=loop, args=(pause,)).start() Thread(target=loop_with, args=(pause,)).start()@registerdef _atexit(): print('all DONE at:', ctime())if __name__ == '__main__': _main() 输出结果 loop方法12345678910111213141516171819[Tue Feb 27 11:26:13 2018] Started Thread-1[Tue Feb 27 11:26:13 2018] Started Thread-2[Tue Feb 27 11:26:13 2018] Started Thread-3[Tue Feb 27 11:26:13 2018] Started Thread-4[Tue Feb 27 11:26:13 2018] Started Thread-5[Tue Feb 27 11:26:13 2018] Started Thread-6[Tue Feb 27 11:26:15 2018] Completed Thread-2 (2 sec) (remaining: Thread-3, Thread-4, Thread-1, Thread-5, Thread-6)[Tue Feb 27 11:26:15 2018] Completed Thread-6 (2 sec) (remaining: Thread-3, Thread-4, Thread-1, Thread-5)[Tue Feb 27 11:26:16 2018] Completed Thread-3 (3 sec) (remaining: Thread-4, Thread-1, Thread-5)[Tue Feb 27 11:26:16 2018] Completed Thread-4 (3 sec) (remaining: Thread-1, Thread-5)[Tue Feb 27 11:26:16 2018] Completed Thread-5 (3 sec) (remaining: Thread-1)[Tue Feb 27 11:26:17 2018] Completed Thread-1 (4 sec) (remaining: NONE)all DONE at: Tue Feb 27 11:26:17 2018 loop_with方法12345678910111213141516171819[Tue Feb 27 11:43:15 2018] Started Thread-1[Tue Feb 27 11:43:15 2018] Started Thread-2[Tue Feb 27 11:43:15 2018] Started Thread-3[Tue Feb 27 11:43:15 2018] Started Thread-4[Tue Feb 27 11:43:15 2018] Started Thread-5[Tue Feb 27 11:43:15 2018] Started Thread-6[Tue Feb 27 11:43:17 2018] Completed Thread-3 (2 sec) (remaining: Thread-1, Thread-5, Thread-4, Thread-6, Thread-2)[Tue Feb 27 11:43:17 2018] Completed Thread-6 (2 sec) (remaining: Thread-1, Thread-5, Thread-4, Thread-2)[Tue Feb 27 11:43:17 2018] Completed Thread-5 (2 sec) (remaining: Thread-1, Thread-4, Thread-2)[Tue Feb 27 11:43:18 2018] Completed Thread-1 (3 sec) (remaining: Thread-4, Thread-2)[Tue Feb 27 11:43:18 2018] Completed Thread-4 (3 sec) (remaining: Thread-2)[Tue Feb 27 11:43:18 2018] Completed Thread-2 (3 sec) (remaining: NONE)all DONE at: Tue Feb 27 11:43:18 2018 信号量示例对于拥有有限资源的应用来说，可以使用信号量的方式来代替锁。信号量 是一个计数器，当资源消耗时递减，当资源释放时递增。信号量比锁更加灵活，因为可以有多个线程，每个线程拥有有限资源的一个实例。消耗资源使计数器递减的操作成为P()，当一个线程对一个资源完成操作时，该资源返回资源池的操作称为V()。 糖果机和信号量 这个特制的机器只有5个可用的槽来保持库存。如果所有槽都满了，糖果不能再加入这个机器中；如果每个槽都空了，想要购买的消费者无法买到糖果。使用信号量来跟踪这些有限的资源 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#!/usr/bin/python3# -*- coding:UTF-8 -*-# 导入相应的模块和信号量类# BoundedSemaphore的额外功能是这个计数器的值永远不会超过它的初始值# 它可以防范其中信号量释放次数多余获得次数的异常用例from atexit import registerfrom random import randrangefrom threading import BoundedSemaphore, Lock, Threadfrom time import sleep, ctime# 全局变量# 锁# 库存商品最大值的常量# 糖果托盘lock = Lock()MAX = 5candytray = BoundedSemaphore(MAX)def refill(): # 当虚构的糖果机所有者向库存中添加糖果时执行 # 代码会输出用户的行动，并在某人添加的糖果超过最大库存是给予警告 lock.acquire() print('Refilling candy...') try: candytray.release() except ValueError: print('full, skipping') else: print('OK') lock.release()def buy(): # 允许消费者获取一个单位的库存 lock.acquire() print('Buying candy....') # 检测是否所有资源都已经消费完了 # 通过传入非阻塞的标志False，让调用不再阻塞，而在应当阻塞的时候返回一个False # 指明没有更多资源 if candytray.acquire(False): print('OK') else: print('Empty, skipping') lock.release()def producer(loops): for i in range(loops): refill() sleep(randrange(3))def consumer(loops): for i in range(loops): buy() sleep(randrange(3))def _main(): print('starting at:', ctime()) nloops = randrange(2, 6) print('THE CANDY MACHINE (full with %d bars)' % MAX) Thread(target=consumer, args=(randrange(nloops, nloops+MAX+2),)).start() Thread(target=producer, args=(nloops,)).start()@registerdef _atexit(): print('all DONE at:', ctime())if __name__ == '__main__': _main() 输出结果 12345678910111213141516171819202122232425262728293031starting at: Tue Feb 27 14:48:31 2018THE CANDY MACHINE (full with 5 bars)Buying candy....OKRefilling candy...OKRefilling candy...full, skippingBuying candy....OKRefilling candy...OKBuying candy....OKRefilling candy...OKRefilling candy...full, skippingBuying candy....OKBuying candy....OKBuying candy....OKBuying candy....OKBuying candy....OKBuying candy....Empty, skippingall DONE at: Tue Feb 27 14:48:42 2018 生产者-消费者问题和queue模块生产商品的时间是不确定的，消费生产者生产的商品的时间也是不确定的。在这个场景下将其放在类似队列的数据结构中。queue模块来提供线程间通信的机制，从而让线程之间可以互相分享数据。具体而言就是创建一个队列，让生产者在其中放入新的商品，而消费者消费这些商品 queue模块常用属性 属性 描述 Queue(maxsize=0) 创建一个先入先出队列。如果给定最大值，则在队列没有空间时阻塞，否则(没有指定最大值),为无限队列 LifoQueue(maxsize=0) 创建一个后入先出队列。如果给定最大值，则在队列没有空间时阻塞，否则(没有指定最大值),为无限队列 PriorityQueue(maxsize) 创建一个优先级队列。如果给定最大值，则在队列没有空间时阻塞，否则(没有指定最大值),为无限队列 queue异常 Empty 当对空队列调用get*()方法时抛出异常 Full 当对已满的队列调用put*()方法时抛出异常 queue对象方法 qsize() 返回队列大小(由于返回时队列大小可能被其他线程修改，所以改值为近似值) empty() 如果队列为空，则返回True；否则，返回False full() 如果队列已满，则返回True；否则，返回False put(item,block=True,timeout=None) 将item放入队列。如果block为True(默认)且timeout为None，则在有可用空间之前阻塞；如果timeout为正值，则最多阻塞timeout秒；如果block为False，则抛出Empty异常 put_nowait() 和put(item,False)相同 get(block=True,timeout=None) 从队列中取得元素，如果给定了block(非0)，则一直阻塞到有可用的元素为止 get_nowait() 和get(False)相同 task_done() 用于标识队列中的某个元素已执行完成，该方法会被下面的join()使用 join() 在队列中所有元素执行完毕并调用上面的task_done()信号之前，保持阻塞 生产者消费者问题使用了Queue对象，以及随机生产(消费)的商品的数量。生产者和消费者独立且并发地执行线程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#!/usr/bin/python3# -*- coding:UTF-8 -*-# 使用queue.Queue对象和之前的myThread.MyThread线程类from random import randintfrom time import sleepfrom queue import Queuefrom myThread import MyThreaddef writeQ(queue): # 将一个对象放入队列中 print('producing object for Q...') queue.put('xxx', 1) print('size now', queue.qsize())def readQ(queue): # 消费队列中的一个对象 val = queue.get(1) print('consumed object from Q... size now', queue.qsize())def writer(queue, loops): # 作为单个线程运行 # 向队列中放入一个对象，等待片刻，然后重复上述步骤 # 直至达到脚本执行时随机生成的次数没值 for i in range(loops): writeQ(queue) # 睡眠的随机秒数比reader短是为了阻碍reader从空队列中获取对象 sleep(randint(1, 3))def reader(queue, loops): # 作为单个线程运行 # 消耗队列中一个对象，等待片刻，然后重复上述步骤 # 直至达到脚本执行时随机生成的次数没值 for i in range(loops): readQ(queue) sleep(randint(2, 5))# 设置派生和执行的线程总数funcs = [writer, reader]nfuncs = range(len(funcs))def main(): nloops = randint(2, 5) q = Queue(32) threads = [] for i in nfuncs: t = MyThread(funcs[i], (q, nloops), funcs[i].__name__) threads.append(t) for i in nfuncs: threads[i].start() for i in nfuncs: threads[i].join() print('all DONE')if __name__ == '__main__': main() 输出结果 1234567891011121314starting at: Tue Feb 27 15:17:16 2018producing object for Q...size now 1starting at: Tue Feb 27 15:17:16 2018consumed object from Q... size now 0producing object for Q...size now 1producing object for Q...size now 2done at: Tue Feb 27 15:17:20 2018consumed object from Q... size now 1consumed object from Q... size now 0done at: Tue Feb 27 15:17:26 2018all DONE 线程的替代方案subprocess模块multiprocessing模块concurrent.futures模块]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python多线程(一)]]></title>
    <url>%2F2018%2F02%2F24%2FPython%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[多线程编程对于以下编程任务是非常理想的： 本质上是异步的 需要多个并发活动 每个活动的处理顺序可能是不确定的(随机、不可预测的) 使用多线程或者类似Queue的共享数据结构可以将一个串行程序规划成几个执行特定任务的线程 UserRequestThread: 负责读取客户端输入。程序将创建多个线程，每个客户端一个，客户端的请求将会被放入队列中 RequestProcessor: 该线程负责从队列中获取请求并进行处理，为第三个线程提供输出 ReplyThread: 负责向用户输出，将结果传回给用户，或者把数据写到本地文件系统或者数据库中 线程和进程 进程 计算机程序是储存在磁盘上的可执行二进制(或其他类型)的文件。进程 （有时称为 重量级进程）则是一个执行中的程序。每一个进程都拥有自己的地址空间、内存、数据栈以及其他用于跟踪执行的辅助数据。操作系统管理其上的所有进程的执行，并为它们合理地分配时间。进程可以通过 派生(fork或spawn)新的进程来执行任务,而进程之间的通信只能通过 进程间通信(IPC) 的方式共享信息 线程 线程（有时称为 轻量级进程）共享相同的上下文。相当于在主进程中并行运行的一些“迷你进程”。当其他线程运行是，它可以被抢占（中断）和临时挂起（睡眠），这种做法叫 让步(yielding)。早单核CPU系统中，线程的实际规划是：每个线程运行一小会儿，然后让步给其他线程（再次排队等待更多的CPU时间）。在整个进程的执行当中，每个线程执行它自己特定的任务，在必要时和其他线程进行结果通信。 线程与Python全局解释锁 对Python虚拟机的访问是由全局解释锁(GIL) 控制的。这个锁用来保证同时只能有一个线程运行。在多线程环境中，Python虚拟机将按照下面的方式执行。 设置GIL 切换进一个线程去运行 执行下面操作之一 a. 指定数量的字节码指令 b. 线程主动让出控制权(可以调用time.sleep(0)来完成) 把线程设置回睡眠状态(切换出线程) 解锁GIL 重复上述步骤 当调用外部代码(即，任意C/C++扩展的内置函数)时，GIL会保持锁定，直至函数执行结束。 退出线程 当一个线程完成函数的执行时，就会退出。还可以通过调用thread.exit()或者sys.exit()退出进程，或者抛出SystemExit异常，是线程退出。 _thread模块 _thread模块提供了派生线程、基本的同步数据结构(锁对象(lock object),也叫 原语锁、简单锁、互斥锁、互斥 和 二进制信号量) _thread模和锁对象 函数/方法 描述 _thread模块的函数 start_new_thread(function, args, kwargs = None) 派生一个新的线程，使用给定的args和可选的kwargs来执行function allocate_lock() 分配LockType锁对象 exit() 给线程退出命令 LockType锁对象的方法 acquire(wait = None) 尝试获取锁对象 locked() 如果获取了锁对象则返回True，否则，返回False release() 释放锁 使用线程一般方式 程序 123456789101112131415161718192021222324252627282930313233#!usr/bin/python3# -*- coding:UTF-8 -*-import _threadfrom time import ctime, sleepdef loop_0(): print('start loop_0 at:', ctime()) sleep(4) print('loop_0 done at:', ctime())def loop_1(): print('start loop_1 at:', ctime()) sleep(2) print('loop_1 done at:', ctime())def main(): print('starting at:', ctime()) # start_new_thread 方法即使要执行的 # 函数不需要参数，也需要传递一个空元组 _thread.start_new_thread(loop_0, ()) _thread.start_new_thread(loop_1, ()) # 阻止主线程的执行，保证其最后执行， # 后续去掉这种方式，引入锁的方式 sleep(6) print('all done at', ctime())if __name__ == '__main__': main() 执行结果 在主线程中同时开启了两个线程，loop_1()由于只睡眠了2s，所以先执行完，其实执行完loo_0()，线程执行的总时间是最慢的那个线程(loop_0() )的运行时间 123456starting at: Mon Feb 26 08:52:10 2018start loop_0 at: Mon Feb 26 08:52:10 2018start loop_1 at: Mon Feb 26 08:52:10 2018loop_1 done at: Mon Feb 26 08:52:12 2018loop_0 done at: Mon Feb 26 08:52:14 2018all done at Mon Feb 26 08:52:16 2018 使用锁对象 程序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#!usr/bin/python3# -*- coding:UTF-8 -*-import _threadfrom time import ctime, sleeploops = [4, 2]def loop(nloop, sec, lock): # nloop: 第几个线程 # sec: 时间 # lock: 分配的锁 print('start loop', nloop, 'at:', ctime()) sleep(sec) print('loop', nloop, 'done at:', ctime()) # 当时间到了的时候释放锁 lock.release()def main(): print('starting at:', ctime()) locks = [] nloops = range(len(loops)) for i in nloops: # 生成锁对象 # 通过allocate_lock()函数得到锁对象 # 通过acquire()取到每个锁 # 添加进locks列表 lock = _thread.allocate_lock() lock.acquire() locks.append(lock) for i in nloops: # 派生线程 # 传递循环号，时间、锁对象 _thread.start_new_thread(loop, (i, loops[i], locks[i])) for i in nloops: # 等待所有线程的锁都释放完了才执行主线程 while locks[i].locked(): pass print('all DONE at:', ctime())if __name__ == '__main__': main() 执行结果 未再设置时间等待所有线程执行结束，而是在线程全部结束后马上运行主线程代码 123456starting at: Mon Feb 26 09:37:39 2018start loop 1 at: Mon Feb 26 09:37:39 2018start loop 0 at: Mon Feb 26 09:37:39 2018loop 1 done at: Mon Feb 26 09:37:41 2018loop 0 done at: Mon Feb 26 09:37:43 2018all DONE at: Mon Feb 26 09:37:43 2018 threading模块threading模块提供了更高级别、功能更全面的线程管理,还包括许多非常好用的同步机制 threading模块的对象 对象 描述 Thread 表示一个执行线程的对象 Lock 锁原语对象(和thread模块中的锁一样) RLock 可重入锁对象，使单一线程可以（再次）获得已持有的锁（锁递归） Condition 条件变量对象，使得一个线程等待另一个线程满足特定的“条件”，比如改变状态或某个数据值 Event 条件变量的通用版本，任何数量的线程等待某个事件的发生，在改事件发生后所有线程将被激活 Semaphone 为线程间共享的有限资源提供一个“计数器”，如果没有可用资源时会被阻塞 BoundSemaphone 与Semaphone相似，不过它不允许超过初始值 Timer 与Thread相似，不过它要在运行前等待一段时间 Barrier 创建一个“障碍”,必须达到指定数量的线程后才可以继续 Thread类 Thread对象的属性和方法 属性 描述 name 线程名 ident 线程的标识符 daemon 布尔标志，表示这个线程是否是守护线程 Thread对象方法 init(group=None, target=None, name=None, args=(), kwargs={}, verbose=None, daemon=就返回None) 实例化一个线程对象，需要一个可调用的target，以及参数args或kargs。还可以传递name或group参数。daemon的值将会设定thread.daemon属性/标志 start() 开始执行该线程 run() 定义线程功能的方法(通常在子类中被应用开发者重写) join(timeout=None) 直至启动的线程终止之前一直挂起；除非给出了timeout(秒)，否则会一直阻塞 使用Thread类，可以有很多方法创建线程。其中比较相似的三种方法是： 创建Thread的实例，传给它一个函数 创建Thread的实例，传给它一个可调用的类实例 派生Thread的子类，并创建子类的实例 创建Thread的实例，传给它一个函数join() 方法可以让主线程等待所有线程执行完毕，或者在提供了超时时间的情况下达到超时时间。join()方法只有在需要等待线程完成的时候才是有用的。 代码 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/python# -*- coding:UTF-8 -*-import threadingfrom time import ctime, sleeploops = [4, 2]def loop(nloop, sec): print('start loop', nloop, 'at:', ctime()) sleep(sec) print('loop', nloop, 'done at:', ctime())def main(): print('starting at:', ctime()) threads = [] nloops = range(len(loops)) for i in nloops: t = threading.Thread(target=loop, args=(i, loops[i])) threads.append(t) for i in nloops: # 启动线程 threads[i].start() for i in nloops: # 等待所有线程结束 threads[i].join() print('all DONE at:', ctime())if __name__ == '__main__': main() 结果 123456starting at: Mon Feb 26 14:29:36 2018start loop 0 at: Mon Feb 26 14:29:36 2018start loop 1 at: Mon Feb 26 14:29:36 2018loop 1 done at: Mon Feb 26 14:29:38 2018loop 0 done at: Mon Feb 26 14:29:40 2018all DONE at: Mon Feb 26 14:29:40 2018 创建Thread的实例，传给它一个可调用的类实例将传递进去一个可调用类(实例)而不仅仅是一个函数 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/usr/bin/python3# -*- coding:UTF-8 -*-import threadingfrom time import ctime, sleeploops = [4, 2]class ThreadFunc(object): def __init__(self, func, args, name=''): self.name = name self.func = func self.args = args def __call__(self): # Thread类的代码将调用ThreadFunc对象，此时会调用这个方法 # 因为init方法已经设定相关值，所以不需要再将其传递给Thread()的构造函数 self.func(*self.args)def loop(nloop, sec): print('start loop', nloop, 'at:', ctime()) sleep(sec) print('loop ', nloop, 'done at:', ctime())def main(): print('starting at:', ctime()) threads = [] nloops = range(len(loops)) for i in nloops: # 创建所有线程 t = threading.Thread(target=ThreadFunc(loop, (i, loops[i]))) threads.append(t) for i in nloops: threads[i].start() for i in nloops: # 等待所有线程 threads[i].join() print('all DONE at:', ctime())if __name__ == '__main__': main() 结果 123456starting at: Mon Feb 26 14:47:28 2018start loop 0 at: Mon Feb 26 14:47:28 2018start loop 1 at: Mon Feb 26 14:47:28 2018loop 1 done at: Mon Feb 26 14:47:30 2018loop 0 done at: Mon Feb 26 14:47:32 2018all DONE at: Mon Feb 26 14:47:32 2018 派生Thread的子类，并创建子类的实例(推荐)将Thread子类化，而不是直接对其实例化。这将在定制线程对象的时候拥有更多的灵活性，也能简化线程创建的调用过程 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#!/usr/bin/python3# -*- coding:UTF-8 -*-import threadingfrom time import ctime, sleeploops = [4, 2]class MyThread(threading.Thread): def __init__(self, func, args, name=''): # 必须先调用基类的构造函数 threading.Thread.__init__(self) self.name = name self.func = func self.args = args def run(self): # 必须重写run()方法 self.func(*self.args)def loop(nloop, sec): print('start loop', nloop, 'at:', ctime()) sleep(sec) print('loop ', nloop, 'done at:', ctime())def main(): print('starting at:', ctime()) threads = [] nloops = range(len(loops)) for i in nloops: # 创建所有线程 t = MyThread(loop, (i, loops[i]), loop.__name__) threads.append(t) for i in nloops: threads[i].start() for i in nloops: # 等待所有线程 threads[i].join() print('all DONE at:', ctime())if __name__ == '__main__': main() 结果 123456starting at: Mon Feb 26 15:08:33 2018start loop 0 at: Mon Feb 26 15:08:33 2018start loop 1 at: Mon Feb 26 15:08:33 2018loop 1 done at: Mon Feb 26 15:08:35 2018loop 0 done at: Mon Feb 26 15:08:37 2018all DONE at: Mon Feb 26 15:08:37 2018 单线程和多线程执行的对比先后使用单线程和多线程执行三个独立的递归函数，代码中加入sleep()是为了减慢执行速度，能够更好的看到效果。 myThread.py 1234567891011121314151617181920212223#!/usr/bin/python3# -*- coding:UTF-8 -*-import threadingfrom time import ctime, sleepclass MyThread(threading.Thread): def __init__(self, func, args, name=''): threading.Thread.__init__(self) self.name = name self.func = func self.args = args def get_result(self): # 返回每一次的执行结果 return self.res def run(self): print('starting at:', ctime()) self.res = self.func(*self.args) print('done at:', ctime()) compare.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/usr/bin/python3# -*- coding:UTF-8 -*-from myThread import MyThreadfrom time import ctime, sleepdef fib(x): # 斐波拉契 sleep(0.005) if x &lt; 2: return 1 return fib(x-2)+fib(x-1)def fac(x): # 阶乘 sleep(0.1) if x &lt; 2: return 1 return x*fac(x-1)def sum(x): # 累加 sleep(0.1) if x &lt; 2: return 1 return x + sum(x-1)funcs = [fib, fac, sum]n = 12def main(): nfuncs = range(len(funcs)) print('***SINGLE THREAD***') for i in nfuncs: # 单线程顺序执行 print('starting', funcs[i].__name__, 'at:', ctime()) print(funcs[i](n)) print(funcs[i].__name__, 'finished at:', ctime(), '\n') print('\n ***MULTIPLE THREADS***') threads = [] for i in nfuncs: # 多线程执行 t = MyThread(funcs[i], (n,),funcs[i].__name__) threads.append(t) for i in nfuncs: threads[i].start() for i in nfuncs: threads[i].join() print(threads[i].get_result()) print('all DONE')if __name__ == '__main__': main() 结果 12345678910111213141516171819202122232425***SINGLE THREAD***starting fib at: Mon Feb 26 15:36:22 2018233fib finished at: Mon Feb 26 15:36:24 2018starting fac at: Mon Feb 26 15:36:24 2018479001600fac finished at: Mon Feb 26 15:36:25 2018starting sum at: Mon Feb 26 15:36:25 201878sum finished at: Mon Feb 26 15:36:26 2018 ***MULTIPLE THREADS***starting at: Mon Feb 26 15:36:26 2018starting at: Mon Feb 26 15:36:26 2018starting at: Mon Feb 26 15:36:26 2018done at: Mon Feb 26 15:36:28 2018done at: Mon Feb 26 15:36:28 2018done at: Mon Feb 26 15:36:29 201823347900160078all DONE]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python网络编程(二)]]></title>
    <url>%2F2018%2F02%2F24%2FPython%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[上篇对Python中的socket模块的简单应用做了描述和记录，下面便是对SocketServer模块和Twisted框架做一个简要的记录 socketserver模块socketserver是标准库的一个高级模块，它的目标是简化很多样板代码，它们是创建网络客户端和服务器所必需的代码。 socketserver模块类 类 描述 BaseServer 包含核心服务器功能和mix-in类的钩子；仅用于推导，这样不会创建这个类的实例；可以用TCPServer或UDPServer创建类的实例 TCPServer/UDPServer 基础的网络同步TCP/UDP服务器 UnixStreamServer/UnixDatagramServer 基于文件的基础同步TCP/UDP服务器 ForkingMixIn/ThreadingMixIn 核心派出或线程功能；只用作mix-in类与一个服务器类配合实现一些异步性；不能直接实例化这个类 ForkingTCPServer/ForkingUDPServer ForkingMaxIn和TCPServer/UDPServer的组合 ThreadingTCPServer/ThreadingUDPServer ThreadingMixIn和TCPServer/UDPServer的组合 BaseRequestHandler 包含处理服务请求的核心功能；仅用于推导，无法创建这个类的实例；可以使用StreamRequestHandler或DatagramRequestHandler创建类的实例 StreamRequestHandler/DatagramRequestHandler 实现TCP/UDP服务器的服务处理器 socketserver TCP服务器/客户端在原始服务器循环中，我们阻塞等待请求，当接收到请求时就对其提供服务，然后继续等待。在此处的服务器循环中，并非在服务器中创建代码，而是定义一个处理程序，当服务器接收到一个传入的请求时，服务器就可以调用 TCP服务器 1234567891011121314151617181920212223242526272829#!usr/bin/python3# -*- coding:UTF-8 -*-# 导入socketserver相关的类和time.ctime()的全部属性from socketserver import (TCPServer as TCP, StreamRequestHandler as SRH)from time import ctimeHOST = ''PORT = 12345ADDR = (HOST, PORT)class MyRequestHandler(SRH): # MyRequestHandler继承自StreamRequestHandler def handle(self): # 重写handle方法，当接收到一个客户端消息是，会调用handle()方法 print('...connected from:', self.client_address) # StreamRequestHandler将输入和输出套接字看做类似文件的对象 # 所以使用write()将字符串返回客户端，用readline()来获取客户端信息 self.wfile.write(bytes('[%s] %s' % ( ctime(), self.rfile.readline().decode('utf-8')), 'utf-8'))# 利用给定的主机信息和请求处理类创建了TCP服务器# 然后无限循环地等待并服务于客户端请求tcpServ = TCP(ADDR, MyRequestHandler)print('waiting for connection...')tcpServ.serve_forever() TCP客户端 12345678910111213141516171819202122232425#!usr/bin/python3# -*- coding:UTF-8 -*-from socket import *HOST = '127.0.0.1'PORT = 12345BUFSIZE = 1024ADDR = (HOST, PORT)while True: tcpSocket = socket(AF_INET, SOCK_STREAM) tcpSocket.connect(ADDR) data = input('&gt; ') if not data: break # 因为处理程序类对待套接字通信像文件一样，所以必须发送行终止符。 # 而服务器只是保留并重用这里发送的终止符 tcpSocket.send(bytes('%s\r\n' % data, 'utf-8')) data = tcpSocket.recv(BUFSIZE) if not data: break # 得到服务器返回的消息时，用strip()函数对其进行处理并使用print()自动提供的换行符 print(data.decode('utf-8').strip()) tcpSocket.close() socketserver TCP服务器和客户端运行结果 在客户端启动的时候连接了一次服务器，而每一次发送一个请求连接一次，所以发送了三个请求连接了四次服务器 TCP服务器运行结果 12345waiting for connection......connected from: (&apos;127.0.0.1&apos;, 51835)...connected from: (&apos;127.0.0.1&apos;, 51877)...connected from: (&apos;127.0.0.1&apos;, 51893)...connected from: (&apos;127.0.0.1&apos;, 51901) TCP客户端运行结果 1234567&gt; hello[Sat Feb 24 10:29:28 2018] hello&gt; hello[Sat Feb 24 10:29:44 2018] hello&gt; hi[Sat Feb 24 10:29:50 2018] hi&gt; Twisted框架的简单使用 Twisted是一个完整的事件驱动的网络框架，利用它既能使用也能开发完整的异步网络应用程序和协议。它不是Python标准库的一部分，所以需要单独下载和安装它1。 1pip3 install Twisted-17.9.0-cp36-cp36m-win_amd64.whl 安装成功显示 1234567891011Processing e:\迅雷下载\twisted-17.9.0-cp36-cp36m-win_amd64.whlRequirement already satisfied: Automat&gt;=0.3.0 in e:\python\python36\lib\site-packages (from Twisted==17.9.0)Requirement already satisfied: zope.interface&gt;=4.0.2 in e:\python\python36\lib\site-packages (from Twisted==17.9.0)Requirement already satisfied: incremental&gt;=16.10.1 in e:\python\python36\lib\site-packages (from Twisted==17.9.0)Requirement already satisfied: hyperlink&gt;=17.1.1 in e:\python\python36\lib\site-packages (from Twisted==17.9.0)Requirement already satisfied: constantly&gt;=15.1 in e:\python\python36\lib\site-packages (from Twisted==17.9.0)Requirement already satisfied: attrs in e:\python\python36\lib\site-packages (from Automat&gt;=0.3.0-&gt;Twisted==17.9.0)Requirement already satisfied: six in e:\python\python36\lib\site-packages (from Automat&gt;=0.3.0-&gt;Twisted==17.9.0)Requirement already satisfied: setuptools in e:\python\python36\lib\site-packages (from zope.interface&gt;=4.0.2-&gt;Twisted==17.9.0)Installing collected packages: TwistedSuccessfully installed Twisted-17.9.0 Twisted Reactor TCP 服务器/客户端TCP服务器 123456789101112131415161718192021222324252627282930313233#!usr/bin/python3# -*- coding:UTF-8 -*-# 常用模块导入，特别是twisted.internet的protocol和reactorfrom twisted.internet import protocol, reactorfrom time import ctime# 设置端口号PORT = 12345class TWServProtocol(protocol.Protocol): # 继承Protocol类 def connectionMade(self): # 重写connectionMade()方法 # 当一个客户端连接到服务器是会执行这个方法 client = self.client = self.transport.getPeer().host print('...connected from:', client) def dataReceived(self, data): # 重写dataReceived()方法 # 当服务器接收到客户端通过网络发送的一些数据的时候会调用此方法 self.transport.write(bytes('[%s] %s' % ( ctime(), data.decode('utf-8')), 'utf-8'))# 创建一个协议工厂，每次得到一个接入连接是，制造协议的一个实例# 在reactor中安装一个TCP监听器，以此检查服务请求# 当接收到一个请求时，就是创建一个就是创建一个TWServProtocol实例来处理客户端事务factory = protocol.Factory()factory.protocol = TWServProtocolprint('waiting for connection...')reactor.listenTCP(PORT, factory)reactor.run() TCP客户端 12345678910111213141516171819202122232425262728293031323334353637383940#!usr/bin/python# -*- coding:UTF-8 -*-from twisted.internet import protocol, reactorHOST = '127.0.0.1'PORT = 12345class TWClientProtocol(protocol.Protocol): def sendData(self): # 需要发送数据时调用 # 会在一个循环中继续，直到不输入任何内容来关闭连接 data = input('&gt; ') if data: print('...send %s...' % data) self.transport.write(bytes(data, 'utf-8')) else: self.transport.loseConnection() def connectionMade(self): # self.sendData() def dataReceived(self, data): print(data.decode('utf-8')) self.sendData()class TWClientFactory(protocol.ClientFactory): # 创建了一个客户端工厂 protocol = TWClientProtocol clientConnectionLost = clientConnectionFailed = \ lambda self, connector, reason: reactor.stop()# 创建了一个到服务器的连接并运行reactor，实例化了客户端工厂# 因为这里不是服务器，需要等待客户端与我们通信# 并且这个工厂为每一次连接都创建一个新的协议对象。# 客户端创建单个连接到服务器的协议对象，而服务器的工厂则创建一个来与客户端通信reactor.connectTCP(HOST, PORT, TWClientFactory())reactor.run() TCP服务器和客户端运行结果 服务器结果 12waiting for connection......connected from: 127.0.0.1 客户端结果 1234567&gt; hello...send hello...[Sat Feb 24 11:19:49 2018] hello&gt; hi...send hi...[Sat Feb 24 11:20:02 2018] hi&gt; 1.需要安装python对应的版本和位数 ↩]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python网络编程(一)]]></title>
    <url>%2F2018%2F02%2F22%2FPython%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[使用Python的一些模块来创建网络应用程序 socket()函数模块要创建套接字，必须使用socket.socket()函数socket(socket_family, socket_type, protocol = 0),其中socket_family是 AF_UNIX或 AF_INET,socket_type是 SOCK_STREAM 或 SOCK_DGRAM。1protocol通常省略，默认为0。 创建TCP/IP套接字 1tcpSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 创建UDP/IP套接字 1udpSock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) 套接字对象内接方法 名称 描述 服务器套接字方法 s.bind() 将地址(主机名、端口号对)绑定到套接字上 s.listen() 设置并启动TCP监听器 s.accept() 被动接受TCP客户端连接，一直等待知道连接到达(阻塞) 客户端套接字方法 s.connect() 主动发起TCP服务器连接 s.connect_ex() connect()的扩展版本，此时会以错误码的形式返回问题，而不是抛出一个异常 普通的套接字方法 s.recv() 接受TCP消息 s.recv_into() 接受TCP消息到指定的缓冲区 s.send() 发送TCP消息 s.sendall() 完整地发送TCP消息 s.recvfrom() 接受UDP消息 s.recvfrom_into() 接受UDP消息到指定的缓冲区 s.sendto() 发送UDP消息 s.getpeername() 连接到套接字(TCP)的远程地址 s.getsockname() 当前套接字的地址 s.getsockopt() 返回给定套接字选项的值 s.setsockopt() 设置给定套接字选项的值 s.shutdown() 关闭连接 s.close() 关闭套接字 s.detach() 在未关闭文件描述符的情况下关闭套接字，返回文件描述符 s.ioctl() 控制套接字的模式(仅支持Windows) 面向阻塞的套接字方法 s.setblocking() 设置套接字的阻塞或非阻塞模式 s.settimeout() 设置阻塞套接字操作的超时时间 s.gettimeout() 获取阻塞套接字操作的超时时间 面向文件的套接字方法 s.fileno() 套接字的文件描述符 s.makefile() 创建与套接字关联的文件对象 数据属性 s.family 套接字家族 s.type 套接字类型 s.proto 套接字协议 socket模块属性 属性名称 描述 数据属性 AF_UNIX、AF_INET、AF_INET6、AF_NETLINK、AF_TIPC Python中支持的套接字地址家族 SO_STREAM、SO_DGRAM 套接字类型(TCP=流，UDP=数据报) has_ipv6 指示是否支持IPv6的布尔标记 异常 error 套接字相关错误 herror 主机和地址相关错误 gaierror 地址相关错误 timeout 超时时间 函数 socket() 以给定的地址家族、套接字类型和协议类型(可选) 创建一个套接字对象 socketpair() 以给定的地址家族、套接字类型和协议类型(可选) 创建一个套接字对象 create_connection() 常规函数，它接收一个地址(主机号，端口号)对，返回套接字对象 fromfd() 以一个打开的文件描述符创建一个套接字对象 ssl() 通过套接字启动一个安全套接字层连接；不执行证书验证 getaddrinfo() 获取一个五元组序列形式的地址信息 getnameinfo() 给定一个套接字地址，返回(主机名，端口号)二元组 getfqdn() 返回完整的域名 gethostname() 返回当前主机名 gethostbyname() 将一个主机名映射到它的IP地址 gethostbyname_ex() gethostbyname()的扩展版本，它返回主机名、别名主机集合和IP地址列表 gethostbyaddr() 讲一个IP地址映射到DNS信息；返回与gethostbyname_ex()相同的三元组 getprotobyname() 将一个协议名(如‘TCP’)映射到一个数字 getservbyname()/getservbyport() 将一个服务名映射到一个端口号，或者反过来；对于任何一个函数来说，协议名都是可选的 ntohl()/ntohs() 将来自网络的整数装换为主机字节序 htonl()/htons() 将来自主机的整数转换为网络字节序 inet_aton()/inet_ntoa() 将IP地址八进制字符串转换成32位的包格式，或者反过来(仅用于IPv4地址) inet_pton()/inet_ntop() 将IP地址字符串转换成打包的二进制格式，或者反过来(同时适用于IPv4和IPv6) getdefaulttimeout()/setdefaulttimeout() 以秒(浮点数)为单位返回默认套接字超时时间；以秒(浮点数)为单位设置默认套接字超时时间 详情参阅socket模块文档 创建TCP服务器/客户端TCP服务器 下面是TCP服务器端的通用伪码，这是设计服务器的一种方式，可根据需求修改来操作服务器 123456789ss = socket() #创建服务器套接字ss.bind() #套接字与地址绑定ss.listen() #监听连接inf_loop: #服务器无线循环 cs = ss.accept() #接受客户端连接 comm_loop: #通信循环 cs.recv()/cs.send() #对话(接收/发送) cs.close() #关闭客户端套接字ss.close() #关闭服务器套接字 TCP时间戳服务器 12345678910111213141516171819202122232425262728293031323334353637383940#!usr/bin/python3# -*- coding:UTF-8 -*-# 导入socket模块和time.ctime()的所有属性from socket import *from time import ctime# HOST变量是空白，这是对bind()方法的标识，标识它可以使用任何可用的地址# 选择一个随机的端口号# 缓冲区大小为1KBHOST = ''PORT = 12345BUFSIZE = 1024ADDR = (HOST, PORT)# 分配了TCP服务套接字# 将套接字绑定到服务器地址# 开启TCP的监听调用# listen()方法的参数是在连接被转接或拒绝之前，传入连接请求的最大数tcpSerSock = socket(AF_INET, SOCK_STREAM)tcpSerSock.bind(ADDR)tcpSerSock.listen(5)while True: # 服务器循环，等待客户端的连接的连接 print('waiting for connection...') tcpCliSock, addr = tcpSerSock.accept() print('...connected from:', addr) while True: # 当一个连接请求出现时，进入对话循环，接收消息 data = tcpCliSock.recv(BUFSIZE) if not data: # 当消息为空时，退出对话循环 # 关闭客户端连接，等待下一个连接请求 break tcpCliSock.send(bytes('[%s] %s' % ( ctime(), data.decode('utf-8')), 'utf-8')) tcpCliSock.close() TCP客户端 下面是TCP客户端的通用伪码 12345cs = socket() #创建客户端套接字cs.connect() #尝试连接服务器comm_loop: #通信循环 cs.send()/cs.recv #对话(发送/接收)cs.close() #关闭客户端套接字 TCP时间戳客户端 1234567891011121314151617181920212223242526272829303132333435#!usr/bin/python3# -*- coding: UTF-8 -*-# 导入socket模块所有属性from socket import *# 服务器的主机名# 服务器的端口号,应与服务器设置的完全相同# 缓冲区大小为1KBHOST = '127.0.0.1'PORT = 12345BUFSIZE = 1024ADDR = (HOST, PORT)# 分配了TCP客户端套接字# 主动调用并连接到服务器tcpCliSock = socket(AF_INET, SOCK_STREAM)tcpCliSock.connect(ADDR)while True: # 无限循环，输入消息 data = bytes(input('&gt; '), 'utf-8') if not data: # 消息为空则退出循环 break # 发送输入的信息 # 接收服务器返回的信息，最后打印 tcpCliSock.send(data) data = tcpCliSock.recv(BUFSIZE) if not data: # 消息为空则退出循环 break print(data.decode('utf-8'))# 关闭客户端tcpCliSock.close() TCP服务器和客户端运行结果 在运行程序时，必须 首先运行服务器 程序，然后再运行客户端程序。如果先运行客户端程序，将会报未连接到服务器的错误。 按正确的顺序启动程序后，在客户端输入信息，将会接收到加上时间戳处理后的信息，如果直接输入回车，将会关闭客户端，而服务器将会等待下一个连接请求 服务器运行结果 123waiting for connection......connected from: (&apos;127.0.0.1&apos;, 53220)waiting for connection... 客户端运行结果 12345678&gt; hello[Fri Feb 23 14:22:58 2018] hello&gt; hi[Fri Feb 23 14:23:02 2018] hi&gt; hello world[Fri Feb 23 14:23:09 2018] hello world&gt;Process finished with exit code 0 创建UDP服务器/客户端UDP服务器 下面是UDP服务器的伪码 12345ss = socket() #创建服务器套接字ss.bind() #绑定服务器套接字inf_loop: #服务器无线循环 cs = ss.recvfrom()/ss.sendto() #关闭(接收/发送)ss.close() #关闭服务器套接字 UDP时间戳服务器 1234567891011121314151617181920212223#!usr/bin/python3# -*- coding:UTF-8 -*-# 导入socket模块和time.ctime()的全部属性from socket import *from time import ctime# 与TCP相同，由于是无连接，所以没有调用监听传入连接HOST = ''PORT = 12345BUFSIZE = 1024ADDR = (HOST, PORT)udpSerSock = socket(AF_INET, SOCK_DGRAM)udpSerSock.bind(ADDR)while True: # 进入循环等待消息，一条消息到达时，处理并返回它，然后等待下一条消息 print('waiting for message...') data, addr = udpSerSock.recvfrom(BUFSIZE) udpSerSock.sendto(bytes('[%s] %s' % ( ctime(), data.decode('utf-8')), 'utf-8'), addr) print('...received from and returned to:', addr) UDP客户端 下面是客户端的伪码 1234cs = socket() #创建客户端套接字comm_loop: #通信循环 cs.sendto()/cs.recvfrom() #对话(发送/接收)cs.close() #关闭客户端套接字 UDP时间戳客户端 12345678910111213141516171819202122#!usr/bin/python3 # -*- coding:UTF-8 -*- from socket import * HOST = '127.0.0.1' PORT = 12345 BUFSIZE = 1024 ADDR = (HOST, PORT) udpClienSock = socket(AF_INET, SOCK_DGRAM) while True: data = bytes(input('&gt;'), 'utf-8') if not data: break udpClienSock.sendto(data, ADDR) data, ADDR = udpClienSock.recvfrom(BUFSIZE) if not data: break print(data.decode('utf-8')) udpClienSock.close() UDP服务器和客户端运行结果 因为UDP面向无连接的服务，所以程序的启动顺序没有要求。当服务器处理完一个数据报之后在等待下一个继续处理 服务器运行结果 12345waiting for message......received from and returned to: (&apos;127.0.0.1&apos;, 51434)waiting for message......received from and returned to: (&apos;127.0.0.1&apos;, 51434)waiting for message... 客户端运行结果 1234567&gt;hello[Fri Feb 23 15:23:57 2018] hello&gt;hi[Fri Feb 23 15:24:03 2018] hi&gt;Process finished with exit code 0 1.AF_UNIX 是基于文件的套接字，代表 地址家族(address family):UNIX，AF_INET 是基于网络的套接字，代表 地址家族：因特网， AF_INET6 用于底6版因特网协议(IPv6)寻址。 SOCK_STREAM 表示面向连接的TCP套接字， SOCK_DGRAM 代表无连接的UDP套接字。 ↩]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python正则表达式(三)]]></title>
    <url>%2F2018%2F02%2F12%2FPython%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[在之前的两篇博文中，已经对正则表达式基本及核心的知识点进行了罗列和总结。而对于正则表达式的使用却缺乏实践。本文将基于《Python核心编程(第三版)》的练习题进行一些练习。 正则表达式 识别后续的字符串：“bat”、“bit”、“but”、“hat”、“hit”或者“hut”。 1234567891011121314import remode = re.compile(r'bat|bit|but|hat|hit|hut')#mode = re.compile(r'[bh][iau]t')strs = ['bat', 'bit', 'but', 'hat', 'hit', 'hut']for s in strs: if mode.match(s) is not None:mode.match(s).group()#输出结果'bat''bit''but''hat''hit''hut' 匹配由单个空格分隔的任意单词对，也就是姓和名。 12345678import remode = re.compile(r'^[A-Za-z]+ [A-Za-z]+$')strs = ['david Bob', 'D.Jone Steven', 'Lucy D May']for s in strs: if mode.match(s) is not None:mode.match(s).group()#输出结果'david Bob' 匹配由单个逗号和单个空白符分隔的任何单词和单个字母，如姓氏的首字母。 123456789import remode = re.compile(r'[A-Za-z]+,\s[A-Za-z]+')strs = ['david, Bob', 'D.Jone, Steven', 'Lucy, D, May']for s in strs: if mode.match(s) is not None:mode.match(s).group()#输出结果'david, Bob''Lucy, D' 匹配所有有效Python 标识符1的集合。 123456789101112import remode = re.compile(r'[^0-9][\w_]+')#用in排除关键字strs = ['1var', 'v_ar', '_var', 'var', 'var_9', 'var_']for s in strs: if mode.match(s) is not None:mode.match(s).group()#输出结果'v_ar''_var''var''var_9''var_' 根据读者当地的格式，匹配街道地址（使你的正则表达式足够通用，来匹配任意数量的街道单词，包括类型名称）。例如，美国街道地址使用如下格式：1180 BordeauxDrive。使你的正则表达式足够灵活，以支持多单词的街道名称，如3120 De la CruzBoulevard。 123456789import remode = re.compile(r'^\d&#123;4&#125;( [A-Z][a-z]+)+$')strs = ['1221 Bordeaux Drive', '54565 Bordeaux Drive', 'Bordeaux Drive', '1221 Bordeaux Drive Drive']for s in strs: if mode.match(s) is not None:mode.match(s).group()#输出结果'1221 Bordeaux Drive''1221 Bordeaux Drive Drive' 匹配以“www”起始且以“.com”结尾的简单Web 域名；例如，www://www. yahoo.com/。选做题：你的正则表达式也可以支持其他高级域名，如.edu、.net 等（例如，http://www.foothill.edu）。 1234567891011import remode = re.compile(r'^(http[s]?://)?www\.(\w+\.)+(com|net|edu)$')strs=['https://www.baidu.com', 'http://www.bilibili.com', 'www.baidu.com', 'baidu.com', 'www.cqupt.edu']for s in strs: if mode.match(s) is not None:mode.match(s).group()#输出结果'https://www.baidu.com''http://www.bilibili.com''www.baidu.com''www.cqupt.edu' 匹配所有能够表示Python 整数的字符串集。 12345678910import remode = re.compile(r'^\d+[lL]?$')strs = ['123', '123l', '12312L']for s in strs: if mode.match(s) is not None:mode.match(s).group()#输出结果'123''123l''12312L' 匹配所有能够表示Python 长整数的字符串集。 123456789import remode = re.compile(r'^\d+[lL]$')strs = ['123', '123l', '12312L']for s in strs: if mode.match(s) is not None:mode.match(s).group()#输出结果'123l''12312L' 匹配所有能够表示Python 浮点数的字符串集。 12345678910import remode = re.compile(r'(0|[1-9]\d*)(\.\d+)?$')strs = ['00.10', '0.123', '12.23', '12', '12.36l']for s in strs: if mode.match(s) is not None:mode.match(s).group() #输出结果'0.123''12.23''12' 匹配所有能够表示Python 复数的字符串集。 12345678910import remode = re.compile(r'^((0|[1-9]\d*)(\.\d+)?\+)?((0|[1-9]\d*)(\.\d+)?j)?$')strs = ['12.3+1.2j', '1+2j', '4j']for s in strs: if mode.match(s) is not None:mode.match(s).group() #输出结果'12.3+1.2j''1+2j''4j' 匹配所有能够表示有效电子邮件地址的集合（从一个宽松的正则表达式开始，然后尝试使它尽可能严谨，不过要保持正确的功能）。 123456789101112import remode = re.compile(r'^\w+@(\w+\.)+(com|com\.cn|net)$')strs = ['12345@qq.com', 'sina@163.com', 'qq@sina.com.cn', 'net@21cn.com', 'new123@163.sina.com']for s in strs: if mode.match(s) is not None:mode.match(s).group() #输出结果'12345@qq.com''sina@163.com''qq@sina.com.cn''net@21cn.com''new123@163.sina.com' type()。内置函数type()返回一个类型对象，如下所示，该对象将表示为一个Pythonic类型的字符串。 12345678910import remode = re.compile(r'&lt;type \'(.*)\'&gt;')strs = ['&lt;type \'int\'&gt;', '&lt;type \'float\'&gt;', '&lt;type \'builtin_function_or_method\'&gt;']for s in strs: if mode.match(s) is not None:mode.match(s).group(1)#输出结果'int''float''builtin_function_or_method' 处理日期。1.2 节提供了来匹配单个或者两个数字字符串的正则表达式模式，来表示1～9 的月份(0?[1-9])。创建一个正则表达式来表示标准日历中剩余三个月的数字。 12345678910import remode = re.compile(r'1[0-2]')strs = ['10', '11', '12']for s in strs: if mode.match(s) is not None:mode.match(s).group()#输出结果'10''11''12' 创建一个允许使用连字符的正则表达式，但是仅能用于正确的位置。例如，15 位的信用卡号码使用4-6-5 的模式，表明4 个数字-连字符-6 个数字-连字符-5 个数字；16 位的信用卡号码使用4-4-4-4 的模式。 123456789import remode = re.compile(r'\d&#123;4&#125;-((\d&#123;6&#125;-\d&#123;5&#125;)|(\d&#123;4&#125;-\d&#123;4&#125;-\d&#123;4&#125;))')strs = ['1234-567890-12345', '1234-5678-8012-3456']for s in strs: if mode.match(s) is not None:mode.match(s).group()#输出结果'1234-567890-12345''1234-5678-8012-3456' 1.标识符有字母、数字、下划线组成，但不能由数字开头 ↩]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python正则表达式(二)]]></title>
    <url>%2F2018%2F02%2F10%2FPython%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[正则表达式的匹配规则基本已经在上一篇博文中全部罗列出来了，下面便是结合到具体语言进行学习和练习了。由于个人兴趣和想要专研的方向，在这里将会使用Python 1 语言进行描述。 正则表达式和Python语言re模块：核心函数和方法 函数方法 描述 仅仅是re函数模块 compile(pattern, flags=0) 使用任何可选的标记来编译正则表达式的模式，然后返回一个正则表达式对象 re模块函数和正则表达式对象的方法 match(pattern, string, flags=0) 尝试使用带有可选的标记的正则表达式的模式来匹配字符串，如果匹配成功，就返回匹配对象；如果失败，就返回None search(pattern, string, flags=0) 使用可选标记搜索字符串中第一次出现的正则表达式模式。如果匹配成功，则返回匹配对象；如果匹配失败，怎返回None findall(pattern, string [,flags]) 查找字符串中所有(非重复)出现的正则表达式模式，并返回一个匹配列表 finditer(pattern, string[,flags]) 与findall()函数相同，但返回的不是一个列表，而是一个迭代器。对于每一次匹配，迭代器都返回一个匹配对象 split(pattern, string, max=0) 根据正则表达式的模式分隔符，split函数将字符串分割为列表，然后返回成功的列表，分割最多操作max次(默认分割所有匹配成功的位置) sub(pattern, repl, string, count=0) 使用repl替换所有正则表达式的模式在字符串中出现的位置，除非定义count，否则就讲替换所有出现的位置（另见subn()函数，该函数返回替换操作的数目） purge() 清除隐式编译的正则表达式模式 常见的匹配对象方法 group(num=0) 返回整个匹配对象，或者编号为num的特定子组 groups(default=None) 返回一个包含所有匹配子组的元组(如果没有成功匹配，则返回一个空元组) groupdict(default=None) 返回一个包含所有匹配的命名子组的字典，所有的子组名称作为字典的键(如果没有成功匹配，则返回一个空字典) 常用的模块属性（用于大多数正则表达式函数的标记） re.I,re.IGNORECASE 不去分大小写的匹配 re.L,re.LOCALE 根据所使用的本地语言环境通过\w、\w、\b、\B、\s、\S实现匹配 re.M,re.MULTILINE ^和$分别匹配目标字符串中行的起始和结尾，而不是严格匹配整个字符串本身的起始和结尾 re.S,re.DOTALL “.”(点号)通常匹配除了\n(换行符)之外的所有单个字符：该标记表示”.”(点号)能匹配全部字符 re.X,re.VERBOSE 通过反斜线转移，否则所有空格加上#(以及在该行中后续文字)都被忽略，除非在一个字符类中或者允许注释并且提高可读性 部分方法总结 compile(pattern, flags=0)2 使用预编译使用推荐的方式，但不是必须的，可以通过设置标志位(上表已罗列出使用频繁的标记，详情可以查阅文档),标志位通过 （|）合并 group(num=0) 和 groups(default=None) 匹配对象3的两个主要方法。 group() 要么返回整个匹配对象，要么按要求返回特定子组。 groups() 仅返回一个包含唯一或全部子组的元组。如果没有子组的要求，group() 返回整个匹配，groups() 返回一个空元组。 match(pattern, string, flags=0) match() 方法试图从字符串的起始部分对模式进行匹配。如果匹配成功，返回一个匹配对象；如果失败就返回None 12345678910111213 #匹配成功 m = re.match('foo', 'foo') #模式匹配字符串 if m is not None: #如果匹配成功，就输出匹配内容 m.group()'foo' #输出结果#匹配失败m = re.match('foo', 'Bfoo') #模式匹配字符串if m is not None: #如果匹配成功，就输出匹配内容 m.group() #因为起始字符为'B',所以匹配不成功，无任何输出 search(pattern, string, flags=0) search() 的工作方式和 match() 相同，不同之处在于 search() 会用它的字符串参数在任意位置对给定正则表达式模式搜索第一次出现的匹配情况。如果搜索到成功的匹配，就返回一个匹配对象；否则，就返回None。 123456#将上面使用match()方法匹配的串改用search()匹配m = re.search('foo', 'Bfoo') #模式匹配字符串if m is not None: #如果匹配成功，就输出匹配内容 m.group()'foo' #可以看到就算起始位置未能匹配，也能匹配成功 findall(pattern, string[,flags]) 和 finditer(pattern, string[,flags]) findall() 总是返回一个列表，如果没有找到匹配对象，返回一个空列表 finditer() 是一个与 findall() 类似但更节省内存的变体，finditer() 在匹配对象中迭代4 1234567891011121314#findall()匹配re.findall('car', 'carry the barcardi to the car') #模式匹配字符串['car', 'car', 'car'] #返回结果#finditer()匹配iter = re.finditer('car', 'carry the barcardi to the car') #模式匹配字符串for i in iter: #遍历迭代器 print(i.group())#输出结果carcarcar sub(pattern, repl, string, count=0) 和 subn(pattern, repl, string, count=0) sub() 和 subn() 用于实现搜索和替换功能。两者都是将某字符串中所有匹配正则表达式的部分进行某种形式的替换。和 sub() 不同的是，subn() 返回一个表示替换的总数，替换后的字符串和表示替换总数的数字一起作为一个拥有两个元素的元组返回 12345678910#sub()re.sub('car', 'cat', 'My car is not only a car.') #模式匹配字符串'My cat is not only a cat.' #输出结果#subn()re.subn('car', 'cat', 'My car is not only a car.') #模式匹配字符串('My cat is not only a cat.', 2) #输出结果 split(pattern, string, max=0) 正则表达式对象的 split() 方法和字符串的工作方式类似，但它是基于正则表达式的模式分割字符串。 123456789101112131415161718192021222324re.split(':', 'str1:str2:str3') #模式匹配字符串['str1', 'str2', 'str3'] #输出结果，与'str1:str2:str3'.split(':')相同#split()复杂用法#使用split()基于逗号分割字符串，如果空格紧跟在5个数字或者两个大写字母之后，就用split()分割该空格#使用(?=)正向前视断言，不适用输入字符串 而是使用后面的空格作为分割字符串import reDATA = ( 'Mountain View, CA 94040', 'Sunnyvale, CA', 'Los Altos, 94023', 'Cupertino 95014', 'Palo Alto CA',)for datum in DATA: print(re.split(', |(?= (?:\d&#123;5&#125;|[A-Z]&#123;2&#125;)) ', datum))#输出结果['Mountain View', 'CA', '94040']['Sunnyvale', 'CA']['Los Altos', '94023']['Cupertino', '95014']['Palo Alto', 'CA'] 符号的使用| 与 . 和 [] 包括择一匹配符号|、点号.，点号不匹配非字符或换行付\n（即空字符） 字符集[]中的字符只取其一 重复、特殊字符5以及分组 ?操作符表示前面的模式出现零次或一次+操作符表示前面的模式出现至少一次*操作符表示前面的模式出现任意次(包括0次)分组从左起第一个括号开始算第一个分组 123456789101112131415m = re.match('(\w(\w\w))-(\d\d\d)','abc-123')m.group() #完整匹配'abc-123' #输出结果m.group(1) #第一组'abc' #输出结果 m.group(2) #第二组'bc' #输出结果m.group(3) #第三组'123' #输出结果m.groups() #全部子组('abc', 'bc', '123') #输出结果 1.这里Python指代的是Python3.6.4 ↩2.预编译可以提升执行效率，而 re.compile() 方法提供了这个功能。模块函数会对已编译的对象进行缓存，所以无论使用 match() 和 search() 在执行时编译的正则表达式,还是使用 compile() 编译的表达式,在再次使用时都会查询缓存。但使用 compile() 同样可以节省查询缓存的时间 ↩3.除了正则表达式对象之外，还有另外一个对象类型：匹配对象。这些是成功调用 match() 和 search() 返回的对象。 ↩4.如果遇到无法调用 next()方法，可以使用 __next__()方法代替。 ↩5.特殊字符的详情可以参考上一篇博文 ↩]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python正则表达式(一)]]></title>
    <url>%2F2018%2F02%2F09%2FPython%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[在Python的学习过程中，正则表达式始终是一道绕不过去的坎.无论提取服务器日志文件还是爬取网页，正则表达式始终扮演着至关重要的角色。下面便对自己学习过程中的一些正则表达式基础做一个总结。 特殊符号和字符 表示法 描述 正则表达式示例 备注 符号 literal 匹配文本字符串的字面值literal foo 只是匹配foo，相当于取等 re1&#124; re2 匹配正则表达式re1或re2 foo&#124; bar 匹配foo或者bar，二选一 . 匹配任何字符(除了\n之外) a.a 匹配axa、aaa、aca等，两个a中间可以是除了\n的任意字符 ^ 匹配字符串起始部分 ^Foo 匹配Foo，不匹配aFoo $ 匹配字符串终止部分 Bar$ 只匹配Bar,不匹配aBar等 * 匹配0次或者多次前面出现的正则表达式 [A-Za-z0-9]* 匹配任意多个字母或数字 + 匹配1次或者多次前面出现的正则表达式 [A-Za-z0-9]+ 匹配一到多个个字母或数字 ? 匹配0次或者1次前面出现的正则表达式 [A-Za-z0-9] 要么有一个字母或数字要么没有 {N} 匹配N次前面出现的正则表达式 [0-9]{3} 匹配三个数字 {M,N} 匹配M~N次前面出现的正则表达式 [0-9]{5,9} 匹配5到9个数字(包括5个和9个) […] 匹配来自字符集的任意单一字符 [aeiou] 匹配一个元音字母 [..x~y..] 匹配x~y范围内的任意单一字符 [A-Za-z] 匹配任意一个英文字母 [^…] 不匹配此字符集中出现的任何一个字符，包括某一范围的字符(如果在此字符集中出现) [\^aeiou][\^A-Za-z0-9] 匹配一个非元音字母和一个非字母数字字符 (*&#124;+&#124;?&#124;{})? 用于匹配上面频繁出现/重复出现符号的非贪婪版本(*、+、?、{}) .*?[a-z] (非贪婪是指尽可能少的匹配) (…) 匹配封闭的正则表达式,然后另存为子组 f(oo&#124; u)bar 匹配foobar,fubar 特殊字符 \d 匹配任何十进制数字，与[0-9]一致(\D和\d相反，不匹配任何非数值型的数字) data\d+.txt 匹配data1.txt、data12.txt \w 匹配任何字母数字字符，与[A-Za-z0-9]相同(\W与之相反) [A-Za-z_]\w+ 匹配任意字母或_加一个或多个字母数字字符(asda,_asda) \s 匹配任何空格字符，与[\n\t\r\v\f]相同(\S与之相反) of\sthe 匹配of the (\n:换行符&#124;\t:水平制表符&#124;\r:回车&#124;\v:垂直制表符&#124;\f:换页符) \b 匹配任何单词边界(\B与之相反) \bThe\b 匹配of The a，不匹配ofThe a \N 匹配已保存的子组N(与上面(…)配合使用) price:\16 匹配price:和前面第16个子组的值 \c 逐字匹配任何特殊字符(即仅按字面意义匹配，不包含特殊含义，\为对特殊字符的转义表示) * 匹配* \A(\Z) 匹配字符串的起始(结束)(另见上面的^和$) \ADear 匹配以Dear开头的 扩展表示法 （?iLmsux） 在正则表达式中嵌入一个或多个特殊”标记”参数(或者通过函数/方法) （?x）,(?im) (?:…) 表示一个匹配不用保存的分组 (?:\w+.)* 匹配任意多个一个或多个字母数字字符与.的组合但不保存改分组 (?P…) 像一个仅由name标识而不是数字ID标识的正则分组匹配 (?P) 给匹配的分组命名为data (?P=name) 在同一个字符串中匹配由(?P)分组之前的文本 (?P=data) 匹配名字为data的串 (?#…) 表示注释，所有内容都被忽略 (?#comment) (?=…) 匹配条件是如果…出现在之后的位置，而不使用输入字符串；称作正向前视断言 (?=.com) 如果一个字符串后面跟着“.com”才做匹配操作，并不适用任何目标字符串 (?!…) 匹配条件是如果…不出现在之后的位置，而不使用输入字符串；称作负向前视断言 (?!.net) 如果一个字符串后面不是跟着“.net”，才做匹配操作 (?&lt;=…) 匹配条件是如果…出现在之前的位置，而不使用输入字符串；称作正向后视断言 (?&lt;=800-) 如果字符串之前为“800-”才做匹配，并不使用任何输入字符串 (?&lt;!…) 匹配条件是如果…不出现在之前的位置，而不使用输入字符串；称作负向后视断言 (?&lt;!192\.168\.) 如果一个字符串之前不是“192.168.”才做匹配，并不适用任何输入字符串 (?(id/name)Y&#124;N 如果分组所提供的id或name(名称)存在，就返回正则表达式的条件匹配Y，如果不存在，就返回N;N是可选项 (?(1)y&#124;x) 如果一个匹配组1(\1)存在就y匹配；否则，就与x匹配 以上为正则表达式的一些基本的符号定义与用法，熟练掌握这些符号是写出高效表达式的基础。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
</search>
